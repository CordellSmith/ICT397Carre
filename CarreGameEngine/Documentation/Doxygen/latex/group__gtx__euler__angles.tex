\hypertarget{group__gtx__euler__angles}{
\section{GLM\_\-GTX\_\-euler\_\-angles}
\label{group__gtx__euler__angles}\index{GLM\_\-GTX\_\-euler\_\-angles@{GLM\_\-GTX\_\-euler\_\-angles}}
}


Collaboration diagram for GLM\_\-GTX\_\-euler\_\-angles:Build matrices from Euler angles.  
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g5fb8269b6795f95dec7ca7bbe61805f6}{glm::eulerAngleX} (T const \&angleX)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g558b0e0fd3c1f6a414d184a22c968b79}{glm::eulerAngleY} (T const \&angleY)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_ge77e2c08c118ecd34ffc8ca425d2cf77}{glm::eulerAngleZ} (T const \&angleZ)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g6a2dc9bf80aecdffb3e5ab3bcede6647}{glm::eulerAngleXY} (T const \&angleX, T const \&angleY)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_gd26afd5add0e121296d3b44dea32f32e}{glm::eulerAngleYX} (T const \&angleY, T const \&angleX)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g9b63e52fda0b7773c50bbf3c310bdcf2}{glm::eulerAngleXZ} (T const \&angleX, T const \&angleZ)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g3709f9eb45b49ecf41d42bec91c031fa}{glm::eulerAngleZX} (T const \&angle, T const \&angleX)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g9ac024a16439421d2a3c7c17b6df31b5}{glm::eulerAngleYZ} (T const \&angleY, T const \&angleZ)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_gfcd7d34bef520fd8bee6d4d865a8162a}{glm::eulerAngleZY} (T const \&angleZ, T const \&angleY)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g7ba74fb9419dd90256b682855e904159}{glm::eulerAngleYXZ} (T const \&yaw, T const \&pitch, T const \&roll)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_ga254d26a7a42b65101f4eee88d5b153f}{glm::yawPitchRoll} (T const \&yaw, T const \&pitch, T const \&roll)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat2x2$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_g026f776506cd9c5b144c6d4b410a079b}{glm::orientate2} (T const \&angle)
\item 
{\footnotesize template$<$typename T$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat3x3$<$ T, defaultp $>$ \hyperlink{group__gtx__euler__angles_gce794db535af3056d97f4f62e7ed7509}{glm::orientate3} (T const \&angle)
\item 
{\footnotesize template$<$typename T, precision P$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat3x3$<$ T, P $>$ \hyperlink{group__gtx__euler__angles_g114ce533cc2f140cb17ca5a44214d973}{glm::orientate3} (detail::tvec3$<$ T, P $>$ const \&angles)
\item 
{\footnotesize template$<$typename T, precision P$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, P $>$ \hyperlink{group__gtx__euler__angles_g98f6c8d3b6b97ff0ae2f64544142cb7f}{glm::orientate4} (detail::tvec3$<$ T, P $>$ const \&angles)
\end{CompactItemize}


\subsection{Detailed Description}
Build matrices from Euler angles. 

$<$glm/gtx/euler\_\-angles.hpp$>$ need to be included to use these functionalities. 

\subsection{Function Documentation}
\hypertarget{group__gtx__euler__angles_g5fb8269b6795f95dec7ca7bbe61805f6}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleX@{eulerAngleX}}
\index{eulerAngleX@{eulerAngleX}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleX]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleX (T const \& {\em angleX})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g5fb8269b6795f95dec7ca7bbe61805f6}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from an euler angle X. \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 14 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

Referenced by glm::eulerAngleXZ(), and glm::eulerAngleZX().

\begin{Code}\begin{verbatim}17         {
18                 T cosX = glm::cos(angleX);
19                 T sinX = glm::sin(angleX);
20         
21                 return detail::tmat4x4<T, defaultp>(
22                         T(1), T(0), T(0), T(0),
23                         T(0), cosX, sinX, T(0),
24                         T(0),-sinX, cosX, T(0),
25                         T(0), T(0), T(0), T(1));
26         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:

Here is the caller graph for this function:\hypertarget{group__gtx__euler__angles_g6a2dc9bf80aecdffb3e5ab3bcede6647}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleXY@{eulerAngleXY}}
\index{eulerAngleXY@{eulerAngleXY}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleXY]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleXY (T const \& {\em angleX}, \/  T const \& {\em angleY})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g6a2dc9bf80aecdffb3e5ab3bcede6647}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (X $\ast$ Y). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 62 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

\begin{Code}\begin{verbatim}66         {
67                 T cosX = glm::cos(angleX);
68                 T sinX = glm::sin(angleX);
69                 T cosY = glm::cos(angleY);
70                 T sinY = glm::sin(angleY);
71 
72                 return detail::tmat4x4<T, defaultp>(
73                         cosY,   -sinX * -sinY,  cosX * -sinY,   T(0),
74                         T(0),   cosX,           sinX,           T(0),
75                         sinY,   -sinX * cosY,   cosX * cosY,    T(0),
76                         T(0),   T(0),           T(0),           T(1));
77         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g9b63e52fda0b7773c50bbf3c310bdcf2}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleXZ@{eulerAngleXZ}}
\index{eulerAngleXZ@{eulerAngleXZ}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleXZ]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleXZ (T const \& {\em angleX}, \/  T const \& {\em angleZ})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g9b63e52fda0b7773c50bbf3c310bdcf2}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (X $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 100 of file euler\_\-angles.inl.

References glm::eulerAngleX(), and glm::eulerAngleZ().

\begin{Code}\begin{verbatim}104         {
105                 return eulerAngleX(angleX) * eulerAngleZ(angleZ);
106         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g558b0e0fd3c1f6a414d184a22c968b79}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleY@{eulerAngleY}}
\index{eulerAngleY@{eulerAngleY}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleY]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleY (T const \& {\em angleY})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g558b0e0fd3c1f6a414d184a22c968b79}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from an euler angle Y. \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 30 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

Referenced by glm::eulerAngleYZ(), and glm::eulerAngleZY().

\begin{Code}\begin{verbatim}33         {
34                 T cosY = glm::cos(angleY);
35                 T sinY = glm::sin(angleY);
36 
37                 return detail::tmat4x4<T, defaultp>(
38                         cosY,   T(0),   -sinY,  T(0),
39                         T(0),   T(1),   T(0),   T(0),
40                         sinY,   T(0),   cosY,   T(0),
41                         T(0),   T(0),   T(0),   T(1));
42         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:

Here is the caller graph for this function:\hypertarget{group__gtx__euler__angles_gd26afd5add0e121296d3b44dea32f32e}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleYX@{eulerAngleYX}}
\index{eulerAngleYX@{eulerAngleYX}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleYX]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleYX (T const \& {\em angleY}, \/  T const \& {\em angleX})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_gd26afd5add0e121296d3b44dea32f32e}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Y $\ast$ X). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 81 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

\begin{Code}\begin{verbatim}85         {
86                 T cosX = glm::cos(angleX);
87                 T sinX = glm::sin(angleX);
88                 T cosY = glm::cos(angleY);
89                 T sinY = glm::sin(angleY);
90 
91                 return detail::tmat4x4<T, defaultp>(
92                         cosY,          0,      -sinY,    T(0),
93                         sinY * sinX,  cosX, cosY * sinX, T(0),
94                         sinY * cosX, -sinX, cosY * cosX, T(0),
95                         T(0),         T(0),     T(0),    T(1));
96         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g7ba74fb9419dd90256b682855e904159}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleYXZ@{eulerAngleYXZ}}
\index{eulerAngleYXZ@{eulerAngleYXZ}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleYXZ]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleYXZ (T const \& {\em yaw}, \/  T const \& {\em pitch}, \/  T const \& {\em roll})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g7ba74fb9419dd90256b682855e904159}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Y $\ast$ X $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 140 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

\begin{Code}\begin{verbatim}145         {
146                 T tmp_ch = glm::cos(yaw);
147                 T tmp_sh = glm::sin(yaw);
148                 T tmp_cp = glm::cos(pitch);
149                 T tmp_sp = glm::sin(pitch);
150                 T tmp_cb = glm::cos(roll);
151                 T tmp_sb = glm::sin(roll);
152 
153                 detail::tmat4x4<T, defaultp> Result;
154                 Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
155                 Result[0][1] = tmp_sb * tmp_cp;
156                 Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
157                 Result[0][3] = static_cast<T>(0);
158                 Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
159                 Result[1][1] = tmp_cb * tmp_cp;
160                 Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
161                 Result[1][3] = static_cast<T>(0);
162                 Result[2][0] = tmp_sh * tmp_cp;
163                 Result[2][1] = -tmp_sp;
164                 Result[2][2] = tmp_ch * tmp_cp;
165                 Result[2][3] = static_cast<T>(0);
166                 Result[3][0] = static_cast<T>(0);
167                 Result[3][1] = static_cast<T>(0);
168                 Result[3][2] = static_cast<T>(0);
169                 Result[3][3] = static_cast<T>(1);
170                 return Result;
171         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g9ac024a16439421d2a3c7c17b6df31b5}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleYZ@{eulerAngleYZ}}
\index{eulerAngleYZ@{eulerAngleYZ}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleYZ]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleYZ (T const \& {\em angleY}, \/  T const \& {\em angleZ})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g9ac024a16439421d2a3c7c17b6df31b5}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Y $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 120 of file euler\_\-angles.inl.

References glm::eulerAngleY(), and glm::eulerAngleZ().

\begin{Code}\begin{verbatim}124         {
125                 return eulerAngleY(angleY) * eulerAngleZ(angleZ);
126         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_ge77e2c08c118ecd34ffc8ca425d2cf77}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleZ@{eulerAngleZ}}
\index{eulerAngleZ@{eulerAngleZ}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleZ]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleZ (T const \& {\em angleZ})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_ge77e2c08c118ecd34ffc8ca425d2cf77}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from an euler angle Z. \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 46 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

Referenced by glm::eulerAngleXZ(), glm::eulerAngleYZ(), glm::eulerAngleZX(), and glm::eulerAngleZY().

\begin{Code}\begin{verbatim}49         {
50                 T cosZ = glm::cos(angleZ);
51                 T sinZ = glm::sin(angleZ);
52 
53                 return detail::tmat4x4<T, defaultp>(
54                         cosZ,   sinZ,   T(0), T(0),
55                         -sinZ,  cosZ,   T(0), T(0),
56                         T(0),   T(0),   T(1), T(0),
57                         T(0),   T(0),   T(0), T(1));
58         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:

Here is the caller graph for this function:\hypertarget{group__gtx__euler__angles_g3709f9eb45b49ecf41d42bec91c031fa}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleZX@{eulerAngleZX}}
\index{eulerAngleZX@{eulerAngleZX}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleZX]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleZX (T const \& {\em angle}, \/  T const \& {\em angleX})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g3709f9eb45b49ecf41d42bec91c031fa}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Z $\ast$ X). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 110 of file euler\_\-angles.inl.

References glm::eulerAngleX(), and glm::eulerAngleZ().

\begin{Code}\begin{verbatim}114         {
115                 return eulerAngleZ(angleZ) * eulerAngleX(angleX);
116         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_gfcd7d34bef520fd8bee6d4d865a8162a}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!eulerAngleZY@{eulerAngleZY}}
\index{eulerAngleZY@{eulerAngleZY}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[eulerAngleZY]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::eulerAngleZY (T const \& {\em angleZ}, \/  T const \& {\em angleY})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_gfcd7d34bef520fd8bee6d4d865a8162a}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Z $\ast$ Y). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 130 of file euler\_\-angles.inl.

References glm::eulerAngleY(), and glm::eulerAngleZ().

\begin{Code}\begin{verbatim}134         {
135                 return eulerAngleZ(angleZ) * eulerAngleY(angleY);
136         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g026f776506cd9c5b144c6d4b410a079b}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!orientate2@{orientate2}}
\index{orientate2@{orientate2}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[orientate2]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat2x2$<$ T, defaultp $>$ glm::orientate2 (T const \& {\em angle})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g026f776506cd9c5b144c6d4b410a079b}


Creates a 2D 2 $\ast$ 2 rotation matrix from an euler angle. \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 210 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

\begin{Code}\begin{verbatim}213         {
214                 T c = glm::cos(angle);
215                 T s = glm::sin(angle);
216 
217                 detail::tmat2x2<T, defaultp> Result;
218                 Result[0][0] = c;
219                 Result[0][1] = s;
220                 Result[1][0] = -s;
221                 Result[1][1] = c;
222                 return Result;
223         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g114ce533cc2f140cb17ca5a44214d973}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!orientate3@{orientate3}}
\index{orientate3@{orientate3}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[orientate3]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, precision P$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat3x3$<$ T, P $>$ glm::orientate3 (detail::tvec3$<$ T, P $>$ const \& {\em angles})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g114ce533cc2f140cb17ca5a44214d973}


Creates a 3D 3 $\ast$ 3 rotation matrix from euler angles (Y $\ast$ X $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 249 of file euler\_\-angles.inl.

References glm::yawPitchRoll().

\begin{Code}\begin{verbatim}252         {
253                 return detail::tmat3x3<T, P>(yawPitchRoll(angles.z, angles.x, angles.y));
254         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_gce794db535af3056d97f4f62e7ed7509}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!orientate3@{orientate3}}
\index{orientate3@{orientate3}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[orientate3]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat3x3$<$ T, defaultp $>$ glm::orientate3 (T const \& {\em angle})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_gce794db535af3056d97f4f62e7ed7509}


Creates a 2D 4 $\ast$ 4 homogeneous rotation matrix from an euler angle. \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 227 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

\begin{Code}\begin{verbatim}230         {
231                 T c = glm::cos(angle);
232                 T s = glm::sin(angle);
233 
234                 detail::tmat3x3<T, defaultp> Result;
235                 Result[0][0] = c;
236                 Result[0][1] = s;
237                 Result[0][2] = 0.0f;
238                 Result[1][0] = -s;
239                 Result[1][1] = c;
240                 Result[1][2] = 0.0f;
241                 Result[2][0] = 0.0f;
242                 Result[2][1] = 0.0f;
243                 Result[2][2] = 1.0f;
244                 return Result;
245         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_g98f6c8d3b6b97ff0ae2f64544142cb7f}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!orientate4@{orientate4}}
\index{orientate4@{orientate4}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[orientate4]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, precision P$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, P $>$ glm::orientate4 (detail::tvec3$<$ T, P $>$ const \& {\em angles})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_g98f6c8d3b6b97ff0ae2f64544142cb7f}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Y $\ast$ X $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 258 of file euler\_\-angles.inl.

References glm::yawPitchRoll().

\begin{Code}\begin{verbatim}261         {
262                 return yawPitchRoll(angles.z, angles.x, angles.y);
263         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__euler__angles_ga254d26a7a42b65101f4eee88d5b153f}{
\index{gtx\_\-euler\_\-angles@{gtx\_\-euler\_\-angles}!yawPitchRoll@{yawPitchRoll}}
\index{yawPitchRoll@{yawPitchRoll}!gtx_euler_angles@{gtx\_\-euler\_\-angles}}
\subsubsection[yawPitchRoll]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, defaultp $>$ glm::yawPitchRoll (T const \& {\em yaw}, \/  T const \& {\em pitch}, \/  T const \& {\em roll})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__euler__angles_ga254d26a7a42b65101f4eee88d5b153f}


Creates a 3D 4 $\ast$ 4 homogeneous rotation matrix from euler angles (Y $\ast$ X $\ast$ Z). \begin{Desc}
\item[See also:]\hyperlink{group__gtx__euler__angles}{GLM\_\-GTX\_\-euler\_\-angles} \end{Desc}


Definition at line 175 of file euler\_\-angles.inl.

References glm::cos(), and glm::sin().

Referenced by glm::orientate3(), and glm::orientate4().

\begin{Code}\begin{verbatim}180         {
181                 T tmp_ch = glm::cos(yaw);
182                 T tmp_sh = glm::sin(yaw);
183                 T tmp_cp = glm::cos(pitch);
184                 T tmp_sp = glm::sin(pitch);
185                 T tmp_cb = glm::cos(roll);
186                 T tmp_sb = glm::sin(roll);
187 
188                 detail::tmat4x4<T, defaultp> Result;
189                 Result[0][0] = tmp_ch * tmp_cb + tmp_sh * tmp_sp * tmp_sb;
190                 Result[0][1] = tmp_sb * tmp_cp;
191                 Result[0][2] = -tmp_sh * tmp_cb + tmp_ch * tmp_sp * tmp_sb;
192                 Result[0][3] = static_cast<T>(0);
193                 Result[1][0] = -tmp_ch * tmp_sb + tmp_sh * tmp_sp * tmp_cb;
194                 Result[1][1] = tmp_cb * tmp_cp;
195                 Result[1][2] = tmp_sb * tmp_sh + tmp_ch * tmp_sp * tmp_cb;
196                 Result[1][3] = static_cast<T>(0);
197                 Result[2][0] = tmp_sh * tmp_cp;
198                 Result[2][1] = -tmp_sp;
199                 Result[2][2] = tmp_ch * tmp_cp;
200                 Result[2][3] = static_cast<T>(0);
201                 Result[3][0] = static_cast<T>(0);
202                 Result[3][1] = static_cast<T>(0);
203                 Result[3][2] = static_cast<T>(0);
204                 Result[3][3] = static_cast<T>(1);
205                 return Result;
206         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:

Here is the caller graph for this function: