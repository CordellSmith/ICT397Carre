\hypertarget{classbt_convex2d_convex2d_algorithm}{
\section{btConvex2dConvex2dAlgorithm Class Reference}
\label{classbt_convex2d_convex2d_algorithm}\index{btConvex2dConvex2dAlgorithm@{btConvex2dConvex2dAlgorithm}}
}
{\tt \#include $<$btConvex2dConvex2dAlgorithm.h$>$}

Inheritance diagram for btConvex2dConvex2dAlgorithm:Collaboration diagram for btConvex2dConvex2dAlgorithm:\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
virtual btScalar \hyperlink{classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e}{calculateTimeOfImpact} (btCollisionObject $\ast$body0, btCollisionObject $\ast$body1, const btDispatcherInfo \&dispatchInfo, \hyperlink{classbt_manifold_result}{btManifoldResult} $\ast$resultOut)
\item 
virtual void \hyperlink{classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4}{getAllContactManifolds} (\hyperlink{classbt_aligned_object_array}{btManifoldArray} \&manifoldArray)
\end{CompactItemize}


\subsection{Detailed Description}
The convex2dConvex2dAlgorithm collision algorithm support 2d collision detection for btConvex2dShape Currently it requires the \hyperlink{classbt_minkowski_penetration_depth_solver}{btMinkowskiPenetrationDepthSolver}, it has support for 2d penetration depth computation 

\subsection{Member Function Documentation}
\hypertarget{classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e}{
\index{btConvex2dConvex2dAlgorithm@{btConvex2dConvex2dAlgorithm}!calculateTimeOfImpact@{calculateTimeOfImpact}}
\index{calculateTimeOfImpact@{calculateTimeOfImpact}!btConvex2dConvex2dAlgorithm@{btConvex2dConvex2dAlgorithm}}
\subsubsection[calculateTimeOfImpact]{\setlength{\rightskip}{0pt plus 5cm}btScalar btConvex2dConvex2dAlgorithm::calculateTimeOfImpact (btCollisionObject $\ast$ {\em body0}, \/  btCollisionObject $\ast$ {\em body1}, \/  const btDispatcherInfo \& {\em dispatchInfo}, \/  {\bf btManifoldResult} $\ast$ {\em resultOut})\hspace{0.3cm}{\tt  \mbox{[}virtual\mbox{]}}}}
\label{classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e}




Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold

Linear motion for one of objects needs to exceed m\_\-ccdSquareMotionThreshold col0-$>$m\_\-worldTransform,

Convex0 against sphere for Convex1

Simplification, one object is simplified as a sphere

Sphere (for convex0) against Convex1

Simplification, one object is simplified as a sphere 

Implements \hyperlink{classbt_collision_algorithm}{btCollisionAlgorithm}.\hypertarget{classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4}{
\index{btConvex2dConvex2dAlgorithm@{btConvex2dConvex2dAlgorithm}!getAllContactManifolds@{getAllContactManifolds}}
\index{getAllContactManifolds@{getAllContactManifolds}!btConvex2dConvex2dAlgorithm@{btConvex2dConvex2dAlgorithm}}
\subsubsection[getAllContactManifolds]{\setlength{\rightskip}{0pt plus 5cm}virtual void btConvex2dConvex2dAlgorithm::getAllContactManifolds ({\bf btManifoldArray} \& {\em manifoldArray})\hspace{0.3cm}{\tt  \mbox{[}inline, virtual\mbox{]}}}}
\label{classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4}




should we use m\_\-ownManifold to avoid adding duplicates? 

Implements \hyperlink{classbt_collision_algorithm}{btCollisionAlgorithm}.

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
C:/Users/New/Documents/Games\_\-Technology/Year4\_\-Semester1/ICT397/$\sim$My Work/Assignment1/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.h\item 
C:/Users/New/Documents/Games\_\-Technology/Year4\_\-Semester1/ICT397/$\sim$My Work/Assignment1/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/btConvex2dConvex2dAlgorithm.cpp\end{CompactItemize}
