\hypertarget{group__gtx__rotate__normalized__axis}{
\section{GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis}
\label{group__gtx__rotate__normalized__axis}\index{GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis@{GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis}}
}


Collaboration diagram for GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis:Quaternions and matrices rotations around normalized axis.  
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\footnotesize template$<$typename T, precision P$>$ }\\GLM\_\-FUNC\_\-DECL detail::tmat4x4$<$ T, P $>$ \hyperlink{group__gtx__rotate__normalized__axis_g9fc93bb16dd6719fc660a506cb833fb0}{glm::rotateNormalizedAxis} (detail::tmat4x4$<$ T, P $>$ const \&m, T const \&angle, detail::tvec3$<$ T, P $>$ const \&axis)
\item 
{\footnotesize template$<$typename T, precision P$>$ }\\GLM\_\-FUNC\_\-DECL detail::tquat$<$ T, P $>$ \hyperlink{group__gtx__rotate__normalized__axis_g34cc3bc3287bc3f56bac3c3a70cea353}{glm::rotateNormalizedAxis} (detail::tquat$<$ T, P $>$ const \&q, T const \&angle, detail::tvec3$<$ T, P $>$ const \&axis)
\end{CompactItemize}


\subsection{Detailed Description}
Quaternions and matrices rotations around normalized axis. 

$<$glm/gtx/rotate\_\-normalized\_\-axis.hpp$>$ need to be included to use these functionalities. 

\subsection{Function Documentation}
\hypertarget{group__gtx__rotate__normalized__axis_g34cc3bc3287bc3f56bac3c3a70cea353}{
\index{gtx\_\-rotate\_\-normalized\_\-axis@{gtx\_\-rotate\_\-normalized\_\-axis}!rotateNormalizedAxis@{rotateNormalizedAxis}}
\index{rotateNormalizedAxis@{rotateNormalizedAxis}!gtx_rotate_normalized_axis@{gtx\_\-rotate\_\-normalized\_\-axis}}
\subsubsection[rotateNormalizedAxis]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, precision P$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tquat$<$ T, P $>$ glm::rotateNormalizedAxis (detail::tquat$<$ T, P $>$ const \& {\em q}, \/  T const \& {\em angle}, \/  detail::tvec3$<$ T, P $>$ const \& {\em axis})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__rotate__normalized__axis_g34cc3bc3287bc3f56bac3c3a70cea353}


Rotates a quaternion from a vector of 3 components normalized axis and an angle.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em q}]Source orientation \item[{\em angle}]Angle expressed in radians if GLM\_\-FORCE\_\-RADIANS is define or degrees otherwise. \item[{\em axis}]Normalized axis of the rotation, must be normalized.\end{description}
\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{group__gtx__rotate__normalized__axis}{GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis} \end{Desc}


Definition at line 75 of file rotate\_\-normalized\_\-axis.inl.

References glm::cos(), glm::radians(), and glm::sin().

\begin{Code}\begin{verbatim}80         {
81                 detail::tvec3<T, P> Tmp = v;
82 
83 #ifdef GLM_FORCE_RADIANS
84                 T const AngleRad(angle);
85 #else
86 #               pragma message("GLM: rotateNormalizedAxis function taking degrees as parameters is deprecated. #define GLM_FORCE_RADIANS before including GLM headers to remove this message.")
87                 T const AngleRad = radians(angle);
88 #endif
89                 T const Sin = sin(AngleRad * T(0.5));
90 
91                 return q * detail::tquat<T, P>(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
92                 //return gtc::quaternion::cross(q, detail::tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * fSin, Tmp.y * fSin, Tmp.z * fSin));
93         }
\end{verbatim}
\end{Code}




Here is the call graph for this function:\hypertarget{group__gtx__rotate__normalized__axis_g9fc93bb16dd6719fc660a506cb833fb0}{
\index{gtx\_\-rotate\_\-normalized\_\-axis@{gtx\_\-rotate\_\-normalized\_\-axis}!rotateNormalizedAxis@{rotateNormalizedAxis}}
\index{rotateNormalizedAxis@{rotateNormalizedAxis}!gtx_rotate_normalized_axis@{gtx\_\-rotate\_\-normalized\_\-axis}}
\subsubsection[rotateNormalizedAxis]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T, precision P$>$ GLM\_\-FUNC\_\-QUALIFIER detail::tmat4x4$<$ T, P $>$ glm::rotateNormalizedAxis (detail::tmat4x4$<$ T, P $>$ const \& {\em m}, \/  T const \& {\em angle}, \/  detail::tvec3$<$ T, P $>$ const \& {\em axis})\hspace{0.3cm}{\tt  \mbox{[}inline\mbox{]}}}}
\label{group__gtx__rotate__normalized__axis_g9fc93bb16dd6719fc660a506cb833fb0}


Builds a rotation 4 $\ast$ 4 matrix created from a normalized axis and an angle.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em m}]Input matrix multiplied by this rotation matrix. \item[{\em angle}]Rotation angle expressed in radians if GLM\_\-FORCE\_\-RADIANS is define or degrees otherwise. \item[{\em axis}]Rotation axis, must be normalized. \end{description}
\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em T}]Value type used to build the matrix. Currently supported: half (not recommanded), float or double.\end{description}
\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{group__gtx__rotate__normalized__axis}{GLM\_\-GTX\_\-rotate\_\-normalized\_\-axis} 

- rotate(T angle, T x, T y, T z) 

- rotate(detail::tmat4x4$<$T, P$>$ const \& m, T angle, T x, T y, T z) 

- \hyperlink{group__gtx__transform_g52e753e0ad1cb6ae700855cc9ca921ca}{rotate(T angle, detail::tvec3$<$T, P$>$ const \& v)} \end{Desc}


Definition at line 33 of file rotate\_\-normalized\_\-axis.inl.

References glm::axis(), glm::cos(), glm::radians(), and glm::sin().

\begin{Code}\begin{verbatim}38         {
39 #ifdef GLM_FORCE_RADIANS
40                 T a = angle;
41 #else
42 #               pragma message("GLM: rotateNormalizedAxis function taking degrees as parameters is deprecated. #define GLM_FORCE_RADIANS before including GLM headers to remove this message.")
43                 T a = radians(angle);
44 #endif
45                 T c = cos(a);
46                 T s = sin(a);
47 
48                 detail::tvec3<T, P> axis = v;
49 
50                 detail::tvec3<T, P> temp = (T(1) - c) * axis;
51 
52                 detail::tmat4x4<T, P> Rotate(detail::tmat4x4<T, P>::_null);
53                 Rotate[0][0] = c + temp[0] * axis[0];
54                 Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
55                 Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];
56 
57                 Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
58                 Rotate[1][1] = c + temp[1] * axis[1];
59                 Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];
60 
61                 Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
62                 Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
63                 Rotate[2][2] = c + temp[2] * axis[2];
64 
65                 detail::tmat4x4<T, P> Result(detail::tmat4x4<T, P>::_null);
66                 Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
67                 Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
68                 Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
69                 Result[3] = m[3];
70                 return Result;
71         }
\end{verbatim}
\end{Code}




Here is the call graph for this function: