<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btMultiBodyDynamicsWorld Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btMultiBodyDynamicsWorld Class Reference</h1><!-- doxytag: class="btMultiBodyDynamicsWorld" --><code>#include &lt;<a class="el" href="bt_multi_body_dynamics_world_8h-source.html">btMultiBodyDynamicsWorld.h</a>&gt;</code>
<p>
Inherited by btSoftMultiBodyDynamicsWorld.
<p>
<div class="dynheader">
Collaboration diagram for btMultiBodyDynamicsWorld:</div>
<div class="dynsection">
<p><center><img src="classbt_multi_body_dynamics_world__coll__graph.png" border="0" usemap="#bt_multi_body_dynamics_world__coll__map" alt="Collaboration graph"></center>
<map name="bt_multi_body_dynamics_world__coll__map">
<area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btQuaternion \&gt;" alt="" coords="1560,55,1803,81"><area shape="rect" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination..." alt="" coords="1144,41,1240,68"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btQuaternion, 16 \&gt;" alt="" coords="796,9,1041,36"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, Alignment \&gt;" alt="" coords="5,284,229,311"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, 16 \&gt;" alt="" coords="527,245,705,272"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btVector3, 16 \&gt;" alt="" coords="805,120,1032,147"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btMatrix3x3, 16 \&gt;" alt="" coords="799,395,1039,421"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btMultiBody *, 16 \&gt;" alt="" coords="1067,311,1317,337"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btMultiBodyConstraint *, 16 \&gt;" alt="" coords="461,463,771,489"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; T \&gt;" alt="" coords="1104,220,1280,247"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btVector3 \&gt;" alt="" coords="1569,171,1793,197"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btMatrix3x3 \&gt;" alt="" coords="1564,272,1799,299"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btMultiBody * \&gt;" alt="" coords="1559,221,1804,248"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btMultiBodyConstraint * \&gt;" alt="" coords="1529,359,1833,385"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_multi_body_dynamics_world-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_multi_body_dynamics_world.html#6abe9896c6178b8d5bebdbca53fa7a74">integrateTransforms</a> (btScalar timeStep)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_multi_body_dynamics_world.html#96ca0256c11525090a831cc854fe0750">solveConstraints</a> (btContactSolverInfo &amp;solverInfo)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classbt_multi_body_dynamics_world.html">btMultiBodyDynamicsWorld</a> adds Featherstone multi body dynamics to Bullet This implementation is still preliminary/experimental. 
<p>Definition at line <a class="el" href="bt_multi_body_dynamics_world_8h-source.html#l00030">30</a> of file <a class="el" href="bt_multi_body_dynamics_world_8h-source.html">btMultiBodyDynamicsWorld.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="96ca0256c11525090a831cc854fe0750"></a><!-- doxytag: member="btMultiBodyDynamicsWorld::solveConstraints" ref="96ca0256c11525090a831cc854fe0750" args="(btContactSolverInfo &amp;solverInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btMultiBodyDynamicsWorld::solveConstraints           </td>
          <td>(</td>
          <td class="paramtype">btContactSolverInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>solverInfo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
solve all the constraints for this island 
<p>Definition at line <a class="el" href="bt_multi_body_dynamics_world_8cpp-source.html#l00406">406</a> of file <a class="el" href="bt_multi_body_dynamics_world_8cpp-source.html">btMultiBodyDynamicsWorld.cpp</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00363">btAlignedObjectArray&lt; T &gt;::quickSort()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00407"></a>00407 {
<a name="l00408"></a>00408         forwardKinematics();
<a name="l00409"></a>00409 
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 
<a name="l00412"></a>00412         BT_PROFILE(<span class="stringliteral">"solveConstraints"</span>);
<a name="l00413"></a>00413         
<a name="l00414"></a>00414         m_sortedConstraints.resize( m_constraints.size());
<a name="l00415"></a>00415         <span class="keywordtype">int</span> i; 
<a name="l00416"></a>00416         <span class="keywordflow">for</span> (i=0;i&lt;getNumConstraints();i++)
<a name="l00417"></a>00417         {
<a name="l00418"></a>00418                 m_sortedConstraints[i] = m_constraints[i];
<a name="l00419"></a>00419         }
<a name="l00420"></a>00420         m_sortedConstraints.quickSort(btSortConstraintOnIslandPredicate2());
<a name="l00421"></a>00421         btTypedConstraint** constraintsPtr = getNumConstraints() ? &amp;m_sortedConstraints[0] : 0;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         m_sortedMultiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_multiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l00424"></a>00424         <span class="keywordflow">for</span> (i=0;i&lt;m_multiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00425"></a>00425         {
<a name="l00426"></a>00426                 m_sortedMultiBodyConstraints[i] = m_multiBodyConstraints[i];
<a name="l00427"></a>00427         }
<a name="l00428"></a>00428         m_sortedMultiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#228f2a824ac397c1de311a9c2b775dc4">quickSort</a>(btSortMultiBodyConstraintOnIslandPredicate());
<a name="l00429"></a>00429 
<a name="l00430"></a>00430         btMultiBodyConstraint** sortedMultiBodyConstraints = m_sortedMultiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>() ?  &amp;m_sortedMultiBodyConstraints[0] : 0;
<a name="l00431"></a>00431         
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         m_solverMultiBodyIslandCallback-&gt;setup(&amp;solverInfo,constraintsPtr,m_sortedConstraints.size(),sortedMultiBodyConstraints,m_sortedMultiBodyConstraints.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>(), getDebugDrawer());
<a name="l00434"></a>00434         m_constraintSolver-&gt;prepareSolve(getCollisionWorld()-&gt;getNumCollisionObjects(), getCollisionWorld()-&gt;getDispatcher()-&gt;getNumManifolds());
<a name="l00435"></a>00435         
<a name="l00437"></a>00437         m_islandManager-&gt;buildAndProcessIslands(getCollisionWorld()-&gt;getDispatcher(),getCollisionWorld(),m_solverMultiBodyIslandCallback);
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="preprocessor">#ifndef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>        {
<a name="l00441"></a>00441                 BT_PROFILE(<span class="stringliteral">"btMultiBody addForce"</span>);
<a name="l00442"></a>00442                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;this-&gt;m_multiBodies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00443"></a>00443                 {
<a name="l00444"></a>00444                         btMultiBody* bod = m_multiBodies[i];
<a name="l00445"></a>00445 
<a name="l00446"></a>00446                         <span class="keywordtype">bool</span> isSleeping = <span class="keyword">false</span>;
<a name="l00447"></a>00447                         
<a name="l00448"></a>00448                         <span class="keywordflow">if</span> (bod-&gt;getBaseCollider() &amp;&amp; bod-&gt;getBaseCollider()-&gt;getActivationState() == ISLAND_SLEEPING)
<a name="l00449"></a>00449                         {
<a name="l00450"></a>00450                                 isSleeping = <span class="keyword">true</span>;
<a name="l00451"></a>00451                         } 
<a name="l00452"></a>00452                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0;b&lt;bod-&gt;getNumLinks();b++)
<a name="l00453"></a>00453                         {
<a name="l00454"></a>00454                                 <span class="keywordflow">if</span> (bod-&gt;getLink(b).m_collider &amp;&amp; bod-&gt;getLink(b).m_collider-&gt;getActivationState()==ISLAND_SLEEPING)
<a name="l00455"></a>00455                                         isSleeping = <span class="keyword">true</span>;
<a name="l00456"></a>00456                         } 
<a name="l00457"></a>00457 
<a name="l00458"></a>00458                         <span class="keywordflow">if</span> (!isSleeping)
<a name="l00459"></a>00459                         {
<a name="l00460"></a>00460                                 <span class="comment">//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)</span>
<a name="l00461"></a>00461                                 m_scratch_r.resize(bod-&gt;getNumLinks()+1);                       <span class="comment">//multidof? ("Y"s use it and it is used to store qdd)</span>
<a name="l00462"></a>00462                                 m_scratch_v.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00463"></a>00463                                 m_scratch_m.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00464"></a>00464 
<a name="l00465"></a>00465                                 bod-&gt;addBaseForce(m_gravity * bod-&gt;getBaseMass());
<a name="l00466"></a>00466 
<a name="l00467"></a>00467                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; bod-&gt;getNumLinks(); ++j) 
<a name="l00468"></a>00468                                 {
<a name="l00469"></a>00469                                         bod-&gt;addLinkForce(j, m_gravity * bod-&gt;getLinkMass(j));
<a name="l00470"></a>00470                                 }
<a name="l00471"></a>00471                         }<span class="comment">//if (!isSleeping)</span>
<a name="l00472"></a>00472                 }
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474 <span class="preprocessor">#endif //BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY</span>
<a name="l00475"></a>00475 <span class="preprocessor"></span>        
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         {
<a name="l00478"></a>00478                 BT_PROFILE(<span class="stringliteral">"btMultiBody stepVelocities"</span>);
<a name="l00479"></a>00479                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;this-&gt;m_multiBodies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00480"></a>00480                 {
<a name="l00481"></a>00481                         btMultiBody* bod = m_multiBodies[i];
<a name="l00482"></a>00482 
<a name="l00483"></a>00483                         <span class="keywordtype">bool</span> isSleeping = <span class="keyword">false</span>;
<a name="l00484"></a>00484                         
<a name="l00485"></a>00485                         <span class="keywordflow">if</span> (bod-&gt;getBaseCollider() &amp;&amp; bod-&gt;getBaseCollider()-&gt;getActivationState() == ISLAND_SLEEPING)
<a name="l00486"></a>00486                         {
<a name="l00487"></a>00487                                 isSleeping = <span class="keyword">true</span>;
<a name="l00488"></a>00488                         } 
<a name="l00489"></a>00489                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0;b&lt;bod-&gt;getNumLinks();b++)
<a name="l00490"></a>00490                         {
<a name="l00491"></a>00491                                 <span class="keywordflow">if</span> (bod-&gt;getLink(b).m_collider &amp;&amp; bod-&gt;getLink(b).m_collider-&gt;getActivationState()==ISLAND_SLEEPING)
<a name="l00492"></a>00492                                         isSleeping = <span class="keyword">true</span>;
<a name="l00493"></a>00493                         } 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495                         <span class="keywordflow">if</span> (!isSleeping)
<a name="l00496"></a>00496                         {
<a name="l00497"></a>00497                                 <span class="comment">//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)</span>
<a name="l00498"></a>00498                                 m_scratch_r.resize(bod-&gt;getNumLinks()+1);                       <span class="comment">//multidof? ("Y"s use it and it is used to store qdd)</span>
<a name="l00499"></a>00499                                 m_scratch_v.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00500"></a>00500                                 m_scratch_m.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00501"></a>00501                                 <span class="keywordtype">bool</span> doNotUpdatePos = <span class="keyword">false</span>;
<a name="l00502"></a>00502 
<a name="l00503"></a>00503                                 {
<a name="l00504"></a>00504                                         <span class="keywordflow">if</span>(!bod-&gt;isUsingRK4Integration())
<a name="l00505"></a>00505                                         {
<a name="l00506"></a>00506                                                 bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(solverInfo.m_timeStep, m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00507"></a>00507                                         }
<a name="l00508"></a>00508                                         <span class="keywordflow">else</span>
<a name="l00509"></a>00509                                         {                                               
<a name="l00510"></a>00510                                                 <span class="comment">//</span>
<a name="l00511"></a>00511                                                 <span class="keywordtype">int</span> numDofs = bod-&gt;getNumDofs() + 6;
<a name="l00512"></a>00512                                                 <span class="keywordtype">int</span> numPosVars = bod-&gt;getNumPosVars() + 7;
<a name="l00513"></a>00513                                                 <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;btScalar&gt;</a> scratch_r2; scratch_r2.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(2*numPosVars + 8*numDofs);
<a name="l00514"></a>00514                                                 <span class="comment">//convenience</span>
<a name="l00515"></a>00515                                                 btScalar *pMem = &amp;scratch_r2[0];
<a name="l00516"></a>00516                                                 btScalar *scratch_q0 = pMem; pMem += numPosVars;
<a name="l00517"></a>00517                                                 btScalar *scratch_qx = pMem; pMem += numPosVars;
<a name="l00518"></a>00518                                                 btScalar *scratch_qd0 = pMem; pMem += numDofs;
<a name="l00519"></a>00519                                                 btScalar *scratch_qd1 = pMem; pMem += numDofs;
<a name="l00520"></a>00520                                                 btScalar *scratch_qd2 = pMem; pMem += numDofs;
<a name="l00521"></a>00521                                                 btScalar *scratch_qd3 = pMem; pMem += numDofs;
<a name="l00522"></a>00522                                                 btScalar *scratch_qdd0 = pMem; pMem += numDofs;
<a name="l00523"></a>00523                                                 btScalar *scratch_qdd1 = pMem; pMem += numDofs;
<a name="l00524"></a>00524                                                 btScalar *scratch_qdd2 = pMem; pMem += numDofs;
<a name="l00525"></a>00525                                                 btScalar *scratch_qdd3 = pMem; pMem += numDofs;
<a name="l00526"></a>00526                                                 btAssert((pMem - (2*numPosVars + 8*numDofs)) == &amp;scratch_r2[0]);
<a name="l00527"></a>00527 
<a name="l00529"></a>00529                                                 <span class="comment">//copy q0 to scratch_q0 and qd0 to scratch_qd0</span>
<a name="l00530"></a>00530                                                 scratch_q0[0] = bod-&gt;getWorldToBaseRot().x();
<a name="l00531"></a>00531                                                 scratch_q0[1] = bod-&gt;getWorldToBaseRot().y();
<a name="l00532"></a>00532                                                 scratch_q0[2] = bod-&gt;getWorldToBaseRot().z();
<a name="l00533"></a>00533                                                 scratch_q0[3] = bod-&gt;getWorldToBaseRot().w();
<a name="l00534"></a>00534                                                 scratch_q0[4] = bod-&gt;getBasePos().x();
<a name="l00535"></a>00535                                                 scratch_q0[5] = bod-&gt;getBasePos().y();
<a name="l00536"></a>00536                                                 scratch_q0[6] = bod-&gt;getBasePos().z();
<a name="l00537"></a>00537                                                 <span class="comment">//</span>
<a name="l00538"></a>00538                                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> link = 0; link &lt; bod-&gt;getNumLinks(); ++link)
<a name="l00539"></a>00539                                                 {
<a name="l00540"></a>00540                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dof = 0; dof &lt; bod-&gt;getLink(link).m_posVarCount; ++dof)
<a name="l00541"></a>00541                                                                 scratch_q0[7 + bod-&gt;getLink(link).m_cfgOffset + dof] = bod-&gt;getLink(link).m_jointPos[dof];                                                      
<a name="l00542"></a>00542                                                 }
<a name="l00543"></a>00543                                                 <span class="comment">//</span>
<a name="l00544"></a>00544                                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dof = 0; dof &lt; numDofs; ++dof)                                                          
<a name="l00545"></a>00545                                                         scratch_qd0[dof] = bod-&gt;getVelocityVector()[dof];
<a name="l00547"></a>00547                                                 <span class="keyword">struct</span>
<a name="l00548"></a>00548                                                 {
<a name="l00549"></a>00549                                                     btMultiBody *bod;
<a name="l00550"></a>00550                             btScalar *scratch_qx, *scratch_q0;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552                                                     <span class="keywordtype">void</span> operator()()
<a name="l00553"></a>00553                                                     {
<a name="l00554"></a>00554                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dof = 0; dof &lt; bod-&gt;getNumPosVars() + 7; ++dof)
<a name="l00555"></a>00555                                     scratch_qx[dof] = scratch_q0[dof];
<a name="l00556"></a>00556                                                     }
<a name="l00557"></a>00557                                                 } pResetQx = {bod, scratch_qx, scratch_q0};
<a name="l00558"></a>00558                                                 <span class="comment">//</span>
<a name="l00559"></a>00559                                                 <span class="keyword">struct</span>
<a name="l00560"></a>00560                                                 {
<a name="l00561"></a>00561                                                     <span class="keywordtype">void</span> operator()(btScalar dt, <span class="keyword">const</span> btScalar *pDer, <span class="keyword">const</span> btScalar *pCurVal, btScalar *pVal, <span class="keywordtype">int</span> size)
<a name="l00562"></a>00562                                                     {
<a name="l00563"></a>00563                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; ++i)
<a name="l00564"></a>00564                                     pVal[i] = pCurVal[i] + dt * pDer[i];
<a name="l00565"></a>00565                                                     }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567                                                 } pEulerIntegrate;
<a name="l00568"></a>00568                                                 <span class="comment">//</span>
<a name="l00569"></a>00569                                                 <span class="keyword">struct</span>
<a name="l00570"></a>00570                         {
<a name="l00571"></a>00571                             <span class="keywordtype">void</span> operator()(btMultiBody *pBody, <span class="keyword">const</span> btScalar *pData)
<a name="l00572"></a>00572                             {
<a name="l00573"></a>00573                                 btScalar *pVel = <span class="keyword">const_cast&lt;</span>btScalar*<span class="keyword">&gt;</span>(pBody-&gt;getVelocityVector());
<a name="l00574"></a>00574 
<a name="l00575"></a>00575                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pBody-&gt;getNumDofs() + 6; ++i)
<a name="l00576"></a>00576                                     pVel[i] = pData[i];
<a name="l00577"></a>00577 
<a name="l00578"></a>00578                             }
<a name="l00579"></a>00579                         } pCopyToVelocityVector;
<a name="l00580"></a>00580                                                 <span class="comment">//</span>
<a name="l00581"></a>00581                         <span class="keyword">struct</span>
<a name="l00582"></a>00582                                                 {
<a name="l00583"></a>00583                                                     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> btScalar *pSrc, btScalar *pDst, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> size)
<a name="l00584"></a>00584                                                     {
<a name="l00585"></a>00585                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; ++i)
<a name="l00586"></a>00586                                     pDst[i] = pSrc[start + i];
<a name="l00587"></a>00587                                                     }
<a name="l00588"></a>00588                                                 } pCopy;
<a name="l00589"></a>00589                                                 <span class="comment">//</span>
<a name="l00590"></a>00590 
<a name="l00591"></a>00591                                                 btScalar h = solverInfo.m_timeStep;
<a name="l00592"></a>00592 <span class="preprocessor">                                                #define output &amp;m_scratch_r[bod-&gt;getNumDofs()]</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>                                                <span class="comment">//calc qdd0 from: q0 &amp; qd0      </span>
<a name="l00594"></a>00594                                                 bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00595"></a>00595                                                 pCopy(output, scratch_qdd0, 0, numDofs);
<a name="l00596"></a>00596                                                 <span class="comment">//calc q1 = q0 + h/2 * qd0</span>
<a name="l00597"></a>00597                                                 pResetQx();
<a name="l00598"></a>00598                                                 bod-&gt;stepPositionsMultiDof(btScalar(.5)*h, scratch_qx, scratch_qd0);
<a name="l00599"></a>00599                                                 <span class="comment">//calc qd1 = qd0 + h/2 * qdd0</span>
<a name="l00600"></a>00600                                                 pEulerIntegrate(btScalar(.5)*h, scratch_qdd0, scratch_qd0, scratch_qd1, numDofs);
<a name="l00601"></a>00601                                                 <span class="comment">//</span>
<a name="l00602"></a>00602                                                 <span class="comment">//calc qdd1 from: q1 &amp; qd1</span>
<a name="l00603"></a>00603                                                 pCopyToVelocityVector(bod, scratch_qd1);
<a name="l00604"></a>00604                                                 bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00605"></a>00605                                                 pCopy(output, scratch_qdd1, 0, numDofs);
<a name="l00606"></a>00606                                                 <span class="comment">//calc q2 = q0 + h/2 * qd1</span>
<a name="l00607"></a>00607                                                 pResetQx();
<a name="l00608"></a>00608                                                 bod-&gt;stepPositionsMultiDof(btScalar(.5)*h, scratch_qx, scratch_qd1);
<a name="l00609"></a>00609                                                 <span class="comment">//calc qd2 = qd0 + h/2 * qdd1</span>
<a name="l00610"></a>00610                                                 pEulerIntegrate(btScalar(.5)*h, scratch_qdd1, scratch_qd0, scratch_qd2, numDofs);
<a name="l00611"></a>00611                                                 <span class="comment">//</span>
<a name="l00612"></a>00612                                                 <span class="comment">//calc qdd2 from: q2 &amp; qd2</span>
<a name="l00613"></a>00613                                                 pCopyToVelocityVector(bod, scratch_qd2);
<a name="l00614"></a>00614                                                 bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00615"></a>00615                                                 pCopy(output, scratch_qdd2, 0, numDofs);
<a name="l00616"></a>00616                                                 <span class="comment">//calc q3 = q0 + h * qd2</span>
<a name="l00617"></a>00617                                                 pResetQx();
<a name="l00618"></a>00618                                                 bod-&gt;stepPositionsMultiDof(h, scratch_qx, scratch_qd2);
<a name="l00619"></a>00619                                                 <span class="comment">//calc qd3 = qd0 + h * qdd2</span>
<a name="l00620"></a>00620                                                 pEulerIntegrate(h, scratch_qdd2, scratch_qd0, scratch_qd3, numDofs);
<a name="l00621"></a>00621                                                 <span class="comment">//</span>
<a name="l00622"></a>00622                                                 <span class="comment">//calc qdd3 from: q3 &amp; qd3</span>
<a name="l00623"></a>00623                                                 pCopyToVelocityVector(bod, scratch_qd3);
<a name="l00624"></a>00624                                                 bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(0., m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00625"></a>00625                                                 pCopy(output, scratch_qdd3, 0, numDofs);
<a name="l00626"></a>00626 
<a name="l00627"></a>00627                                                 <span class="comment">//</span>
<a name="l00628"></a>00628                                                 <span class="comment">//calc q = q0 + h/6(qd0 + 2*(qd1 + qd2) + qd3)</span>
<a name="l00629"></a>00629                                                 <span class="comment">//calc qd = qd0 + h/6(qdd0 + 2*(qdd1 + qdd2) + qdd3)                                            </span>
<a name="l00630"></a>00630                                                 <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;btScalar&gt;</a> delta_q; delta_q.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(numDofs);
<a name="l00631"></a>00631                                                 <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;btScalar&gt;</a> delta_qd; delta_qd.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(numDofs);
<a name="l00632"></a>00632                                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numDofs; ++i)
<a name="l00633"></a>00633                                                 {
<a name="l00634"></a>00634                                                         delta_q[i] = h/btScalar(6.)*(scratch_qd0[i] + 2*scratch_qd1[i] + 2*scratch_qd2[i] + scratch_qd3[i]);
<a name="l00635"></a>00635                                                         delta_qd[i] = h/btScalar(6.)*(scratch_qdd0[i] + 2*scratch_qdd1[i] + 2*scratch_qdd2[i] + scratch_qdd3[i]);                                                       
<a name="l00636"></a>00636                                                         <span class="comment">//delta_q[i] = h*scratch_qd0[i];</span>
<a name="l00637"></a>00637                                                         <span class="comment">//delta_qd[i] = h*scratch_qdd0[i];</span>
<a name="l00638"></a>00638                                                 }
<a name="l00639"></a>00639                                                 <span class="comment">//</span>
<a name="l00640"></a>00640                                                 pCopyToVelocityVector(bod, scratch_qd0);
<a name="l00641"></a>00641                                                 bod-&gt;applyDeltaVeeMultiDof(&amp;delta_qd[0], 1);                                            
<a name="l00642"></a>00642                                                 <span class="comment">//</span>
<a name="l00643"></a>00643                                                 <span class="keywordflow">if</span>(!doNotUpdatePos)
<a name="l00644"></a>00644                                                 {
<a name="l00645"></a>00645                                                         btScalar *pRealBuf = <span class="keyword">const_cast&lt;</span>btScalar *<span class="keyword">&gt;</span>(bod-&gt;getVelocityVector());
<a name="l00646"></a>00646                                                         pRealBuf += 6 + bod-&gt;getNumDofs() + bod-&gt;getNumDofs()*bod-&gt;getNumDofs();
<a name="l00647"></a>00647 
<a name="l00648"></a>00648                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numDofs; ++i)
<a name="l00649"></a>00649                                                                 pRealBuf[i] = delta_q[i];
<a name="l00650"></a>00650 
<a name="l00651"></a>00651                                                         <span class="comment">//bod-&gt;stepPositionsMultiDof(1, 0, &amp;delta_q[0]);</span>
<a name="l00652"></a>00652                                                         bod-&gt;setPosUpdated(<span class="keyword">true</span>);                                                       
<a name="l00653"></a>00653                                                 }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655                                                 <span class="comment">//ugly hack which resets the cached data to t0 (needed for constraint solver)</span>
<a name="l00656"></a>00656                                                 {
<a name="l00657"></a>00657                                                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> link = 0; link &lt; bod-&gt;getNumLinks(); ++link)
<a name="l00658"></a>00658                                                                 bod-&gt;getLink(link).updateCacheMultiDof();
<a name="l00659"></a>00659                                                         bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(0, m_scratch_r, m_scratch_v, m_scratch_m);
<a name="l00660"></a>00660                                                 }
<a name="l00661"></a>00661                                                 
<a name="l00662"></a>00662                                         }
<a name="l00663"></a>00663                                 }
<a name="l00664"></a>00664                                 
<a name="l00665"></a>00665 <span class="preprocessor">#ifndef BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY</span>
<a name="l00666"></a>00666 <span class="preprocessor"></span>                                bod-&gt;clearForcesAndTorques();
<a name="l00667"></a>00667 <span class="preprocessor">#endif //BT_USE_VIRTUAL_CLEARFORCES_AND_GRAVITY</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>                        }<span class="comment">//if (!isSleeping)</span>
<a name="l00669"></a>00669                 }
<a name="l00670"></a>00670         }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672         clearMultiBodyConstraintForces();
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         m_solverMultiBodyIslandCallback-&gt;processConstraints();
<a name="l00675"></a>00675         
<a name="l00676"></a>00676         m_constraintSolver-&gt;allSolved(solverInfo, m_debugDrawer);
<a name="l00677"></a>00677 
<a name="l00678"></a>00678         {
<a name="l00679"></a>00679                 BT_PROFILE(<span class="stringliteral">"btMultiBody stepVelocities"</span>);
<a name="l00680"></a>00680                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;this-&gt;m_multiBodies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00681"></a>00681                 {
<a name="l00682"></a>00682                         btMultiBody* bod = m_multiBodies[i];
<a name="l00683"></a>00683 
<a name="l00684"></a>00684                         <span class="keywordtype">bool</span> isSleeping = <span class="keyword">false</span>;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686                         <span class="keywordflow">if</span> (bod-&gt;getBaseCollider() &amp;&amp; bod-&gt;getBaseCollider()-&gt;getActivationState() == ISLAND_SLEEPING)
<a name="l00687"></a>00687                         {
<a name="l00688"></a>00688                                 isSleeping = <span class="keyword">true</span>;
<a name="l00689"></a>00689                         }
<a name="l00690"></a>00690                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0;b&lt;bod-&gt;getNumLinks();b++)
<a name="l00691"></a>00691                         {
<a name="l00692"></a>00692                                 <span class="keywordflow">if</span> (bod-&gt;getLink(b).m_collider &amp;&amp; bod-&gt;getLink(b).m_collider-&gt;getActivationState()==ISLAND_SLEEPING)
<a name="l00693"></a>00693                                         isSleeping = <span class="keyword">true</span>;
<a name="l00694"></a>00694                         }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696                         <span class="keywordflow">if</span> (!isSleeping)
<a name="l00697"></a>00697                         {
<a name="l00698"></a>00698                                 <span class="comment">//useless? they get resized in stepVelocities once again (AND DIFFERENTLY)</span>
<a name="l00699"></a>00699                                 m_scratch_r.resize(bod-&gt;getNumLinks()+1);                 <span class="comment">//multidof? ("Y"s use it and it is used to store qdd)</span>
<a name="l00700"></a>00700                                 m_scratch_v.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00701"></a>00701                                 m_scratch_m.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(bod-&gt;getNumLinks()+1);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                                 
<a name="l00704"></a>00704                             {
<a name="l00705"></a>00705                                 <span class="keywordflow">if</span>(!bod-&gt;isUsingRK4Integration())
<a name="l00706"></a>00706                                 {
<a name="l00707"></a>00707                                                                         <span class="keywordtype">bool</span> isConstraintPass = <span class="keyword">true</span>;
<a name="l00708"></a>00708                                     bod-&gt;computeAccelerationsArticulatedBodyAlgorithmMultiDof(solverInfo.m_timeStep, m_scratch_r, m_scratch_v, m_scratch_m, isConstraintPass);
<a name="l00709"></a>00709                                 }
<a name="l00710"></a>00710                                 }
<a name="l00711"></a>00711                         }
<a name="l00712"></a>00712                 }
<a name="l00713"></a>00713         }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;this-&gt;m_multiBodies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00716"></a>00716         {
<a name="l00717"></a>00717                 btMultiBody* bod = m_multiBodies[i];
<a name="l00718"></a>00718                 bod-&gt;processDeltaVeeMultiDof2();
<a name="l00719"></a>00719         }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_multi_body_dynamics_world_96ca0256c11525090a831cc854fe0750_cgraph.png" border="0" usemap="#classbt_multi_body_dynamics_world_96ca0256c11525090a831cc854fe0750_cgraph_map" alt=""></center>
<map name="classbt_multi_body_dynamics_world_96ca0256c11525090a831cc854fe0750_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#228f2a824ac397c1de311a9c2b775dc4" title="btAlignedObjectArray::quickSort" alt="" coords="339,5,547,32"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="349,56,536,83"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="355,107,531,133"></map>
</div>

</div>
</div><p>
<a class="anchor" name="6abe9896c6178b8d5bebdbca53fa7a74"></a><!-- doxytag: member="btMultiBodyDynamicsWorld::integrateTransforms" ref="6abe9896c6178b8d5bebdbca53fa7a74" args="(btScalar timeStep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btMultiBodyDynamicsWorld::integrateTransforms           </td>
          <td>(</td>
          <td class="paramtype">btScalar&nbsp;</td>
          <td class="paramname"> <em>timeStep</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
base + num m_links 
<p>Definition at line <a class="el" href="bt_multi_body_dynamics_world_8cpp-source.html#l00723">723</a> of file <a class="el" href="bt_multi_body_dynamics_world_8cpp-source.html">btMultiBodyDynamicsWorld.cpp</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00724"></a>00724 {
<a name="l00725"></a>00725         btDiscreteDynamicsWorld::integrateTransforms(timeStep);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727         {
<a name="l00728"></a>00728                 BT_PROFILE(<span class="stringliteral">"btMultiBody stepPositions"</span>);
<a name="l00729"></a>00729                 <span class="comment">//integrate and update the Featherstone hierarchies</span>
<a name="l00730"></a>00730         
<a name="l00731"></a>00731                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0;b&lt;m_multiBodies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();b++)
<a name="l00732"></a>00732                 {
<a name="l00733"></a>00733                         btMultiBody* bod = m_multiBodies[b];
<a name="l00734"></a>00734                         <span class="keywordtype">bool</span> isSleeping = <span class="keyword">false</span>;
<a name="l00735"></a>00735                         <span class="keywordflow">if</span> (bod-&gt;getBaseCollider() &amp;&amp; bod-&gt;getBaseCollider()-&gt;getActivationState() == ISLAND_SLEEPING)
<a name="l00736"></a>00736                         {
<a name="l00737"></a>00737                                 isSleeping = <span class="keyword">true</span>;
<a name="l00738"></a>00738                         } 
<a name="l00739"></a>00739                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b=0;b&lt;bod-&gt;getNumLinks();b++)
<a name="l00740"></a>00740                         {
<a name="l00741"></a>00741                                 <span class="keywordflow">if</span> (bod-&gt;getLink(b).m_collider &amp;&amp; bod-&gt;getLink(b).m_collider-&gt;getActivationState()==ISLAND_SLEEPING)
<a name="l00742"></a>00742                                         isSleeping = <span class="keyword">true</span>;
<a name="l00743"></a>00743                         }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 
<a name="l00746"></a>00746                         <span class="keywordflow">if</span> (!isSleeping)
<a name="l00747"></a>00747                         {
<a name="l00748"></a>00748                                 <span class="keywordtype">int</span> nLinks = bod-&gt;getNumLinks();
<a name="l00749"></a>00749 
<a name="l00751"></a>00751                         
<a name="l00752"></a>00752                                 
<a name="l00753"></a>00753                                 {
<a name="l00754"></a>00754                                         <span class="keywordflow">if</span>(!bod-&gt;isPosUpdated())
<a name="l00755"></a>00755                                                 bod-&gt;stepPositionsMultiDof(timeStep);
<a name="l00756"></a>00756                                         <span class="keywordflow">else</span>
<a name="l00757"></a>00757                                         {
<a name="l00758"></a>00758                                                 btScalar *pRealBuf = <span class="keyword">const_cast&lt;</span>btScalar *<span class="keyword">&gt;</span>(bod-&gt;getVelocityVector());
<a name="l00759"></a>00759                                                 pRealBuf += 6 + bod-&gt;getNumDofs() + bod-&gt;getNumDofs()*bod-&gt;getNumDofs();
<a name="l00760"></a>00760 
<a name="l00761"></a>00761                                                 bod-&gt;stepPositionsMultiDof(1, 0, pRealBuf);
<a name="l00762"></a>00762                                                 bod-&gt;setPosUpdated(<span class="keyword">false</span>);
<a name="l00763"></a>00763                                         }
<a name="l00764"></a>00764                                 }
<a name="l00765"></a>00765                                 
<a name="l00766"></a>00766                                 m_scratch_world_to_local.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(nLinks+1);
<a name="l00767"></a>00767                                 m_scratch_local_origin.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(nLinks+1);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769                                 bod-&gt;updateCollisionObjectWorldTransforms(m_scratch_world_to_local,m_scratch_local_origin);
<a name="l00770"></a>00770                                 
<a name="l00771"></a>00771                         } <span class="keywordflow">else</span>
<a name="l00772"></a>00772                         {
<a name="l00773"></a>00773                                 bod-&gt;clearVelocities();
<a name="l00774"></a>00774                         }
<a name="l00775"></a>00775                 }
<a name="l00776"></a>00776         }
<a name="l00777"></a>00777 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_multi_body_dynamics_world_6abe9896c6178b8d5bebdbca53fa7a74_cgraph.png" border="0" usemap="#classbt_multi_body_dynamics_world_6abe9896c6178b8d5bebdbca53fa7a74_cgraph_map" alt=""></center>
<map name="classbt_multi_body_dynamics_world_6abe9896c6178b8d5bebdbca53fa7a74_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="359,5,545,32"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="364,56,540,83"></map>
</div>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/Featherstone/<a class="el" href="bt_multi_body_dynamics_world_8h-source.html">btMultiBodyDynamicsWorld.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/Featherstone/<a class="el" href="bt_multi_body_dynamics_world_8cpp-source.html">btMultiBodyDynamicsWorld.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:01:31 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
