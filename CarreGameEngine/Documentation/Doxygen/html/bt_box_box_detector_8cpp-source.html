<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/btBoxBoxDetector.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Box-Box collision detection re-distributed under the ZLib license with permission from Russell L. Smith</span>
<a name="l00003"></a>00003 <span class="comment"> * Original version is from Open Dynamics Engine, Copyright (C) 2001,2002 Russell L. Smith.</span>
<a name="l00004"></a>00004 <span class="comment"> * All rights reserved.  Email: russ@q12.org   Web: www.q12.org</span>
<a name="l00005"></a>00005 <span class="comment"> Bullet Continuous Collision Detection and Physics Library</span>
<a name="l00006"></a>00006 <span class="comment"> Bullet is Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">This software is provided 'as-is', without any express or implied warranty.</span>
<a name="l00009"></a>00009 <span class="comment">In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00010"></a>00010 <span class="comment">Permission is granted to anyone to use this software for any purpose, </span>
<a name="l00011"></a>00011 <span class="comment">including commercial applications, and to alter it and redistribute it freely, </span>
<a name="l00012"></a>00012 <span class="comment">subject to the following restrictions:</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00015"></a>00015 <span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00016"></a>00016 <span class="comment">3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00017"></a>00017 <span class="comment">*/</span>
<a name="l00018"></a>00018 
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include "btBoxBoxDetector.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "BulletCollision/CollisionShapes/btBoxShape.h"</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;float.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a><a class="code" href="structbt_box_box_detector.html#9ab1be9748aeb7cfceb274768910c895">00027</a> <a class="code" href="structbt_box_box_detector.html#9ab1be9748aeb7cfceb274768910c895" title="ODE box-box collision detection is adapted to work with Bullet.">btBoxBoxDetector::btBoxBoxDetector</a>(<span class="keyword">const</span> btBoxShape* box1,<span class="keyword">const</span> btBoxShape* box2)
<a name="l00028"></a>00028 : m_box1(box1),
<a name="l00029"></a>00029 m_box2(box2)
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 }
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">// given two boxes (p1,R1,side1) and (p2,R2,side2), collide them together and</span>
<a name="l00036"></a>00036 <span class="comment">// generate contact points. this returns 0 if there is no contact otherwise</span>
<a name="l00037"></a>00037 <span class="comment">// it returns the number of contacts generated.</span>
<a name="l00038"></a>00038 <span class="comment">// `normal' returns the contact normal.</span>
<a name="l00039"></a>00039 <span class="comment">// `depth' returns the maximum penetration depth along that normal.</span>
<a name="l00040"></a>00040 <span class="comment">// `return_code' returns a number indicating the type of contact that was</span>
<a name="l00041"></a>00041 <span class="comment">// detected:</span>
<a name="l00042"></a>00042 <span class="comment">//        1,2,3 = box 2 intersects with a face of box 1</span>
<a name="l00043"></a>00043 <span class="comment">//        4,5,6 = box 1 intersects with a face of box 2</span>
<a name="l00044"></a>00044 <span class="comment">//        7..15 = edge-edge contact</span>
<a name="l00045"></a>00045 <span class="comment">// `maxc' is the maximum number of contacts allowed to be generated, i.e.</span>
<a name="l00046"></a>00046 <span class="comment">// the size of the `contact' array.</span>
<a name="l00047"></a>00047 <span class="comment">// `contact' and `skip' are the contact array information provided to the</span>
<a name="l00048"></a>00048 <span class="comment">// collision functions. this function only fills in the position and depth</span>
<a name="l00049"></a>00049 <span class="comment">// fields.</span>
<a name="l00050"></a>00050 <span class="keyword">struct </span>dContactGeom;
<a name="l00051"></a>00051 <span class="preprocessor">#define dDOTpq(a,b,p,q) ((a)[0]*(b)[0] + (a)[p]*(b)[q] + (a)[2*(p)]*(b)[2*(q)])</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define dInfinity FLT_MAX</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">/*PURE_INLINE btScalar dDOT   (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,1,1); }</span>
<a name="l00056"></a>00056 <span class="comment">PURE_INLINE btScalar dDOT13 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,1,3); }</span>
<a name="l00057"></a>00057 <span class="comment">PURE_INLINE btScalar dDOT31 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,3,1); }</span>
<a name="l00058"></a>00058 <span class="comment">PURE_INLINE btScalar dDOT33 (const btScalar *a, const btScalar *b) { return dDOTpq(a,b,3,3); }</span>
<a name="l00059"></a>00059 <span class="comment">*/</span>
<a name="l00060"></a>00060 <span class="keyword">static</span> btScalar dDOT   (<span class="keyword">const</span> btScalar *a, <span class="keyword">const</span> btScalar *b) { <span class="keywordflow">return</span> dDOTpq(a,b,1,1); }
<a name="l00061"></a>00061 <span class="keyword">static</span> btScalar dDOT44 (<span class="keyword">const</span> btScalar *a, <span class="keyword">const</span> btScalar *b) { <span class="keywordflow">return</span> dDOTpq(a,b,4,4); }
<a name="l00062"></a>00062 <span class="keyword">static</span> btScalar dDOT41 (<span class="keyword">const</span> btScalar *a, <span class="keyword">const</span> btScalar *b) { <span class="keywordflow">return</span> dDOTpq(a,b,4,1); }
<a name="l00063"></a>00063 <span class="keyword">static</span> btScalar dDOT14 (<span class="keyword">const</span> btScalar *a, <span class="keyword">const</span> btScalar *b) { <span class="keywordflow">return</span> dDOTpq(a,b,1,4); }
<a name="l00064"></a>00064 <span class="preprocessor">#define dMULTIPLYOP1_331(A,op,B,C) \</span>
<a name="l00065"></a>00065 <span class="preprocessor">{\</span>
<a name="l00066"></a>00066 <span class="preprocessor">  (A)[0] op dDOT41((B),(C)); \</span>
<a name="l00067"></a>00067 <span class="preprocessor">  (A)[1] op dDOT41((B+1),(C)); \</span>
<a name="l00068"></a>00068 <span class="preprocessor">  (A)[2] op dDOT41((B+2),(C)); \</span>
<a name="l00069"></a>00069 <span class="preprocessor">}</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#define dMULTIPLYOP0_331(A,op,B,C) \</span>
<a name="l00072"></a>00072 <span class="preprocessor">{ \</span>
<a name="l00073"></a>00073 <span class="preprocessor">  (A)[0] op dDOT((B),(C)); \</span>
<a name="l00074"></a>00074 <span class="preprocessor">  (A)[1] op dDOT((B+4),(C)); \</span>
<a name="l00075"></a>00075 <span class="preprocessor">  (A)[2] op dDOT((B+8),(C)); \</span>
<a name="l00076"></a>00076 <span class="preprocessor">} </span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#define dMULTIPLY1_331(A,B,C) dMULTIPLYOP1_331(A,=,B,C)</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define dMULTIPLY0_331(A,B,C) dMULTIPLYOP0_331(A,=,B,C)</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span>
<a name="l00081"></a>00081 <span class="keyword">typedef</span> btScalar dMatrix3[4*3];
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keywordtype">void</span> dLineClosestApproach (<span class="keyword">const</span> btVector3&amp; pa, <span class="keyword">const</span> btVector3&amp; ua,
<a name="l00084"></a>00084                            <span class="keyword">const</span> btVector3&amp; pb, <span class="keyword">const</span> btVector3&amp; ub,
<a name="l00085"></a>00085                            btScalar *alpha, btScalar *beta);
<a name="l00086"></a>00086 <span class="keywordtype">void</span> dLineClosestApproach (<span class="keyword">const</span> btVector3&amp; pa, <span class="keyword">const</span> btVector3&amp; ua,
<a name="l00087"></a>00087                            <span class="keyword">const</span> btVector3&amp; pb, <span class="keyword">const</span> btVector3&amp; ub,
<a name="l00088"></a>00088                            btScalar *alpha, btScalar *beta)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   btVector3 p;
<a name="l00091"></a>00091   p[0] = pb[0] - pa[0];
<a name="l00092"></a>00092   p[1] = pb[1] - pa[1];
<a name="l00093"></a>00093   p[2] = pb[2] - pa[2];
<a name="l00094"></a>00094   btScalar uaub = dDOT(ua,ub);
<a name="l00095"></a>00095   btScalar q1 =  dDOT(ua,p);
<a name="l00096"></a>00096   btScalar q2 = -dDOT(ub,p);
<a name="l00097"></a>00097   btScalar d = 1-uaub*uaub;
<a name="l00098"></a>00098   <span class="keywordflow">if</span> (d &lt;= btScalar(0.0001f)) {
<a name="l00099"></a>00099     <span class="comment">// @@@ this needs to be made more robust</span>
<a name="l00100"></a>00100     *alpha = 0;
<a name="l00101"></a>00101     *beta  = 0;
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103   <span class="keywordflow">else</span> {
<a name="l00104"></a>00104     d = 1.f/d;
<a name="l00105"></a>00105     *alpha = (q1 + uaub*q2)*d;
<a name="l00106"></a>00106     *beta  = (uaub*q1 + q2)*d;
<a name="l00107"></a>00107   }
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">// find all the intersection points between the 2D rectangle with vertices</span>
<a name="l00113"></a>00113 <span class="comment">// at (+/-h[0],+/-h[1]) and the 2D quadrilateral with vertices (p[0],p[1]),</span>
<a name="l00114"></a>00114 <span class="comment">// (p[2],p[3]),(p[4],p[5]),(p[6],p[7]).</span>
<a name="l00115"></a>00115 <span class="comment">//</span>
<a name="l00116"></a>00116 <span class="comment">// the intersection points are returned as x,y pairs in the 'ret' array.</span>
<a name="l00117"></a>00117 <span class="comment">// the number of intersection points is returned by the function (this will</span>
<a name="l00118"></a>00118 <span class="comment">// be in the range 0 to 8).</span>
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="keyword">static</span> <span class="keywordtype">int</span> intersectRectQuad2 (btScalar h[2], btScalar p[8], btScalar ret[16])
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122   <span class="comment">// q (and r) contain nq (and nr) coordinate points for the current (and</span>
<a name="l00123"></a>00123   <span class="comment">// chopped) polygons</span>
<a name="l00124"></a>00124   <span class="keywordtype">int</span> nq=4,nr=0;
<a name="l00125"></a>00125   btScalar buffer[16];
<a name="l00126"></a>00126   btScalar *q = p;
<a name="l00127"></a>00127   btScalar *r = ret;
<a name="l00128"></a>00128   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dir=0; dir &lt;= 1; dir++) {
<a name="l00129"></a>00129     <span class="comment">// direction notation: xy[0] = x axis, xy[1] = y axis</span>
<a name="l00130"></a>00130     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>=-1; <a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a> &lt;= 1; <a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a> += 2) {
<a name="l00131"></a>00131       <span class="comment">// chop q along the line xy[dir] = sign*h[dir]</span>
<a name="l00132"></a>00132       btScalar *pq = q;
<a name="l00133"></a>00133       btScalar *pr = r;
<a name="l00134"></a>00134       nr = 0;
<a name="l00135"></a>00135       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=nq; i &gt; 0; i--) {
<a name="l00136"></a>00136         <span class="comment">// go through all points in q and all lines between adjacent points</span>
<a name="l00137"></a>00137         <span class="keywordflow">if</span> (<a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>*pq[dir] &lt; h[dir]) {
<a name="l00138"></a>00138           <span class="comment">// this point is inside the chopping line</span>
<a name="l00139"></a>00139           pr[0] = pq[0];
<a name="l00140"></a>00140           pr[1] = pq[1];
<a name="l00141"></a>00141           pr += 2;
<a name="l00142"></a>00142           nr++;
<a name="l00143"></a>00143           <span class="keywordflow">if</span> (nr &amp; 8) {
<a name="l00144"></a>00144             q = r;
<a name="l00145"></a>00145             <span class="keywordflow">goto</span> done;
<a name="l00146"></a>00146           }
<a name="l00147"></a>00147         }
<a name="l00148"></a>00148         btScalar *nextq = (i &gt; 1) ? pq+2 : q;
<a name="l00149"></a>00149         <span class="keywordflow">if</span> ((<a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>*pq[dir] &lt; h[dir]) ^ (<a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>*nextq[dir] &lt; h[dir])) {
<a name="l00150"></a>00150           <span class="comment">// this line crosses the chopping line</span>
<a name="l00151"></a>00151           pr[1-dir] = pq[1-dir] + (nextq[1-dir]-pq[1-dir]) /
<a name="l00152"></a>00152             (nextq[dir]-pq[dir]) * (<a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>*h[dir]-pq[dir]);
<a name="l00153"></a>00153           pr[dir] = <a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>*h[dir];
<a name="l00154"></a>00154           pr += 2;
<a name="l00155"></a>00155           nr++;
<a name="l00156"></a>00156           <span class="keywordflow">if</span> (nr &amp; 8) {
<a name="l00157"></a>00157             q = r;
<a name="l00158"></a>00158             <span class="keywordflow">goto</span> done;
<a name="l00159"></a>00159           }
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161         pq += 2;
<a name="l00162"></a>00162       }
<a name="l00163"></a>00163       q = r;
<a name="l00164"></a>00164       r = (q==ret) ? buffer : ret;
<a name="l00165"></a>00165       nq = nr;
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168  done:
<a name="l00169"></a>00169   <span class="keywordflow">if</span> (q != ret) memcpy (ret,q,nr*2*<span class="keyword">sizeof</span>(btScalar));
<a name="l00170"></a>00170   <span class="keywordflow">return</span> nr;
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="preprocessor">#define M__PI 3.14159265f</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>
<a name="l00176"></a>00176 <span class="comment">// given n points in the plane (array p, of size 2*n), generate m points that</span>
<a name="l00177"></a>00177 <span class="comment">// best represent the whole set. the definition of 'best' here is not</span>
<a name="l00178"></a>00178 <span class="comment">// predetermined - the idea is to select points that give good box-box</span>
<a name="l00179"></a>00179 <span class="comment">// collision detection behavior. the chosen point indexes are returned in the</span>
<a name="l00180"></a>00180 <span class="comment">// array iret (of size m). 'i0' is always the first entry in the array.</span>
<a name="l00181"></a>00181 <span class="comment">// n must be in the range [1..8]. m must be in the range [1..n]. i0 must be</span>
<a name="l00182"></a>00182 <span class="comment">// in the range [0..n-1].</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keywordtype">void</span> cullPoints2 (<span class="keywordtype">int</span> n, btScalar p[], <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> iret[]);
<a name="l00185"></a>00185 <span class="keywordtype">void</span> cullPoints2 (<span class="keywordtype">int</span> n, btScalar p[], <span class="keywordtype">int</span> m, <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> iret[])
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187   <span class="comment">// compute the centroid of the polygon in cx,cy</span>
<a name="l00188"></a>00188   <span class="keywordtype">int</span> i,j;
<a name="l00189"></a>00189   btScalar a,cx,cy,q;
<a name="l00190"></a>00190   <span class="keywordflow">if</span> (n==1) {
<a name="l00191"></a>00191     cx = p[0];
<a name="l00192"></a>00192     cy = p[1];
<a name="l00193"></a>00193   }
<a name="l00194"></a>00194   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n==2) {
<a name="l00195"></a>00195     cx = btScalar(0.5)*(p[0] + p[2]);
<a name="l00196"></a>00196     cy = btScalar(0.5)*(p[1] + p[3]);
<a name="l00197"></a>00197   }
<a name="l00198"></a>00198   <span class="keywordflow">else</span> {
<a name="l00199"></a>00199     a = 0;
<a name="l00200"></a>00200     cx = 0;
<a name="l00201"></a>00201     cy = 0;
<a name="l00202"></a>00202     <span class="keywordflow">for</span> (i=0; i&lt;(n-1); i++) {
<a name="l00203"></a>00203       q = p[i*2]*p[i*2+3] - p[i*2+2]*p[i*2+1];
<a name="l00204"></a>00204       a += q;
<a name="l00205"></a>00205       cx += q*(p[i*2]+p[i*2+2]);
<a name="l00206"></a>00206       cy += q*(p[i*2+1]+p[i*2+3]);
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208     q = p[n*2-2]*p[1] - p[0]*p[n*2-1];
<a name="l00209"></a>00209         <span class="keywordflow">if</span> (btFabs(a+q) &gt; SIMD_EPSILON)
<a name="l00210"></a>00210         {
<a name="l00211"></a>00211                 a = 1.f/(btScalar(3.0)*(a+q));
<a name="l00212"></a>00212         } <span class="keywordflow">else</span>
<a name="l00213"></a>00213         {
<a name="l00214"></a>00214                 a=BT_LARGE_FLOAT;
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216     cx = a*(cx + q*(p[n*2-2]+p[0]));
<a name="l00217"></a>00217     cy = a*(cy + q*(p[n*2-1]+p[1]));
<a name="l00218"></a>00218   }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">// compute the angle of each point w.r.t. the centroid</span>
<a name="l00221"></a>00221   btScalar A[8];
<a name="l00222"></a>00222   <span class="keywordflow">for</span> (i=0; i&lt;n; i++) A[i] = btAtan2(p[i*2+1]-cy,p[i*2]-cx);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">// search for points that have angles closest to A[i0] + i*(2*pi/m).</span>
<a name="l00225"></a>00225   <span class="keywordtype">int</span> avail[8];
<a name="l00226"></a>00226   <span class="keywordflow">for</span> (i=0; i&lt;n; i++) avail[i] = 1;
<a name="l00227"></a>00227   avail[i0] = 0;
<a name="l00228"></a>00228   iret[0] = i0;
<a name="l00229"></a>00229   iret++;
<a name="l00230"></a>00230   <span class="keywordflow">for</span> (j=1; j&lt;m; j++) {
<a name="l00231"></a>00231     a = btScalar(j)*(2*M__PI/m) + A[i0];
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (a &gt; M__PI) a -= 2*M__PI;
<a name="l00233"></a>00233     btScalar maxdiff=1e9,diff;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     *iret = i0;                 <span class="comment">// iret is not allowed to keep this value, but it sometimes does, when diff=#QNAN0</span>
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
<a name="l00238"></a>00238       <span class="keywordflow">if</span> (avail[i]) {
<a name="l00239"></a>00239         diff = btFabs (A[i]-a);
<a name="l00240"></a>00240         <span class="keywordflow">if</span> (diff &gt; M__PI) diff = 2*M__PI - diff;
<a name="l00241"></a>00241         <span class="keywordflow">if</span> (diff &lt; maxdiff) {
<a name="l00242"></a>00242           maxdiff = diff;
<a name="l00243"></a>00243           *iret = i;
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245       }
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 <span class="preprocessor">#if defined(DEBUG) || defined (_DEBUG)</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>    btAssert (*iret != i0);     <span class="comment">// ensure iret got set</span>
<a name="l00249"></a>00249 <span class="preprocessor">#endif</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>    avail[*iret] = 0;
<a name="l00251"></a>00251     iret++;
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keywordtype">int</span> dBoxBox2 (<span class="keyword">const</span> btVector3&amp; p1, <span class="keyword">const</span> dMatrix3 R1,
<a name="l00258"></a>00258              <span class="keyword">const</span> btVector3&amp; side1, <span class="keyword">const</span> btVector3&amp; p2,
<a name="l00259"></a>00259              <span class="keyword">const</span> dMatrix3 R2, <span class="keyword">const</span> btVector3&amp; side2,
<a name="l00260"></a>00260              btVector3&amp; normal, btScalar *depth, <span class="keywordtype">int</span> *return_code,
<a name="l00261"></a>00261                  <span class="keywordtype">int</span> maxc, dContactGeom * <span class="comment">/*contact*/</span>, <span class="keywordtype">int</span> <span class="comment">/*skip*/</span>,btDiscreteCollisionDetectorInterface::Result&amp; output);
<a name="l00262"></a>00262 <span class="keywordtype">int</span> dBoxBox2 (<span class="keyword">const</span> btVector3&amp; p1, <span class="keyword">const</span> dMatrix3 R1,
<a name="l00263"></a>00263              <span class="keyword">const</span> btVector3&amp; side1, <span class="keyword">const</span> btVector3&amp; p2,
<a name="l00264"></a>00264              <span class="keyword">const</span> dMatrix3 R2, <span class="keyword">const</span> btVector3&amp; side2,
<a name="l00265"></a>00265              btVector3&amp; normal, btScalar *depth, <span class="keywordtype">int</span> *return_code,
<a name="l00266"></a>00266                  <span class="keywordtype">int</span> maxc, dContactGeom * <span class="comment">/*contact*/</span>, <span class="keywordtype">int</span> <span class="comment">/*skip*/</span>,btDiscreteCollisionDetectorInterface::Result&amp; output)
<a name="l00267"></a>00267 {
<a name="l00268"></a>00268   <span class="keyword">const</span> btScalar fudge_factor = btScalar(1.05);
<a name="l00269"></a>00269   btVector3 p,pp,normalC(0.f,0.f,0.f);
<a name="l00270"></a>00270   <span class="keyword">const</span> btScalar *normalR = 0;
<a name="l00271"></a>00271   btScalar A[3],B[3],R11,R12,R13,R21,R22,R23,R31,R32,R33,
<a name="l00272"></a>00272     Q11,Q12,Q13,Q21,Q22,Q23,Q31,Q32,Q33,s,s2,l;
<a name="l00273"></a>00273   <span class="keywordtype">int</span> i,j,invert_normal,code;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="comment">// get vector from centers of box 1 to box 2, relative to box 1</span>
<a name="l00276"></a>00276   p = p2 - p1;
<a name="l00277"></a>00277   dMULTIPLY1_331 (pp,R1,p);             <span class="comment">// get pp = p relative to body 1</span>
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <span class="comment">// get side lengths / 2</span>
<a name="l00280"></a>00280   A[0] = side1[0]*btScalar(0.5);
<a name="l00281"></a>00281   A[1] = side1[1]*btScalar(0.5);
<a name="l00282"></a>00282   A[2] = side1[2]*btScalar(0.5);
<a name="l00283"></a>00283   B[0] = side2[0]*btScalar(0.5);
<a name="l00284"></a>00284   B[1] = side2[1]*btScalar(0.5);
<a name="l00285"></a>00285   B[2] = side2[2]*btScalar(0.5);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// Rij is R1'*R2, i.e. the relative rotation between R1 and R2</span>
<a name="l00288"></a>00288   R11 = dDOT44(R1+0,R2+0); R12 = dDOT44(R1+0,R2+1); R13 = dDOT44(R1+0,R2+2);
<a name="l00289"></a>00289   R21 = dDOT44(R1+1,R2+0); R22 = dDOT44(R1+1,R2+1); R23 = dDOT44(R1+1,R2+2);
<a name="l00290"></a>00290   R31 = dDOT44(R1+2,R2+0); R32 = dDOT44(R1+2,R2+1); R33 = dDOT44(R1+2,R2+2);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292   Q11 = btFabs(R11); Q12 = btFabs(R12); Q13 = btFabs(R13);
<a name="l00293"></a>00293   Q21 = btFabs(R21); Q22 = btFabs(R22); Q23 = btFabs(R23);
<a name="l00294"></a>00294   Q31 = btFabs(R31); Q32 = btFabs(R32); Q33 = btFabs(R33);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="comment">// for all 15 possible separating axes:</span>
<a name="l00297"></a>00297   <span class="comment">//   * see if the axis separates the boxes. if so, return 0.</span>
<a name="l00298"></a>00298   <span class="comment">//   * find the depth of the penetration along the separating axis (s2)</span>
<a name="l00299"></a>00299   <span class="comment">//   * if this is the largest depth so far, record it.</span>
<a name="l00300"></a>00300   <span class="comment">// the normal vector will be set to the separating axis with the smallest</span>
<a name="l00301"></a>00301   <span class="comment">// depth. note: normalR is set to point to a column of R1 or R2 if that is</span>
<a name="l00302"></a>00302   <span class="comment">// the smallest depth normal so far. otherwise normalR is 0 and normalC is</span>
<a name="l00303"></a>00303   <span class="comment">// set to a vector relative to body 1. invert_normal is 1 if the sign of</span>
<a name="l00304"></a>00304   <span class="comment">// the normal should be flipped.</span>
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="preprocessor">#define TST(expr1,expr2,norm,cc) \</span>
<a name="l00307"></a>00307 <span class="preprocessor">  s2 = btFabs(expr1) - (expr2); \</span>
<a name="l00308"></a>00308 <span class="preprocessor">  if (s2 &gt; 0) return 0; \</span>
<a name="l00309"></a>00309 <span class="preprocessor">  if (s2 &gt; s) { \</span>
<a name="l00310"></a>00310 <span class="preprocessor">    s = s2; \</span>
<a name="l00311"></a>00311 <span class="preprocessor">    normalR = norm; \</span>
<a name="l00312"></a>00312 <span class="preprocessor">    invert_normal = ((expr1) &lt; 0); \</span>
<a name="l00313"></a>00313 <span class="preprocessor">    code = (cc); \</span>
<a name="l00314"></a>00314 <span class="preprocessor">  }</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span>
<a name="l00316"></a>00316   s = -dInfinity;
<a name="l00317"></a>00317   invert_normal = 0;
<a name="l00318"></a>00318   code = 0;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="comment">// separating axis = u1,u2,u3</span>
<a name="l00321"></a>00321   TST (pp[0],(A[0] + B[0]*Q11 + B[1]*Q12 + B[2]*Q13),R1+0,1);
<a name="l00322"></a>00322   TST (pp[1],(A[1] + B[0]*Q21 + B[1]*Q22 + B[2]*Q23),R1+1,2);
<a name="l00323"></a>00323   TST (pp[2],(A[2] + B[0]*Q31 + B[1]*Q32 + B[2]*Q33),R1+2,3);
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="comment">// separating axis = v1,v2,v3</span>
<a name="l00326"></a>00326   TST (dDOT41(R2+0,p),(A[0]*Q11 + A[1]*Q21 + A[2]*Q31 + B[0]),R2+0,4);
<a name="l00327"></a>00327   TST (dDOT41(R2+1,p),(A[0]*Q12 + A[1]*Q22 + A[2]*Q32 + B[1]),R2+1,5);
<a name="l00328"></a>00328   TST (dDOT41(R2+2,p),(A[0]*Q13 + A[1]*Q23 + A[2]*Q33 + B[2]),R2+2,6);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="comment">// note: cross product axes need to be scaled when s is computed.</span>
<a name="l00331"></a>00331   <span class="comment">// normal (n1,n2,n3) is relative to box 1.</span>
<a name="l00332"></a>00332 <span class="preprocessor">#undef TST</span>
<a name="l00333"></a>00333 <span class="preprocessor"></span><span class="preprocessor">#define TST(expr1,expr2,n1,n2,n3,cc) \</span>
<a name="l00334"></a>00334 <span class="preprocessor">  s2 = btFabs(expr1) - (expr2); \</span>
<a name="l00335"></a>00335 <span class="preprocessor">  if (s2 &gt; SIMD_EPSILON) return 0; \</span>
<a name="l00336"></a>00336 <span class="preprocessor">  l = btSqrt((n1)*(n1) + (n2)*(n2) + (n3)*(n3)); \</span>
<a name="l00337"></a>00337 <span class="preprocessor">  if (l &gt; SIMD_EPSILON) { \</span>
<a name="l00338"></a>00338 <span class="preprocessor">    s2 /= l; \</span>
<a name="l00339"></a>00339 <span class="preprocessor">    if (s2*fudge_factor &gt; s) { \</span>
<a name="l00340"></a>00340 <span class="preprocessor">      s = s2; \</span>
<a name="l00341"></a>00341 <span class="preprocessor">      normalR = 0; \</span>
<a name="l00342"></a>00342 <span class="preprocessor">      normalC[0] = (n1)/l; normalC[1] = (n2)/l; normalC[2] = (n3)/l; \</span>
<a name="l00343"></a>00343 <span class="preprocessor">      invert_normal = ((expr1) &lt; 0); \</span>
<a name="l00344"></a>00344 <span class="preprocessor">      code = (cc); \</span>
<a name="l00345"></a>00345 <span class="preprocessor">    } \</span>
<a name="l00346"></a>00346 <span class="preprocessor">  }</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span>
<a name="l00348"></a>00348   btScalar fudge2 (1.0<a class="code" href="group__gtc__constants.html#g2425b9c6a54d9d91fd1a634700e85cf1">e</a>-5f);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   Q11 += fudge2;
<a name="l00351"></a>00351   Q12 += fudge2;
<a name="l00352"></a>00352   Q13 += fudge2;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   Q21 += fudge2;
<a name="l00355"></a>00355   Q22 += fudge2;
<a name="l00356"></a>00356   Q23 += fudge2;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   Q31 += fudge2;
<a name="l00359"></a>00359   Q32 += fudge2;
<a name="l00360"></a>00360   Q33 += fudge2;
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="comment">// separating axis = u1 x (v1,v2,v3)</span>
<a name="l00363"></a>00363   TST(pp[2]*R21-pp[1]*R31,(A[1]*Q31+A[2]*Q21+B[1]*Q13+B[2]*Q12),0,-R31,R21,7);
<a name="l00364"></a>00364   TST(pp[2]*R22-pp[1]*R32,(A[1]*Q32+A[2]*Q22+B[0]*Q13+B[2]*Q11),0,-R32,R22,8);
<a name="l00365"></a>00365   TST(pp[2]*R23-pp[1]*R33,(A[1]*Q33+A[2]*Q23+B[0]*Q12+B[1]*Q11),0,-R33,R23,9);
<a name="l00366"></a>00366 
<a name="l00367"></a>00367   <span class="comment">// separating axis = u2 x (v1,v2,v3)</span>
<a name="l00368"></a>00368   TST(pp[0]*R31-pp[2]*R11,(A[0]*Q31+A[2]*Q11+B[1]*Q23+B[2]*Q22),R31,0,-R11,10);
<a name="l00369"></a>00369   TST(pp[0]*R32-pp[2]*R12,(A[0]*Q32+A[2]*Q12+B[0]*Q23+B[2]*Q21),R32,0,-R12,11);
<a name="l00370"></a>00370   TST(pp[0]*R33-pp[2]*R13,(A[0]*Q33+A[2]*Q13+B[0]*Q22+B[1]*Q21),R33,0,-R13,12);
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">// separating axis = u3 x (v1,v2,v3)</span>
<a name="l00373"></a>00373   TST(pp[1]*R11-pp[0]*R21,(A[0]*Q21+A[1]*Q11+B[1]*Q33+B[2]*Q32),-R21,R11,0,13);
<a name="l00374"></a>00374   TST(pp[1]*R12-pp[0]*R22,(A[0]*Q22+A[1]*Q12+B[0]*Q33+B[2]*Q31),-R22,R12,0,14);
<a name="l00375"></a>00375   TST(pp[1]*R13-pp[0]*R23,(A[0]*Q23+A[1]*Q13+B[0]*Q32+B[1]*Q31),-R23,R13,0,15);
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="preprocessor">#undef TST</span>
<a name="l00378"></a>00378 <span class="preprocessor"></span>
<a name="l00379"></a>00379   <span class="keywordflow">if</span> (!code) <span class="keywordflow">return</span> 0;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">// if we get to this point, the boxes interpenetrate. compute the normal</span>
<a name="l00382"></a>00382   <span class="comment">// in global coordinates.</span>
<a name="l00383"></a>00383   <span class="keywordflow">if</span> (normalR) {
<a name="l00384"></a>00384     normal[0] = normalR[0];
<a name="l00385"></a>00385     normal[1] = normalR[4];
<a name="l00386"></a>00386     normal[2] = normalR[8];
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388   <span class="keywordflow">else</span> {
<a name="l00389"></a>00389     dMULTIPLY0_331 (normal,R1,normalC);
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391   <span class="keywordflow">if</span> (invert_normal) {
<a name="l00392"></a>00392     normal[0] = -normal[0];
<a name="l00393"></a>00393     normal[1] = -normal[1];
<a name="l00394"></a>00394     normal[2] = -normal[2];
<a name="l00395"></a>00395   }
<a name="l00396"></a>00396   *depth = -s;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398   <span class="comment">// compute contact point(s)</span>
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <span class="keywordflow">if</span> (code &gt; 6) {
<a name="l00401"></a>00401     <span class="comment">// an edge from box 1 touches an edge from box 2.</span>
<a name="l00402"></a>00402     <span class="comment">// find a point pa on the intersecting edge of box 1</span>
<a name="l00403"></a>00403     btVector3 pa;
<a name="l00404"></a>00404     btScalar <a class="code" href="group__core__func__common.html#g74ce53889485c33ac9d81d2b27165c80">sign</a>;
<a name="l00405"></a>00405     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pa[i] = p1[i];
<a name="l00406"></a>00406     <span class="keywordflow">for</span> (j=0; j&lt;3; j++) {
<a name="l00407"></a>00407       sign = (dDOT14(normal,R1+j) &gt; 0) ? btScalar(1.0) : btScalar(-1.0);
<a name="l00408"></a>00408       <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pa[i] += sign * A[j] * R1[i*4+j];
<a name="l00409"></a>00409     }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411     <span class="comment">// find a point pb on the intersecting edge of box 2</span>
<a name="l00412"></a>00412     btVector3 pb;
<a name="l00413"></a>00413     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pb[i] = p2[i];
<a name="l00414"></a>00414     <span class="keywordflow">for</span> (j=0; j&lt;3; j++) {
<a name="l00415"></a>00415       sign = (dDOT14(normal,R2+j) &gt; 0) ? btScalar(-1.0) : btScalar(1.0);
<a name="l00416"></a>00416       <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pb[i] += sign * B[j] * R2[i*4+j];
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     btScalar alpha,beta;
<a name="l00420"></a>00420     btVector3 ua,ub;
<a name="l00421"></a>00421     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) ua[i] = R1[((code)-7)/3 + i*4];
<a name="l00422"></a>00422     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) ub[i] = R2[((code)-7)%3 + i*4];
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     dLineClosestApproach (pa,ua,pb,ub,&amp;alpha,&amp;beta);
<a name="l00425"></a>00425     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pa[i] += ua[i]*alpha;
<a name="l00426"></a>00426     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) pb[i] += ub[i]*beta;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         {
<a name="l00429"></a>00429                 
<a name="l00430"></a>00430                 <span class="comment">//contact[0].pos[i] = btScalar(0.5)*(pa[i]+pb[i]);</span>
<a name="l00431"></a>00431                 <span class="comment">//contact[0].depth = *depth;</span>
<a name="l00432"></a>00432                 btVector3 pointInWorld;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="preprocessor">#ifdef USE_CENTER_POINT</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>            <span class="keywordflow">for</span> (i=0; i&lt;3; i++) 
<a name="l00436"></a>00436                         pointInWorld[i] = (pa[i]+pb[i])*btScalar(0.5);
<a name="l00437"></a>00437                 output.addContactPoint(-normal,pointInWorld,-*depth);
<a name="l00438"></a>00438 <span class="preprocessor">#else</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span>                output.addContactPoint(-normal,pb,-*depth);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="preprocessor">#endif //</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>                *return_code = code;
<a name="l00443"></a>00443         }
<a name="l00444"></a>00444     <span class="keywordflow">return</span> 1;
<a name="l00445"></a>00445   }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="comment">// okay, we have a face-something intersection (because the separating</span>
<a name="l00448"></a>00448   <span class="comment">// axis is perpendicular to a face). define face 'a' to be the reference</span>
<a name="l00449"></a>00449   <span class="comment">// face (i.e. the normal vector is perpendicular to this) and face 'b' to be</span>
<a name="l00450"></a>00450   <span class="comment">// the incident face (the closest face of the other box).</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452   <span class="keyword">const</span> btScalar *Ra,*Rb,*pa,*pb,*Sa,*Sb;
<a name="l00453"></a>00453   <span class="keywordflow">if</span> (code &lt;= 3) {
<a name="l00454"></a>00454     Ra = R1;
<a name="l00455"></a>00455     Rb = R2;
<a name="l00456"></a>00456     pa = p1;
<a name="l00457"></a>00457     pb = p2;
<a name="l00458"></a>00458     Sa = A;
<a name="l00459"></a>00459     Sb = B;
<a name="l00460"></a>00460   }
<a name="l00461"></a>00461   <span class="keywordflow">else</span> {
<a name="l00462"></a>00462     Ra = R2;
<a name="l00463"></a>00463     Rb = R1;
<a name="l00464"></a>00464     pa = p2;
<a name="l00465"></a>00465     pb = p1;
<a name="l00466"></a>00466     Sa = B;
<a name="l00467"></a>00467     Sb = A;
<a name="l00468"></a>00468   }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="comment">// nr = normal vector of reference face dotted with axes of incident box.</span>
<a name="l00471"></a>00471   <span class="comment">// anr = absolute values of nr.</span>
<a name="l00472"></a>00472   btVector3 normal2,nr,anr;
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (code &lt;= 3) {
<a name="l00474"></a>00474     normal2[0] = normal[0];
<a name="l00475"></a>00475     normal2[1] = normal[1];
<a name="l00476"></a>00476     normal2[2] = normal[2];
<a name="l00477"></a>00477   }
<a name="l00478"></a>00478   <span class="keywordflow">else</span> {
<a name="l00479"></a>00479     normal2[0] = -normal[0];
<a name="l00480"></a>00480     normal2[1] = -normal[1];
<a name="l00481"></a>00481     normal2[2] = -normal[2];
<a name="l00482"></a>00482   }
<a name="l00483"></a>00483   dMULTIPLY1_331 (nr,Rb,normal2);
<a name="l00484"></a>00484   anr[0] = btFabs (nr[0]);
<a name="l00485"></a>00485   anr[1] = btFabs (nr[1]);
<a name="l00486"></a>00486   anr[2] = btFabs (nr[2]);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488   <span class="comment">// find the largest compontent of anr: this corresponds to the normal</span>
<a name="l00489"></a>00489   <span class="comment">// for the indident face. the other axis numbers of the indicent face</span>
<a name="l00490"></a>00490   <span class="comment">// are stored in a1,a2.</span>
<a name="l00491"></a>00491   <span class="keywordtype">int</span> lanr,a1,a2;
<a name="l00492"></a>00492   <span class="keywordflow">if</span> (anr[1] &gt; anr[0]) {
<a name="l00493"></a>00493     <span class="keywordflow">if</span> (anr[1] &gt; anr[2]) {
<a name="l00494"></a>00494       a1 = 0;
<a name="l00495"></a>00495       lanr = 1;
<a name="l00496"></a>00496       a2 = 2;
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498     <span class="keywordflow">else</span> {
<a name="l00499"></a>00499       a1 = 0;
<a name="l00500"></a>00500       a2 = 1;
<a name="l00501"></a>00501       lanr = 2;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503   }
<a name="l00504"></a>00504   <span class="keywordflow">else</span> {
<a name="l00505"></a>00505     <span class="keywordflow">if</span> (anr[0] &gt; anr[2]) {
<a name="l00506"></a>00506       lanr = 0;
<a name="l00507"></a>00507       a1 = 1;
<a name="l00508"></a>00508       a2 = 2;
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510     <span class="keywordflow">else</span> {
<a name="l00511"></a>00511       a1 = 0;
<a name="l00512"></a>00512       a2 = 1;
<a name="l00513"></a>00513       lanr = 2;
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515   }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="comment">// compute center point of incident face, in reference-face coordinates</span>
<a name="l00518"></a>00518   btVector3 center;
<a name="l00519"></a>00519   <span class="keywordflow">if</span> (nr[lanr] &lt; 0) {
<a name="l00520"></a>00520     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) center[i] = pb[i] - pa[i] + Sb[lanr] * Rb[i*4+lanr];
<a name="l00521"></a>00521   }
<a name="l00522"></a>00522   <span class="keywordflow">else</span> {
<a name="l00523"></a>00523     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) center[i] = pb[i] - pa[i] - Sb[lanr] * Rb[i*4+lanr];
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="comment">// find the normal and non-normal axis numbers of the reference box</span>
<a name="l00527"></a>00527   <span class="keywordtype">int</span> codeN,code1,code2;
<a name="l00528"></a>00528   <span class="keywordflow">if</span> (code &lt;= 3) codeN = code-1; <span class="keywordflow">else</span> codeN = code-4;
<a name="l00529"></a>00529   <span class="keywordflow">if</span> (codeN==0) {
<a name="l00530"></a>00530     code1 = 1;
<a name="l00531"></a>00531     code2 = 2;
<a name="l00532"></a>00532   }
<a name="l00533"></a>00533   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (codeN==1) {
<a name="l00534"></a>00534     code1 = 0;
<a name="l00535"></a>00535     code2 = 2;
<a name="l00536"></a>00536   }
<a name="l00537"></a>00537   <span class="keywordflow">else</span> {
<a name="l00538"></a>00538     code1 = 0;
<a name="l00539"></a>00539     code2 = 1;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <span class="comment">// find the four corners of the incident face, in reference-face coordinates</span>
<a name="l00543"></a>00543   btScalar quad[8];     <span class="comment">// 2D coordinate of incident face (x,y pairs)</span>
<a name="l00544"></a>00544   btScalar c1,c2,m11,m12,m21,m22;
<a name="l00545"></a>00545   c1 = dDOT14 (center,Ra+code1);
<a name="l00546"></a>00546   c2 = dDOT14 (center,Ra+code2);
<a name="l00547"></a>00547   <span class="comment">// optimize this? - we have already computed this data above, but it is not</span>
<a name="l00548"></a>00548   <span class="comment">// stored in an easy-to-index format. for now it's quicker just to recompute</span>
<a name="l00549"></a>00549   <span class="comment">// the four dot products.</span>
<a name="l00550"></a>00550   m11 = dDOT44 (Ra+code1,Rb+a1);
<a name="l00551"></a>00551   m12 = dDOT44 (Ra+code1,Rb+a2);
<a name="l00552"></a>00552   m21 = dDOT44 (Ra+code2,Rb+a1);
<a name="l00553"></a>00553   m22 = dDOT44 (Ra+code2,Rb+a2);
<a name="l00554"></a>00554   {
<a name="l00555"></a>00555     btScalar k1 = m11*Sb[a1];
<a name="l00556"></a>00556     btScalar k2 = m21*Sb[a1];
<a name="l00557"></a>00557     btScalar k3 = m12*Sb[a2];
<a name="l00558"></a>00558     btScalar k4 = m22*Sb[a2];
<a name="l00559"></a>00559     quad[0] = c1 - k1 - k3;
<a name="l00560"></a>00560     quad[1] = c2 - k2 - k4;
<a name="l00561"></a>00561     quad[2] = c1 - k1 + k3;
<a name="l00562"></a>00562     quad[3] = c2 - k2 + k4;
<a name="l00563"></a>00563     quad[4] = c1 + k1 + k3;
<a name="l00564"></a>00564     quad[5] = c2 + k2 + k4;
<a name="l00565"></a>00565     quad[6] = c1 + k1 - k3;
<a name="l00566"></a>00566     quad[7] = c2 + k2 - k4;
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569   <span class="comment">// find the size of the reference face</span>
<a name="l00570"></a>00570   btScalar rect[2];
<a name="l00571"></a>00571   rect[0] = Sa[code1];
<a name="l00572"></a>00572   rect[1] = Sa[code2];
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <span class="comment">// intersect the incident and reference faces</span>
<a name="l00575"></a>00575   btScalar ret[16];
<a name="l00576"></a>00576   <span class="keywordtype">int</span> n = intersectRectQuad2 (rect,quad,ret);
<a name="l00577"></a>00577   <span class="keywordflow">if</span> (n &lt; 1) <span class="keywordflow">return</span> 0;          <span class="comment">// this should never happen</span>
<a name="l00578"></a>00578 
<a name="l00579"></a>00579   <span class="comment">// convert the intersection points into reference-face coordinates,</span>
<a name="l00580"></a>00580   <span class="comment">// and compute the contact position and depth for each point. only keep</span>
<a name="l00581"></a>00581   <span class="comment">// those points that have a positive (penetrating) depth. delete points in</span>
<a name="l00582"></a>00582   <span class="comment">// the 'ret' array as necessary so that 'point' and 'ret' correspond.</span>
<a name="l00583"></a>00583   btScalar point[3*8];          <span class="comment">// penetrating contact points</span>
<a name="l00584"></a>00584   btScalar dep[8];                      <span class="comment">// depths for those points</span>
<a name="l00585"></a>00585   btScalar det1 = 1.f/(m11*m22 - m12*m21);
<a name="l00586"></a>00586   m11 *= det1;
<a name="l00587"></a>00587   m12 *= det1;
<a name="l00588"></a>00588   m21 *= det1;
<a name="l00589"></a>00589   m22 *= det1;
<a name="l00590"></a>00590   <span class="keywordtype">int</span> cnum = 0;                 <span class="comment">// number of penetrating contact points found</span>
<a name="l00591"></a>00591   <span class="keywordflow">for</span> (j=0; j &lt; n; j++) {
<a name="l00592"></a>00592     btScalar k1 =  m22*(ret[j*2]-c1) - m12*(ret[j*2+1]-c2);
<a name="l00593"></a>00593     btScalar k2 = -m21*(ret[j*2]-c1) + m11*(ret[j*2+1]-c2);
<a name="l00594"></a>00594     <span class="keywordflow">for</span> (i=0; i&lt;3; i++) point[cnum*3+i] =
<a name="l00595"></a>00595                           center[i] + k1*Rb[i*4+a1] + k2*Rb[i*4+a2];
<a name="l00596"></a>00596     dep[cnum] = Sa[codeN] - dDOT(normal2,point+cnum*3);
<a name="l00597"></a>00597     <span class="keywordflow">if</span> (dep[cnum] &gt;= 0) {
<a name="l00598"></a>00598       ret[cnum*2] = ret[j*2];
<a name="l00599"></a>00599       ret[cnum*2+1] = ret[j*2+1];
<a name="l00600"></a>00600       cnum++;
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602   }
<a name="l00603"></a>00603   <span class="keywordflow">if</span> (cnum &lt; 1) <span class="keywordflow">return</span> 0;       <span class="comment">// this should never happen</span>
<a name="l00604"></a>00604 
<a name="l00605"></a>00605   <span class="comment">// we can't generate more contacts than we actually have</span>
<a name="l00606"></a>00606   <span class="keywordflow">if</span> (maxc &gt; cnum) maxc = cnum;
<a name="l00607"></a>00607   <span class="keywordflow">if</span> (maxc &lt; 1) maxc = 1;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="keywordflow">if</span> (cnum &lt;= maxc) {
<a name="l00610"></a>00610 
<a name="l00611"></a>00611           <span class="keywordflow">if</span> (code&lt;4) 
<a name="l00612"></a>00612           {
<a name="l00613"></a>00613     <span class="comment">// we have less contacts than we need, so we use them all</span>
<a name="l00614"></a>00614     <span class="keywordflow">for</span> (j=0; j &lt; cnum; j++) 
<a name="l00615"></a>00615         {
<a name="l00616"></a>00616                 btVector3 pointInWorld;
<a name="l00617"></a>00617                 <span class="keywordflow">for</span> (i=0; i&lt;3; i++) 
<a name="l00618"></a>00618                         pointInWorld[i] = point[j*3+i] + pa[i];
<a name="l00619"></a>00619                 output.addContactPoint(-normal,pointInWorld,-dep[j]);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622           } <span class="keywordflow">else</span>
<a name="l00623"></a>00623           {
<a name="l00624"></a>00624                   <span class="comment">// we have less contacts than we need, so we use them all</span>
<a name="l00625"></a>00625                 <span class="keywordflow">for</span> (j=0; j &lt; cnum; j++) 
<a name="l00626"></a>00626                 {
<a name="l00627"></a>00627                         btVector3 pointInWorld;
<a name="l00628"></a>00628                         <span class="keywordflow">for</span> (i=0; i&lt;3; i++) 
<a name="l00629"></a>00629                                 pointInWorld[i] = point[j*3+i] + pa[i]-normal[i]*dep[j];
<a name="l00630"></a>00630                                 <span class="comment">//pointInWorld[i] = point[j*3+i] + pa[i];</span>
<a name="l00631"></a>00631                         output.addContactPoint(-normal,pointInWorld,-dep[j]);
<a name="l00632"></a>00632                 }
<a name="l00633"></a>00633           }
<a name="l00634"></a>00634   }
<a name="l00635"></a>00635   <span class="keywordflow">else</span> {
<a name="l00636"></a>00636     <span class="comment">// we have more contacts than are wanted, some of them must be culled.</span>
<a name="l00637"></a>00637     <span class="comment">// find the deepest point, it is always the first contact.</span>
<a name="l00638"></a>00638     <span class="keywordtype">int</span> i1 = 0;
<a name="l00639"></a>00639     btScalar maxdepth = dep[0];
<a name="l00640"></a>00640     <span class="keywordflow">for</span> (i=1; i&lt;cnum; i++) {
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (dep[i] &gt; maxdepth) {
<a name="l00642"></a>00642         maxdepth = dep[i];
<a name="l00643"></a>00643         i1 = i;
<a name="l00644"></a>00644       }
<a name="l00645"></a>00645     }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647     <span class="keywordtype">int</span> iret[8];
<a name="l00648"></a>00648     cullPoints2 (cnum,ret,maxc,i1,iret);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650     <span class="keywordflow">for</span> (j=0; j &lt; maxc; j++) {
<a name="l00651"></a>00651 <span class="comment">//      dContactGeom *con = CONTACT(contact,skip*j);</span>
<a name="l00652"></a>00652   <span class="comment">//    for (i=0; i&lt;3; i++) con-&gt;pos[i] = point[iret[j]*3+i] + pa[i];</span>
<a name="l00653"></a>00653     <span class="comment">//  con-&gt;depth = dep[iret[j]];</span>
<a name="l00654"></a>00654 
<a name="l00655"></a>00655                 btVector3 posInWorld;
<a name="l00656"></a>00656                 <span class="keywordflow">for</span> (i=0; i&lt;3; i++) 
<a name="l00657"></a>00657                         posInWorld[i] = point[iret[j]*3+i] + pa[i];
<a name="l00658"></a>00658                 <span class="keywordflow">if</span> (code&lt;4) 
<a name="l00659"></a>00659            {
<a name="l00660"></a>00660                         output.addContactPoint(-normal,posInWorld,-dep[iret[j]]);
<a name="l00661"></a>00661                 } <span class="keywordflow">else</span>
<a name="l00662"></a>00662                 {
<a name="l00663"></a>00663                         output.addContactPoint(-normal,posInWorld-normal*dep[iret[j]],-dep[iret[j]]);
<a name="l00664"></a>00664                 }
<a name="l00665"></a>00665     }
<a name="l00666"></a>00666     cnum = maxc;
<a name="l00667"></a>00667   }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   *return_code = code;
<a name="l00670"></a>00670   <span class="keywordflow">return</span> cnum;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="keywordtype">void</span>    btBoxBoxDetector::getClosestPoints(<span class="keyword">const</span> ClosestPointInput&amp; input,Result&amp; output,<span class="keyword">class</span> <a class="code" href="classbt_i_debug_draw.html">btIDebugDraw</a>* <span class="comment">/*debugDraw*/</span>,<span class="keywordtype">bool</span> <span class="comment">/*swapResults*/</span>)
<a name="l00674"></a>00674 {
<a name="l00675"></a>00675         
<a name="l00676"></a>00676         <span class="keyword">const</span> btTransform&amp; transformA = input.m_transformA;
<a name="l00677"></a>00677         <span class="keyword">const</span> btTransform&amp; transformB = input.m_transformB;
<a name="l00678"></a>00678         
<a name="l00679"></a>00679         <span class="keywordtype">int</span> skip = 0;
<a name="l00680"></a>00680         dContactGeom *contact = 0;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         dMatrix3 R1;
<a name="l00683"></a>00683         dMatrix3 R2;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;3;j++)
<a name="l00686"></a>00686         {
<a name="l00687"></a>00687                 R1[0+4*j] = transformA.getBasis()[j].x();
<a name="l00688"></a>00688                 R2[0+4*j] = transformB.getBasis()[j].x();
<a name="l00689"></a>00689 
<a name="l00690"></a>00690                 R1[1+4*j] = transformA.getBasis()[j].y();
<a name="l00691"></a>00691                 R2[1+4*j] = transformB.getBasis()[j].y();
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00694"></a>00694                 R1[2+4*j] = transformA.getBasis()[j].z();
<a name="l00695"></a>00695                 R2[2+4*j] = transformB.getBasis()[j].z();
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         btVector3 normal;
<a name="l00702"></a>00702         btScalar depth;
<a name="l00703"></a>00703         <span class="keywordtype">int</span> return_code;
<a name="l00704"></a>00704         <span class="keywordtype">int</span> maxc = 4;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         dBoxBox2 (transformA.getOrigin(), 
<a name="l00708"></a>00708         R1,
<a name="l00709"></a>00709         2.f*m_box1-&gt;getHalfExtentsWithMargin(),
<a name="l00710"></a>00710         transformB.getOrigin(),
<a name="l00711"></a>00711         R2, 
<a name="l00712"></a>00712         2.f*m_box2-&gt;getHalfExtentsWithMargin(),
<a name="l00713"></a>00713         normal, &amp;depth, &amp;return_code,
<a name="l00714"></a>00714         maxc, contact, skip,
<a name="l00715"></a>00715         output
<a name="l00716"></a>00716         );
<a name="l00717"></a>00717 
<a name="l00718"></a>00718 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 12:56:46 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
