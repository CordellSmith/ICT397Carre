<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/Dynamics/btRigidBody.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/Dynamics/btRigidBody.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Bullet Continuous Collision Detection and Physics Library</span>
<a name="l00003"></a>00003 <span class="comment">Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">This software is provided 'as-is', without any express or implied warranty.</span>
<a name="l00006"></a>00006 <span class="comment">In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00007"></a>00007 <span class="comment">Permission is granted to anyone to use this software for any purpose, </span>
<a name="l00008"></a>00008 <span class="comment">including commercial applications, and to alter it and redistribute it freely, </span>
<a name="l00009"></a>00009 <span class="comment">subject to the following restrictions:</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00012"></a>00012 <span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00013"></a>00013 <span class="comment">3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00014"></a>00014 <span class="comment">*/</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include "btRigidBody.h"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include "BulletCollision/CollisionShapes/btConvexShape.h"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include "LinearMath/btMinMax.h"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include "LinearMath/btTransformUtil.h"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "LinearMath/btMotionState.h"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include "LinearMath/btSerializer.h"</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">//'temporarily' global variables</span>
<a name="l00025"></a>00025 btScalar        gDeactivationTime = btScalar(2.);
<a name="l00026"></a>00026 <span class="keywordtype">bool</span>    gDisableDeactivation = <span class="keyword">false</span>;
<a name="l00027"></a>00027 <span class="keyword">static</span> <span class="keywordtype">int</span> uniqueId = 0;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 
<a name="l00030"></a><a class="code" href="classbt_rigid_body.html#66a55c268281f64e849851a929449ffd">00030</a> <a class="code" href="classbt_rigid_body.html#66a55c268281f64e849851a929449ffd" title="btRigidBody constructor using construction info">btRigidBody::btRigidBody</a>(<span class="keyword">const</span> <a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html">btRigidBody::btRigidBodyConstructionInfo</a>&amp; constructionInfo)
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032         <a class="code" href="classbt_rigid_body.html#daa57210b4f5388b63a11db376358dd0" title="setupRigidBody is only used internally by the constructor">setupRigidBody</a>(constructionInfo);
<a name="l00033"></a>00033 }
<a name="l00034"></a>00034 
<a name="l00035"></a><a class="code" href="classbt_rigid_body.html#ac9b7d050bc87644d38e9ffe4fe4c5ab">00035</a> <a class="code" href="classbt_rigid_body.html#66a55c268281f64e849851a929449ffd" title="btRigidBody constructor using construction info">btRigidBody::btRigidBody</a>(btScalar mass, <a class="code" href="classbt_motion_state.html">btMotionState</a> *motionState, btCollisionShape *collisionShape, <span class="keyword">const</span> btVector3 &amp;localInertia)
<a name="l00036"></a>00036 {
<a name="l00037"></a>00037         <a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html">btRigidBodyConstructionInfo</a> cinfo(mass,motionState,collisionShape,localInertia);
<a name="l00038"></a>00038         <a class="code" href="classbt_rigid_body.html#daa57210b4f5388b63a11db376358dd0" title="setupRigidBody is only used internally by the constructor">setupRigidBody</a>(cinfo);
<a name="l00039"></a>00039 }
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="classbt_rigid_body.html#daa57210b4f5388b63a11db376358dd0">00041</a> <span class="keywordtype">void</span>    <a class="code" href="classbt_rigid_body.html#daa57210b4f5388b63a11db376358dd0" title="setupRigidBody is only used internally by the constructor">btRigidBody::setupRigidBody</a>(<span class="keyword">const</span> <a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html">btRigidBody::btRigidBodyConstructionInfo</a>&amp; constructionInfo)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043 
<a name="l00044"></a>00044         m_internalType=CO_RIGID_BODY;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         m_linearVelocity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
<a name="l00047"></a>00047         m_angularVelocity.setValue(btScalar(0.),btScalar(0.),btScalar(0.));
<a name="l00048"></a>00048         m_angularFactor.setValue(1,1,1);
<a name="l00049"></a>00049         m_linearFactor.setValue(1,1,1);
<a name="l00050"></a>00050         m_gravity.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
<a name="l00051"></a>00051         m_gravity_acceleration.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
<a name="l00052"></a>00052         m_totalForce.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0));
<a name="l00053"></a>00053         m_totalTorque.setValue(btScalar(0.0), btScalar(0.0), btScalar(0.0)),
<a name="l00054"></a>00054     setDamping(constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#b74df15a7cd29a48628e416dc0cf166e">m_linearDamping</a>, constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#9bec3e4c1e96b99165969a5777bf6199">m_angularDamping</a>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056         m_linearSleepingThreshold = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#382486eb29c274813a5c94abe362fb43">m_linearSleepingThreshold</a>;
<a name="l00057"></a>00057         m_angularSleepingThreshold = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#d594f539db30c73497825a5e1d48c553">m_angularSleepingThreshold</a>;
<a name="l00058"></a>00058         m_optionalMotionState = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#729b0b79412f36ac983d4adafbffa429">m_motionState</a>;
<a name="l00059"></a>00059         m_contactSolverType = 0;
<a name="l00060"></a>00060         m_frictionSolverType = 0;
<a name="l00061"></a>00061         m_additionalDamping = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#0f229267a8bd1018fc097d61c24f842b">m_additionalDamping</a>;
<a name="l00062"></a>00062         m_additionalDampingFactor = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#c6d2e032902d110c82582c6a32e4e0f9">m_additionalDampingFactor</a>;
<a name="l00063"></a>00063         m_additionalLinearDampingThresholdSqr = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#9ad11b15b26da0273510452bcb120d58">m_additionalLinearDampingThresholdSqr</a>;
<a name="l00064"></a>00064         m_additionalAngularDampingThresholdSqr = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#f9ce4aa036c0610ff1acb9e30df35c85">m_additionalAngularDampingThresholdSqr</a>;
<a name="l00065"></a>00065         m_additionalAngularDampingFactor = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#79629c6fa7631eeb72f25d10b4e17513">m_additionalAngularDampingFactor</a>;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         <span class="keywordflow">if</span> (m_optionalMotionState)
<a name="l00068"></a>00068         {
<a name="l00069"></a>00069                 m_optionalMotionState-&gt;<a class="code" href="classbt_motion_state.html#5d30ed64161a4f36fe2affc3d3501412">getWorldTransform</a>(m_worldTransform);
<a name="l00070"></a>00070         } <span class="keywordflow">else</span>
<a name="l00071"></a>00071         {
<a name="l00072"></a>00072                 m_worldTransform = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#e8a7d3c32e1f4aa5a725aab48bd5c1e2">m_startWorldTransform</a>;
<a name="l00073"></a>00073         }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         m_interpolationWorldTransform = m_worldTransform;
<a name="l00076"></a>00076         m_interpolationLinearVelocity.setValue(0,0,0);
<a name="l00077"></a>00077         m_interpolationAngularVelocity.setValue(0,0,0);
<a name="l00078"></a>00078         
<a name="l00079"></a>00079         <span class="comment">//moved to btCollisionObject</span>
<a name="l00080"></a>00080         m_friction = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#096d36f8308c4ca9b225d7c7ad43a0bf" title="best simulation results when friction is non-zero">m_friction</a>;
<a name="l00081"></a>00081         m_rollingFriction = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#bb72d0a00d035d2224a927810e9ed972">m_rollingFriction</a>;
<a name="l00082"></a>00082     m_spinningFriction = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#41d7c0ec9c256837d6d5673523d4c717">m_spinningFriction</a>;
<a name="l00083"></a>00083     
<a name="l00084"></a>00084         m_restitution = constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#4cee9df6cc734b50e0ef7c7a4eeb43d8" title="best simulation results using zero restitution.">m_restitution</a>;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         setCollisionShape( constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#d8486f606af2546d898a8cf42d7b2db2">m_collisionShape</a> );
<a name="l00087"></a>00087         m_debugBodyId = uniqueId++;
<a name="l00088"></a>00088         
<a name="l00089"></a>00089         setMassProps(constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#f145a871d772aa1f6d7ff4f199c84bd2">m_mass</a>, constructionInfo.<a class="code" href="structbt_rigid_body_1_1bt_rigid_body_construction_info.html#b7bcfa5e5f6ce479409fa7ebd76e75eb">m_localInertia</a>);
<a name="l00090"></a>00090         updateInertiaTensor();
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         m_rigidbodyFlags = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         m_deltaLinearVelocity.setZero();
<a name="l00096"></a>00096         m_deltaAngularVelocity.setZero();
<a name="l00097"></a>00097         m_invMass = m_inverseMass*m_linearFactor;
<a name="l00098"></a>00098         m_pushVelocity.setZero();
<a name="l00099"></a>00099         m_turnVelocity.setZero();
<a name="l00100"></a>00100 
<a name="l00101"></a>00101         
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="classbt_rigid_body.html#f7f9b40d0abcfe9927d2e9c011947cec">00106</a> <span class="keywordtype">void</span> <a class="code" href="classbt_rigid_body.html#f7f9b40d0abcfe9927d2e9c011947cec" title="continuous collision detection needs prediction">btRigidBody::predictIntegratedTransform</a>(btScalar timeStep,btTransform&amp; predictedTransform) 
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108         btTransformUtil::integrateTransform(m_worldTransform,m_linearVelocity,m_angularVelocity,timeStep,predictedTransform);
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="keywordtype">void</span>                    btRigidBody::saveKinematicState(btScalar timeStep)
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113         <span class="comment">//todo: clamp to some (user definable) safe minimum timestep, to limit maximum angular/linear velocities</span>
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (timeStep != btScalar(0.))
<a name="l00115"></a>00115         {
<a name="l00116"></a>00116                 <span class="comment">//if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform</span>
<a name="l00117"></a>00117                 <span class="keywordflow">if</span> (getMotionState())
<a name="l00118"></a>00118                         getMotionState()-&gt;<a class="code" href="classbt_motion_state.html#5d30ed64161a4f36fe2affc3d3501412">getWorldTransform</a>(m_worldTransform);
<a name="l00119"></a>00119                 btVector3 linVel,angVel;
<a name="l00120"></a>00120                 
<a name="l00121"></a>00121                 btTransformUtil::calculateVelocity(m_interpolationWorldTransform,m_worldTransform,timeStep,m_linearVelocity,m_angularVelocity);
<a name="l00122"></a>00122                 m_interpolationLinearVelocity = m_linearVelocity;
<a name="l00123"></a>00123                 m_interpolationAngularVelocity = m_angularVelocity;
<a name="l00124"></a>00124                 m_interpolationWorldTransform = m_worldTransform;
<a name="l00125"></a>00125                 <span class="comment">//printf("angular = %f %f %f\n",m_angularVelocity.getX(),m_angularVelocity.getY(),m_angularVelocity.getZ());</span>
<a name="l00126"></a>00126         }
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128         
<a name="l00129"></a>00129 <span class="keywordtype">void</span>    btRigidBody::getAabb(btVector3&amp; aabbMin,btVector3&amp; aabbMax)<span class="keyword"> const</span>
<a name="l00130"></a>00130 <span class="keyword"></span>{
<a name="l00131"></a>00131         getCollisionShape()-&gt;getAabb(m_worldTransform,aabbMin,aabbMax);
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="keywordtype">void</span> btRigidBody::setGravity(<span class="keyword">const</span> btVector3&amp; acceleration) 
<a name="l00138"></a>00138 {
<a name="l00139"></a>00139         <span class="keywordflow">if</span> (m_inverseMass != btScalar(0.0))
<a name="l00140"></a>00140         {
<a name="l00141"></a>00141                 m_gravity = acceleration * (btScalar(1.0) / m_inverseMass);
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143         m_gravity_acceleration = acceleration;
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keywordtype">void</span> btRigidBody::setDamping(btScalar lin_damping, btScalar ang_damping)
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153         m_linearDamping = btClamped(lin_damping, (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
<a name="l00154"></a>00154         m_angularDamping = btClamped(ang_damping, (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 
<a name="l00161"></a><a class="code" href="classbt_rigid_body.html#3fecb8c50d734095f33e2c7624bfba2c">00161</a> <span class="keywordtype">void</span>                    <a class="code" href="classbt_rigid_body.html#3fecb8c50d734095f33e2c7624bfba2c" title="applyDamping damps the velocity, using the given m_linearDamping and m_angularDamping...">btRigidBody::applyDamping</a>(btScalar timeStep)
<a name="l00162"></a>00162 {
<a name="l00163"></a>00163         <span class="comment">//On new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74</span>
<a name="l00164"></a>00164         <span class="comment">//todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 <span class="comment">//#define USE_OLD_DAMPING_METHOD 1</span>
<a name="l00167"></a>00167 <span class="preprocessor">#ifdef USE_OLD_DAMPING_METHOD</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        m_linearVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_linearDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
<a name="l00169"></a>00169         m_angularVelocity *= GEN_clamped((btScalar(1.) - timeStep * m_angularDamping), (btScalar)btScalar(0.0), (btScalar)btScalar(1.0));
<a name="l00170"></a>00170 <span class="preprocessor">#else</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>        m_linearVelocity *= btPow(btScalar(1)-m_linearDamping, timeStep);
<a name="l00172"></a>00172         m_angularVelocity *= btPow(btScalar(1)-m_angularDamping, timeStep);
<a name="l00173"></a>00173 <span class="preprocessor">#endif</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>
<a name="l00175"></a>00175         <span class="keywordflow">if</span> (m_additionalDamping)
<a name="l00176"></a>00176         {
<a name="l00177"></a>00177                 <span class="comment">//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.</span>
<a name="l00178"></a>00178                 <span class="comment">//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete</span>
<a name="l00179"></a>00179                 <span class="keywordflow">if</span> ((m_angularVelocity.length2() &lt; m_additionalAngularDampingThresholdSqr) &amp;&amp;
<a name="l00180"></a>00180                         (m_linearVelocity.length2() &lt; m_additionalLinearDampingThresholdSqr))
<a name="l00181"></a>00181                 {
<a name="l00182"></a>00182                         m_angularVelocity *= m_additionalDampingFactor;
<a name="l00183"></a>00183                         m_linearVelocity *= m_additionalDampingFactor;
<a name="l00184"></a>00184                 }
<a name="l00185"></a>00185         
<a name="l00186"></a>00186 
<a name="l00187"></a>00187                 btScalar speed = m_linearVelocity.length();
<a name="l00188"></a>00188                 <span class="keywordflow">if</span> (speed &lt; m_linearDamping)
<a name="l00189"></a>00189                 {
<a name="l00190"></a>00190                         btScalar dampVel = btScalar(0.005);
<a name="l00191"></a>00191                         <span class="keywordflow">if</span> (speed &gt; dampVel)
<a name="l00192"></a>00192                         {
<a name="l00193"></a>00193                                 btVector3 dir = m_linearVelocity.normalized();
<a name="l00194"></a>00194                                 m_linearVelocity -=  dir * dampVel;
<a name="l00195"></a>00195                         } <span class="keywordflow">else</span>
<a name="l00196"></a>00196                         {
<a name="l00197"></a>00197                                 m_linearVelocity.setValue(btScalar(0.),btScalar(0.),btScalar(0.));
<a name="l00198"></a>00198                         }
<a name="l00199"></a>00199                 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201                 btScalar angSpeed = m_angularVelocity.length();
<a name="l00202"></a>00202                 <span class="keywordflow">if</span> (angSpeed &lt; m_angularDamping)
<a name="l00203"></a>00203                 {
<a name="l00204"></a>00204                         btScalar angDampVel = btScalar(0.005);
<a name="l00205"></a>00205                         <span class="keywordflow">if</span> (angSpeed &gt; angDampVel)
<a name="l00206"></a>00206                         {
<a name="l00207"></a>00207                                 btVector3 dir = m_angularVelocity.normalized();
<a name="l00208"></a>00208                                 m_angularVelocity -=  dir * angDampVel;
<a name="l00209"></a>00209                         } <span class="keywordflow">else</span>
<a name="l00210"></a>00210                         {
<a name="l00211"></a>00211                                 m_angularVelocity.setValue(btScalar(0.),btScalar(0.),btScalar(0.));
<a name="l00212"></a>00212                         }
<a name="l00213"></a>00213                 }
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="keywordtype">void</span> btRigidBody::applyGravity()
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (isStaticOrKinematicObject())
<a name="l00221"></a>00221                 <span class="keywordflow">return</span>;
<a name="l00222"></a>00222         
<a name="l00223"></a>00223         applyCentralForce(m_gravity);   
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="keywordtype">void</span> btRigidBody::proceedToTransform(<span class="keyword">const</span> btTransform&amp; newTrans)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229         setCenterOfMassTransform( newTrans );
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231         
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="keywordtype">void</span> btRigidBody::setMassProps(btScalar mass, <span class="keyword">const</span> btVector3&amp; inertia)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235         <span class="keywordflow">if</span> (mass == btScalar(0.))
<a name="l00236"></a>00236         {
<a name="l00237"></a>00237                 m_collisionFlags |= btCollisionObject::CF_STATIC_OBJECT;
<a name="l00238"></a>00238                 m_inverseMass = btScalar(0.);
<a name="l00239"></a>00239         } <span class="keywordflow">else</span>
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241                 m_collisionFlags &amp;= (~btCollisionObject::CF_STATIC_OBJECT);
<a name="l00242"></a>00242                 m_inverseMass = btScalar(1.0) / mass;
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         <span class="comment">//Fg = m * a</span>
<a name="l00246"></a>00246         m_gravity = mass * m_gravity_acceleration;
<a name="l00247"></a>00247         
<a name="l00248"></a>00248         m_invInertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x(): btScalar(0.0),
<a name="l00249"></a>00249                                    inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y(): btScalar(0.0),
<a name="l00250"></a>00250                                    inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z(): btScalar(0.0));
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         m_invMass = m_linearFactor*m_inverseMass;
<a name="l00253"></a>00253 }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255         
<a name="l00256"></a>00256 <span class="keywordtype">void</span> btRigidBody::updateInertiaTensor() 
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258         m_invInertiaTensorWorld = m_worldTransform.getBasis().scaled(m_invInertiaLocal) * m_worldTransform.getBasis().transpose();
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 btVector3 btRigidBody::getLocalInertia()<span class="keyword"> const</span>
<a name="l00264"></a>00264 <span class="keyword"></span>{
<a name="l00265"></a>00265 
<a name="l00266"></a>00266         btVector3 inertiaLocal;
<a name="l00267"></a>00267         <span class="keyword">const</span> btVector3 inertia = m_invInertiaLocal;
<a name="l00268"></a>00268         inertiaLocal.setValue(inertia.x() != btScalar(0.0) ? btScalar(1.0) / inertia.x() : btScalar(0.0),
<a name="l00269"></a>00269                 inertia.y() != btScalar(0.0) ? btScalar(1.0) / inertia.y() : btScalar(0.0),
<a name="l00270"></a>00270                 inertia.z() != btScalar(0.0) ? btScalar(1.0) / inertia.z() : btScalar(0.0));
<a name="l00271"></a>00271         <span class="keywordflow">return</span> inertiaLocal;
<a name="l00272"></a>00272 }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="keyword">inline</span> btVector3 evalEulerEqn(<span class="keyword">const</span> btVector3&amp; w1, <span class="keyword">const</span> btVector3&amp; w0, <span class="keyword">const</span> btVector3&amp; T, <span class="keyword">const</span> btScalar dt,
<a name="l00275"></a>00275         <span class="keyword">const</span> btMatrix3x3 &amp;I)
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277         <span class="keyword">const</span> btVector3 w2 = I*w1 + w1.cross(I*w1)*dt - (T*dt + I*w0);
<a name="l00278"></a>00278         <span class="keywordflow">return</span> w2;
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="keyword">inline</span> btMatrix3x3 evalEulerEqnDeriv(<span class="keyword">const</span> btVector3&amp; w1, <span class="keyword">const</span> btVector3&amp; w0, <span class="keyword">const</span> btScalar dt,
<a name="l00282"></a>00282         <span class="keyword">const</span> btMatrix3x3 &amp;I)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         btMatrix3x3 w1x, Iw1x;
<a name="l00286"></a>00286         <span class="keyword">const</span> btVector3 Iwi = (I*w1);
<a name="l00287"></a>00287         w1.getSkewSymmetricMatrix(&amp;w1x[0], &amp;w1x[1], &amp;w1x[2]);
<a name="l00288"></a>00288         Iwi.getSkewSymmetricMatrix(&amp;Iw1x[0], &amp;Iw1x[1], &amp;Iw1x[2]);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290         <span class="keyword">const</span> btMatrix3x3 dfw1 = I + (w1x*I - Iw1x)*dt;
<a name="l00291"></a>00291         <span class="keywordflow">return</span> dfw1;
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a><a class="code" href="classbt_rigid_body.html#3beda468b8cc2953b8aad44c96426cd5">00294</a> btVector3 <a class="code" href="classbt_rigid_body.html#3beda468b8cc2953b8aad44c96426cd5" title="explicit version is best avoided, it gains energy">btRigidBody::computeGyroscopicForceExplicit</a>(btScalar maxGyroscopicForce)<span class="keyword"> const</span>
<a name="l00295"></a>00295 <span class="keyword"></span>{
<a name="l00296"></a>00296         btVector3 inertiaLocal = getLocalInertia();
<a name="l00297"></a>00297         btMatrix3x3 inertiaTensorWorld = getWorldTransform().getBasis().scaled(inertiaLocal) * getWorldTransform().getBasis().transpose();
<a name="l00298"></a>00298         btVector3 tmp = inertiaTensorWorld*getAngularVelocity();
<a name="l00299"></a>00299         btVector3 gf = getAngularVelocity().cross(tmp);
<a name="l00300"></a>00300         btScalar l2 = gf.length2();
<a name="l00301"></a>00301         <span class="keywordflow">if</span> (l2&gt;maxGyroscopicForce*maxGyroscopicForce)
<a name="l00302"></a>00302         {
<a name="l00303"></a>00303                 gf *= btScalar(1.)/btSqrt(l2)*maxGyroscopicForce;
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305         <span class="keywordflow">return</span> gf;
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00309"></a><a class="code" href="classbt_rigid_body.html#0ec4663c4ac2a614fa03cf93d4d533d6">00309</a> btVector3 <a class="code" href="classbt_rigid_body.html#0ec4663c4ac2a614fa03cf93d4d533d6" title="perform implicit force computation in body space (inertial frame)">btRigidBody::computeGyroscopicImpulseImplicit_Body</a>(btScalar <a class="code" href="group__core__func__common.html#gdb27417a05ff516eda338a7047cea913">step</a>)<span class="keyword"> const</span>
<a name="l00310"></a>00310 <span class="keyword"></span>{       
<a name="l00311"></a>00311         btVector3 idl = getLocalInertia();
<a name="l00312"></a>00312         btVector3 omega1 = getAngularVelocity();
<a name="l00313"></a>00313         <a class="code" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination...">btQuaternion</a> q = getWorldTransform().getRotation();
<a name="l00314"></a>00314         
<a name="l00315"></a>00315         <span class="comment">// Convert to body coordinates</span>
<a name="l00316"></a>00316         btVector3 omegab = quatRotate(q.<a class="code" href="classbt_quaternion.html#a8894800b346577a9a568048d10e09d0" title="Return the inverse of this quaternion.">inverse</a>(), omega1);
<a name="l00317"></a>00317         btMatrix3x3 Ib;
<a name="l00318"></a>00318         Ib.setValue(idl.x(),0,0,
<a name="l00319"></a>00319                                 0,idl.y(),0,
<a name="l00320"></a>00320                                 0,0,idl.z());
<a name="l00321"></a>00321         
<a name="l00322"></a>00322         btVector3 ibo = Ib*omegab;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="comment">// Residual vector</span>
<a name="l00325"></a>00325         btVector3 f = step * omegab.cross(ibo);
<a name="l00326"></a>00326         
<a name="l00327"></a>00327         btMatrix3x3 skew0;
<a name="l00328"></a>00328         omegab.getSkewSymmetricMatrix(&amp;skew0[0], &amp;skew0[1], &amp;skew0[2]);
<a name="l00329"></a>00329         btVector3 om = Ib*omegab;
<a name="l00330"></a>00330         btMatrix3x3 skew1;
<a name="l00331"></a>00331         om.getSkewSymmetricMatrix(&amp;skew1[0],&amp;skew1[1],&amp;skew1[2]);
<a name="l00332"></a>00332         
<a name="l00333"></a>00333         <span class="comment">// Jacobian</span>
<a name="l00334"></a>00334         btMatrix3x3 J = Ib +  (skew0*Ib - skew1)*step;
<a name="l00335"></a>00335         
<a name="l00336"></a>00336 <span class="comment">//      btMatrix3x3 Jinv = J.inverse();</span>
<a name="l00337"></a>00337 <span class="comment">//      btVector3 omega_div = Jinv*f;</span>
<a name="l00338"></a>00338         btVector3 omega_div = J.solve33(f);
<a name="l00339"></a>00339         
<a name="l00340"></a>00340         <span class="comment">// Single Newton-Raphson update</span>
<a name="l00341"></a>00341         omegab = omegab - omega_div;<span class="comment">//Solve33(J, f);</span>
<a name="l00342"></a>00342         <span class="comment">// Back to world coordinates</span>
<a name="l00343"></a>00343         btVector3 omega2 = quatRotate(q,omegab);
<a name="l00344"></a>00344         btVector3 gf = omega2-omega1;
<a name="l00345"></a>00345         <span class="keywordflow">return</span> gf;
<a name="l00346"></a>00346 }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="classbt_rigid_body.html#23d5467c62d5647a6a75eb5f60182786">00350</a> btVector3 <a class="code" href="classbt_rigid_body.html#23d5467c62d5647a6a75eb5f60182786" title="perform implicit force computation in world space">btRigidBody::computeGyroscopicImpulseImplicit_World</a>(btScalar <a class="code" href="group__core__func__common.html#gdb27417a05ff516eda338a7047cea913">step</a>)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword"></span>{
<a name="l00352"></a>00352         <span class="comment">// use full newton-euler equations.  common practice to drop the wxIw term. want it for better tumbling behavior.</span>
<a name="l00353"></a>00353         <span class="comment">// calculate using implicit euler step so it's stable.</span>
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="keyword">const</span> btVector3 inertiaLocal = getLocalInertia();
<a name="l00356"></a>00356         <span class="keyword">const</span> btVector3 w0 = getAngularVelocity();
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         btMatrix3x3 I;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360         I = m_worldTransform.getBasis().scaled(inertiaLocal) *
<a name="l00361"></a>00361                 m_worldTransform.getBasis().transpose();
<a name="l00362"></a>00362 
<a name="l00363"></a>00363         <span class="comment">// use newtons method to find implicit solution for new angular velocity (w')</span>
<a name="l00364"></a>00364         <span class="comment">// f(w') = -(T*step + Iw) + Iw' + w' + w'xIw'*step = 0 </span>
<a name="l00365"></a>00365         <span class="comment">// df/dw' = I + 1xIw'*step + w'xI*step</span>
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         btVector3 w1 = w0;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369         <span class="comment">// one step of newton's method</span>
<a name="l00370"></a>00370         {
<a name="l00371"></a>00371                 <span class="keyword">const</span> btVector3 fw = evalEulerEqn(w1, w0, btVector3(0, 0, 0), step, I);
<a name="l00372"></a>00372                 <span class="keyword">const</span> btMatrix3x3 dfw = evalEulerEqnDeriv(w1, w0, step, I);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374                 btVector3 dw;
<a name="l00375"></a>00375                 dw = dfw.solve33(fw);
<a name="l00376"></a>00376                 <span class="comment">//const btMatrix3x3 dfw_inv = dfw.inverse();</span>
<a name="l00377"></a>00377                 <span class="comment">//dw = dfw_inv*fw;</span>
<a name="l00378"></a>00378 
<a name="l00379"></a>00379                 w1 -= dw;
<a name="l00380"></a>00380         }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382         btVector3 gf = (w1 - w0);
<a name="l00383"></a>00383         <span class="keywordflow">return</span> gf;
<a name="l00384"></a>00384 }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="classbt_rigid_body.html#16029bc5aabcbb33aaf7e6e6e819283a">00387</a> <span class="keywordtype">void</span> <a class="code" href="classbt_rigid_body.html#16029bc5aabcbb33aaf7e6e6e819283a">btRigidBody::integrateVelocities</a>(btScalar <a class="code" href="group__core__func__common.html#gdb27417a05ff516eda338a7047cea913">step</a>) 
<a name="l00388"></a>00388 {
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (isStaticOrKinematicObject())
<a name="l00390"></a>00390                 <span class="keywordflow">return</span>;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         m_linearVelocity += m_totalForce * (m_inverseMass * step);
<a name="l00393"></a>00393         m_angularVelocity += m_invInertiaTensorWorld * m_totalTorque * step;
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 <span class="preprocessor">#define MAX_ANGVEL SIMD_HALF_PI</span>
<a name="l00397"></a>00397 <span class="preprocessor">        btScalar angvel = m_angularVelocity.length();</span>
<a name="l00398"></a>00398 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (angvel*step &gt; MAX_ANGVEL)
<a name="l00399"></a>00399         {
<a name="l00400"></a>00400                 m_angularVelocity *= (MAX_ANGVEL/step) /angvel;
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <a class="code" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination...">btQuaternion</a> btRigidBody::getOrientation()<span class="keyword"> const</span>
<a name="l00406"></a>00406 <span class="keyword"></span>{
<a name="l00407"></a>00407                 <a class="code" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination...">btQuaternion</a> orn;
<a name="l00408"></a>00408                 m_worldTransform.getBasis().getRotation(orn);
<a name="l00409"></a>00409                 <span class="keywordflow">return</span> orn;
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411         
<a name="l00412"></a>00412         
<a name="l00413"></a>00413 <span class="keywordtype">void</span> btRigidBody::setCenterOfMassTransform(<span class="keyword">const</span> btTransform&amp; xform)
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keywordflow">if</span> (isKinematicObject())
<a name="l00417"></a>00417         {
<a name="l00418"></a>00418                 m_interpolationWorldTransform = m_worldTransform;
<a name="l00419"></a>00419         } <span class="keywordflow">else</span>
<a name="l00420"></a>00420         {
<a name="l00421"></a>00421                 m_interpolationWorldTransform = xform;
<a name="l00422"></a>00422         }
<a name="l00423"></a>00423         m_interpolationLinearVelocity = getLinearVelocity();
<a name="l00424"></a>00424         m_interpolationAngularVelocity = getAngularVelocity();
<a name="l00425"></a>00425         m_worldTransform = xform;
<a name="l00426"></a>00426         updateInertiaTensor();
<a name="l00427"></a>00427 }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 
<a name="l00433"></a><a class="code" href="classbt_rigid_body.html#1c89df31d2a10f06cc81da0e4b573297">00433</a> <span class="keywordtype">void</span> <a class="code" href="classbt_rigid_body.html#1c89df31d2a10f06cc81da0e4b573297">btRigidBody::addConstraintRef</a>(btTypedConstraint* c)
<a name="l00434"></a>00434 {
<a name="l00436"></a>00436 
<a name="l00437"></a>00437         <span class="keywordtype">int</span> index = m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8">findLinearSearch</a>(c);
<a name="l00438"></a>00438         <span class="comment">//don't add constraints that are already referenced</span>
<a name="l00439"></a>00439         <span class="comment">//btAssert(index == m_constraintRefs.size());</span>
<a name="l00440"></a>00440         <span class="keywordflow">if</span> (index == m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l00441"></a>00441         {
<a name="l00442"></a>00442                 m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(c);
<a name="l00443"></a>00443                 btCollisionObject* colObjA = &amp;c-&gt;getRigidBodyA();
<a name="l00444"></a>00444                 btCollisionObject* colObjB = &amp;c-&gt;getRigidBodyB();
<a name="l00445"></a>00445                 <span class="keywordflow">if</span> (colObjA == <span class="keyword">this</span>)
<a name="l00446"></a>00446                 {
<a name="l00447"></a>00447                         colObjA-&gt;setIgnoreCollisionCheck(colObjB, <span class="keyword">true</span>);
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449                 <span class="keywordflow">else</span>
<a name="l00450"></a>00450                 {
<a name="l00451"></a>00451                         colObjB-&gt;setIgnoreCollisionCheck(colObjA, <span class="keyword">true</span>);
<a name="l00452"></a>00452                 }
<a name="l00453"></a>00453         } 
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="keywordtype">void</span> btRigidBody::removeConstraintRef(btTypedConstraint* c)
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458         <span class="keywordtype">int</span> index = m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8">findLinearSearch</a>(c);
<a name="l00459"></a>00459         <span class="comment">//don't remove constraints that are not referenced</span>
<a name="l00460"></a>00460         <span class="keywordflow">if</span>(index &lt; m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l00461"></a>00461     {
<a name="l00462"></a>00462         m_constraintRefs.<a class="code" href="classbt_aligned_object_array.html#6782242f06df5bab0cffbd23195cd9cd">remove</a>(c);
<a name="l00463"></a>00463         btCollisionObject* colObjA = &amp;c-&gt;getRigidBodyA();
<a name="l00464"></a>00464         btCollisionObject* colObjB = &amp;c-&gt;getRigidBodyB();
<a name="l00465"></a>00465         <span class="keywordflow">if</span> (colObjA == <span class="keyword">this</span>)
<a name="l00466"></a>00466         {
<a name="l00467"></a>00467             colObjA-&gt;setIgnoreCollisionCheck(colObjB, <span class="keyword">false</span>);
<a name="l00468"></a>00468         }
<a name="l00469"></a>00469         <span class="keywordflow">else</span>
<a name="l00470"></a>00470         {
<a name="l00471"></a>00471             colObjB-&gt;setIgnoreCollisionCheck(colObjA, <span class="keyword">false</span>);
<a name="l00472"></a>00472         }
<a name="l00473"></a>00473     }
<a name="l00474"></a>00474 }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="keywordtype">int</span>     btRigidBody::calculateSerializeBufferSize()<span class="keyword">     const</span>
<a name="l00477"></a>00477 <span class="keyword"></span>{
<a name="l00478"></a>00478         <span class="keywordtype">int</span> sz = <span class="keyword">sizeof</span>(btRigidBodyData);
<a name="l00479"></a>00479         <span class="keywordflow">return</span> sz;
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00483"></a><a class="code" href="classbt_rigid_body.html#9b1b5b688a59958aabcdf1fbc359182d">00483</a> <span class="keyword">const</span> <span class="keywordtype">char</span>*     <a class="code" href="classbt_rigid_body.html#9b1b5b688a59958aabcdf1fbc359182d" title="fills the dataBuffer and returns the struct name (and 0 on failure)">btRigidBody::serialize</a>(<span class="keywordtype">void</span>* dataBuffer, <span class="keyword">class</span> btSerializer* serializer)<span class="keyword"> const</span>
<a name="l00484"></a>00484 <span class="keyword"></span>{
<a name="l00485"></a>00485         btRigidBodyData* rbd = (btRigidBodyData*) dataBuffer;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         btCollisionObject::serialize(&amp;rbd-&gt;m_collisionObjectData, serializer);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489         m_invInertiaTensorWorld.serialize(rbd-&gt;m_invInertiaTensorWorld);
<a name="l00490"></a>00490         m_linearVelocity.serialize(rbd-&gt;m_linearVelocity);
<a name="l00491"></a>00491         m_angularVelocity.serialize(rbd-&gt;m_angularVelocity);
<a name="l00492"></a>00492         rbd-&gt;m_inverseMass = m_inverseMass;
<a name="l00493"></a>00493         m_angularFactor.serialize(rbd-&gt;m_angularFactor);
<a name="l00494"></a>00494         m_linearFactor.serialize(rbd-&gt;m_linearFactor);
<a name="l00495"></a>00495         m_gravity.serialize(rbd-&gt;m_gravity);
<a name="l00496"></a>00496         m_gravity_acceleration.serialize(rbd-&gt;m_gravity_acceleration);
<a name="l00497"></a>00497         m_invInertiaLocal.serialize(rbd-&gt;m_invInertiaLocal);
<a name="l00498"></a>00498         m_totalForce.serialize(rbd-&gt;m_totalForce);
<a name="l00499"></a>00499         m_totalTorque.serialize(rbd-&gt;m_totalTorque);
<a name="l00500"></a>00500         rbd-&gt;m_linearDamping = m_linearDamping;
<a name="l00501"></a>00501         rbd-&gt;m_angularDamping = m_angularDamping;
<a name="l00502"></a>00502         rbd-&gt;m_additionalDamping = m_additionalDamping;
<a name="l00503"></a>00503         rbd-&gt;m_additionalDampingFactor = m_additionalDampingFactor;
<a name="l00504"></a>00504         rbd-&gt;m_additionalLinearDampingThresholdSqr = m_additionalLinearDampingThresholdSqr;
<a name="l00505"></a>00505         rbd-&gt;m_additionalAngularDampingThresholdSqr = m_additionalAngularDampingThresholdSqr;
<a name="l00506"></a>00506         rbd-&gt;m_additionalAngularDampingFactor = m_additionalAngularDampingFactor;
<a name="l00507"></a>00507         rbd-&gt;m_linearSleepingThreshold=m_linearSleepingThreshold;
<a name="l00508"></a>00508         rbd-&gt;m_angularSleepingThreshold = m_angularSleepingThreshold;
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         <span class="comment">// Fill padding with zeros to appease msan.</span>
<a name="l00511"></a>00511 <span class="preprocessor">#ifdef BT_USE_DOUBLE_PRECISION</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>        memset(rbd-&gt;m_padding, 0, <span class="keyword">sizeof</span>(rbd-&gt;m_padding));
<a name="l00513"></a>00513 <span class="preprocessor">#endif</span>
<a name="l00514"></a>00514 <span class="preprocessor"></span>
<a name="l00515"></a>00515         <span class="keywordflow">return</span> btRigidBodyDataName;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keywordtype">void</span> btRigidBody::serializeSingleObject(<span class="keyword">class</span> btSerializer* serializer)<span class="keyword"> const</span>
<a name="l00521"></a>00521 <span class="keyword"></span>{
<a name="l00522"></a>00522         btChunk* chunk = serializer-&gt;allocate(calculateSerializeBufferSize(),1);
<a name="l00523"></a>00523         <span class="keyword">const</span> <span class="keywordtype">char</span>* structType = <a class="code" href="classbt_rigid_body.html#9b1b5b688a59958aabcdf1fbc359182d" title="fills the dataBuffer and returns the struct name (and 0 on failure)">serialize</a>(chunk-&gt;m_oldPtr, serializer);
<a name="l00524"></a>00524         serializer-&gt;finalizeChunk(chunk,structType,BT_RIGIDBODY_CODE,(<span class="keywordtype">void</span>*)<span class="keyword">this</span>);
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 12:56:48 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
