<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/SOIL2/include/stb_image_write.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/SOIL2/include/stb_image_write.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* stb_image_write - v1.05 - public domain - http://nothings.org/stb/stb_image_write.h</span>
<a name="l00002"></a>00002 <span class="comment">   writes out PNG/BMP/TGA images to C stdio - Sean Barrett 2010-2015</span>
<a name="l00003"></a>00003 <span class="comment">                                     no warranty implied; use at your own risk</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">   Before #including,</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">       #define STB_IMAGE_WRITE_IMPLEMENTATION</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">   in the file that you want to have the implementation.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">   Will probably not work correctly with strict-aliasing optimizations.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">ABOUT:</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   This header file is a library for writing images to C stdio. It could be</span>
<a name="l00016"></a>00016 <span class="comment">   adapted to write to memory or a general streaming interface; let me know.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   The PNG output is not optimal; it is 20-50% larger than the file</span>
<a name="l00019"></a>00019 <span class="comment">   written by a decent optimizing implementation. This library is designed</span>
<a name="l00020"></a>00020 <span class="comment">   for source code compactness and simplicity, not optimal image file size</span>
<a name="l00021"></a>00021 <span class="comment">   or run-time performance.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">BUILDING:</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.</span>
<a name="l00026"></a>00026 <span class="comment">   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace</span>
<a name="l00027"></a>00027 <span class="comment">   malloc,realloc,free.</span>
<a name="l00028"></a>00028 <span class="comment">   You can define STBIW_MEMMOVE() to replace memmove()</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">USAGE:</span>
<a name="l00031"></a>00031 <span class="comment"></span>
<a name="l00032"></a>00032 <span class="comment">   There are four functions, one for each image file format:</span>
<a name="l00033"></a>00033 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);</span>
<a name="l00035"></a>00035 <span class="comment">     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);</span>
<a name="l00036"></a>00036 <span class="comment">     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);</span>
<a name="l00037"></a>00037 <span class="comment">     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);</span>
<a name="l00038"></a>00038 <span class="comment"></span>
<a name="l00039"></a>00039 <span class="comment">   There are also four equivalent functions that use an arbitrary write function. You are</span>
<a name="l00040"></a>00040 <span class="comment">   expected to open/close your file-equivalent before and after calling these:</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);</span>
<a name="l00043"></a>00043 <span class="comment">     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);</span>
<a name="l00044"></a>00044 <span class="comment">     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);</span>
<a name="l00045"></a>00045 <span class="comment">     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">   where the callback is:</span>
<a name="l00048"></a>00048 <span class="comment">      void stbi_write_func(void *context, void *data, int size);</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">   You can define STBI_WRITE_NO_STDIO to disable the file variant of these</span>
<a name="l00051"></a>00051 <span class="comment">   functions, so the library will not use stdio.h at all. However, this will</span>
<a name="l00052"></a>00052 <span class="comment">   also disable HDR writing, because it requires stdio for formatted output.</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">   Each function returns 0 on failure and non-0 on success.</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">   The functions create an image file defined by the parameters. The image</span>
<a name="l00057"></a>00057 <span class="comment">   is a rectangle of pixels stored from left-to-right, top-to-bottom.</span>
<a name="l00058"></a>00058 <span class="comment">   Each pixel contains 'comp' channels of data stored interleaved with 8-bits</span>
<a name="l00059"></a>00059 <span class="comment">   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is</span>
<a name="l00060"></a>00060 <span class="comment">   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.</span>
<a name="l00061"></a>00061 <span class="comment">   The *data pointer points to the first byte of the top-left-most pixel.</span>
<a name="l00062"></a>00062 <span class="comment">   For PNG, "stride_in_bytes" is the distance in bytes from the first byte of</span>
<a name="l00063"></a>00063 <span class="comment">   a row of pixels to the first byte of the next row of pixels.</span>
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">   PNG creates output files with the same number of components as the input.</span>
<a name="l00066"></a>00066 <span class="comment">   The BMP format expands Y to RGB in the file format and does not</span>
<a name="l00067"></a>00067 <span class="comment">   output alpha.</span>
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">   PNG supports writing rectangles of data even when the bytes storing rows of</span>
<a name="l00070"></a>00070 <span class="comment">   data are not consecutive in memory (e.g. sub-rectangles of a larger image),</span>
<a name="l00071"></a>00071 <span class="comment">   by supplying the stride between the beginning of adjacent rows. The other</span>
<a name="l00072"></a>00072 <span class="comment">   formats do not. (Thus you cannot write a native-format BMP through the BMP</span>
<a name="l00073"></a>00073 <span class="comment">   writer, both because it is in BGR order and because it may have padding</span>
<a name="l00074"></a>00074 <span class="comment">   at the end of the line.)</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">   HDR expects linear float data. Since the format is always 32-bit rgb(e)</span>
<a name="l00077"></a>00077 <span class="comment">   data, alpha (if provided) is discarded, and for monochrome data it is</span>
<a name="l00078"></a>00078 <span class="comment">   replicated across all three channels.</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a>00080 <span class="comment">   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed</span>
<a name="l00081"></a>00081 <span class="comment">   data, set the global variable 'stbi_write_tga_with_rle' to 0.</span>
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">CREDITS:</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">   PNG/BMP/TGA</span>
<a name="l00086"></a>00086 <span class="comment">      Sean Barrett</span>
<a name="l00087"></a>00087 <span class="comment">   HDR</span>
<a name="l00088"></a>00088 <span class="comment">      Baldur Karlsson</span>
<a name="l00089"></a>00089 <span class="comment">   TGA monochrome:</span>
<a name="l00090"></a>00090 <span class="comment">      Jean-Sebastien Guay</span>
<a name="l00091"></a>00091 <span class="comment">   misc enhancements:</span>
<a name="l00092"></a>00092 <span class="comment">      Tim Kelsey</span>
<a name="l00093"></a>00093 <span class="comment">   TGA RLE</span>
<a name="l00094"></a>00094 <span class="comment">      Alan Hickman</span>
<a name="l00095"></a>00095 <span class="comment">   initial file IO callback implementation</span>
<a name="l00096"></a>00096 <span class="comment">      Emmanuel Julien</span>
<a name="l00097"></a>00097 <span class="comment">   bugfixes:</span>
<a name="l00098"></a>00098 <span class="comment">      github:Chribba</span>
<a name="l00099"></a>00099 <span class="comment">      Guillaume Chereau</span>
<a name="l00100"></a>00100 <span class="comment">      github:jry2</span>
<a name="l00101"></a>00101 <span class="comment">      github:romigrou</span>
<a name="l00102"></a>00102 <span class="comment">      Sergio Gonzalez</span>
<a name="l00103"></a>00103 <span class="comment">      Jonas Karlsson</span>
<a name="l00104"></a>00104 <span class="comment">      Filip Wasil</span>
<a name="l00105"></a>00105 <span class="comment">      Thatcher Ulrich</span>
<a name="l00106"></a>00106 <span class="comment">      github:poppolopoppo</span>
<a name="l00107"></a>00107 <span class="comment">      Patrick Boettcher</span>
<a name="l00108"></a>00108 <span class="comment">      </span>
<a name="l00109"></a>00109 <span class="comment">LICENSE</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">  See end of file for license information.</span>
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">*/</span>
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 <span class="preprocessor">#ifndef INCLUDE_STB_IMAGE_WRITE_H</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor">#define INCLUDE_STB_IMAGE_WRITE_H</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>
<a name="l00118"></a>00118 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00120"></a>00120 <span class="preprocessor">#endif</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span>
<a name="l00122"></a>00122 <span class="preprocessor">#ifdef STB_IMAGE_WRITE_STATIC</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define STBIWDEF static</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#define STBIWDEF extern</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> stbi_write_tga_with_rle;
<a name="l00127"></a>00127 <span class="preprocessor">#endif</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>
<a name="l00129"></a>00129 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>STBIWDEF <span class="keywordtype">int</span> stbi_write_png(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data, <span class="keywordtype">int</span> stride_in_bytes);
<a name="l00131"></a>00131 STBIWDEF <span class="keywordtype">int</span> stbi_write_bmp(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data);
<a name="l00132"></a>00132 STBIWDEF <span class="keywordtype">int</span> stbi_write_tga(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data);
<a name="l00133"></a>00133 STBIWDEF <span class="keywordtype">int</span> stbi_write_hdr(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">float</span> *data);
<a name="l00134"></a>00134 <span class="preprocessor">#endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="keyword">typedef</span> <span class="keywordtype">void</span> stbi_write_func(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> size);
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 STBIWDEF <span class="keywordtype">int</span> stbi_write_png_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data, <span class="keywordtype">int</span> stride_in_bytes);
<a name="l00139"></a>00139 STBIWDEF <span class="keywordtype">int</span> stbi_write_bmp_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data);
<a name="l00140"></a>00140 STBIWDEF <span class="keywordtype">int</span> stbi_write_tga_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span>  *data);
<a name="l00141"></a>00141 STBIWDEF <span class="keywordtype">int</span> stbi_write_hdr_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">float</span> *data);
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>}
<a name="l00145"></a>00145 <span class="preprocessor">#endif</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span>
<a name="l00147"></a>00147 <span class="preprocessor">#endif//INCLUDE_STB_IMAGE_WRITE_H</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span>
<a name="l00149"></a>00149 <span class="preprocessor">#ifdef STB_IMAGE_WRITE_IMPLEMENTATION</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor">   #ifndef _CRT_SECURE_NO_WARNINGS</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">   #define _CRT_SECURE_NO_WARNINGS</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">   #ifndef _CRT_NONSTDC_NO_DEPRECATE</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor">   #define _CRT_NONSTDC_NO_DEPRECATE</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span><span class="preprocessor">   #endif</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00162"></a>00162 <span class="preprocessor">#endif // STBI_WRITE_NO_STDIO</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span>
<a name="l00164"></a>00164 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00165"></a>00165 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00166"></a>00166 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00167"></a>00167 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="preprocessor">#if defined(STBIW_MALLOC) &amp;&amp; defined(STBIW_FREE) &amp;&amp; (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="comment">// ok</span>
<a name="l00171"></a>00171 <span class="preprocessor">#elif !defined(STBIW_MALLOC) &amp;&amp; !defined(STBIW_FREE) &amp;&amp; !defined(STBIW_REALLOC) &amp;&amp; !defined(STBIW_REALLOC_SIZED)</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span><span class="comment">// ok</span>
<a name="l00173"></a>00173 <span class="preprocessor">#else</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span><span class="preprocessor">#error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED)."</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>
<a name="l00177"></a>00177 <span class="preprocessor">#ifndef STBIW_MALLOC</span>
<a name="l00178"></a>00178 <span class="preprocessor"></span><span class="preprocessor">#define STBIW_MALLOC(sz)        malloc(sz)</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define STBIW_FREE(p)           free(p)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>
<a name="l00183"></a>00183 <span class="preprocessor">#ifndef STBIW_REALLOC_SIZED</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span><span class="preprocessor">#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="preprocessor">#ifndef STBIW_MEMMOVE</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="preprocessor">#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00191"></a>00191 <span class="preprocessor"></span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#ifndef STBIW_ASSERT</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00195"></a>00195 <span class="preprocessor">#define STBIW_ASSERT(x) assert(x)</span>
<a name="l00196"></a>00196 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>
<a name="l00198"></a>00198 <span class="preprocessor">#define STBIW_UCHAR(x) (unsigned char) ((x) &amp; 0xff)</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span>
<a name="l00200"></a>00200 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202    stbi_write_func *func;
<a name="l00203"></a>00203    <span class="keywordtype">void</span> *context;
<a name="l00204"></a>00204 } stbi__write_context;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 <span class="comment">// initialize a callback-based context</span>
<a name="l00207"></a>00207 <span class="keyword">static</span> <span class="keywordtype">void</span> stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, <span class="keywordtype">void</span> *context)
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209    s-&gt;func    = c;
<a name="l00210"></a>00210    s-&gt;context = context;
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>
<a name="l00215"></a>00215 <span class="keyword">static</span> <span class="keywordtype">void</span> stbi__stdio_write(<span class="keywordtype">void</span> *context, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> size)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217    fwrite(data,1,size,(FILE*) context);
<a name="l00218"></a>00218 }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="keyword">static</span> <span class="keywordtype">int</span> stbi__start_write_file(stbi__write_context *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222    FILE *f = fopen(filename, <span class="stringliteral">"wb"</span>);
<a name="l00223"></a>00223    stbi__start_write_callbacks(s, stbi__stdio_write, (<span class="keywordtype">void</span> *) f);
<a name="l00224"></a>00224    <span class="keywordflow">return</span> f != NULL;
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 <span class="keyword">static</span> <span class="keywordtype">void</span> stbi__end_write_file(stbi__write_context *s)
<a name="l00228"></a>00228 {
<a name="l00229"></a>00229    fclose((FILE *)s-&gt;context);
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="preprocessor">#endif // !STBI_WRITE_NO_STDIO</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span>
<a name="l00234"></a>00234 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stbiw_uint32;
<a name="l00235"></a>00235 <span class="keyword">typedef</span> <span class="keywordtype">int</span> stb_image_write_test[<span class="keyword">sizeof</span>(stbiw_uint32)==4 ? 1 : -1];
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="preprocessor">#ifdef STB_IMAGE_WRITE_STATIC</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> stbi_write_tga_with_rle = 1;
<a name="l00239"></a>00239 <span class="preprocessor">#else</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span><span class="keywordtype">int</span> stbi_write_tga_with_rle = 1;
<a name="l00241"></a>00241 <span class="preprocessor">#endif</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__writefv(stbi__write_context *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list v)
<a name="l00244"></a>00244 {
<a name="l00245"></a>00245    <span class="keywordflow">while</span> (*fmt) {
<a name="l00246"></a>00246       <span class="keywordflow">switch</span> (*fmt++) {
<a name="l00247"></a>00247          <span class="keywordflow">case</span> <span class="charliteral">' '</span>: <span class="keywordflow">break</span>;
<a name="l00248"></a>00248          <span class="keywordflow">case</span> <span class="charliteral">'1'</span>: { <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> x = STBIW_UCHAR(va_arg(v, <span class="keywordtype">int</span>));
<a name="l00249"></a>00249                      s-&gt;func(s-&gt;context,&amp;x,1);
<a name="l00250"></a>00250                      <span class="keywordflow">break</span>; }
<a name="l00251"></a>00251          <span class="keywordflow">case</span> <span class="charliteral">'2'</span>: { <span class="keywordtype">int</span> x = va_arg(v,<span class="keywordtype">int</span>);
<a name="l00252"></a>00252                      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b[2];
<a name="l00253"></a>00253                      b[0] = STBIW_UCHAR(x);
<a name="l00254"></a>00254                      b[1] = STBIW_UCHAR(x&gt;&gt;8);
<a name="l00255"></a>00255                      s-&gt;func(s-&gt;context,b,2);
<a name="l00256"></a>00256                      <span class="keywordflow">break</span>; }
<a name="l00257"></a>00257          <span class="keywordflow">case</span> <span class="charliteral">'4'</span>: { stbiw_uint32 x = va_arg(v,<span class="keywordtype">int</span>);
<a name="l00258"></a>00258                      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b[4];
<a name="l00259"></a>00259                      b[0]=STBIW_UCHAR(x);
<a name="l00260"></a>00260                      b[1]=STBIW_UCHAR(x&gt;&gt;8);
<a name="l00261"></a>00261                      b[2]=STBIW_UCHAR(x&gt;&gt;16);
<a name="l00262"></a>00262                      b[3]=STBIW_UCHAR(x&gt;&gt;24);
<a name="l00263"></a>00263                      s-&gt;func(s-&gt;context,b,4);
<a name="l00264"></a>00264                      <span class="keywordflow">break</span>; }
<a name="l00265"></a>00265          <span class="keywordflow">default</span>:
<a name="l00266"></a>00266             STBIW_ASSERT(0);
<a name="l00267"></a>00267             <span class="keywordflow">return</span>;
<a name="l00268"></a>00268       }
<a name="l00269"></a>00269    }
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__writef(stbi__write_context *s, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274    va_list v;
<a name="l00275"></a>00275    va_start(v, fmt);
<a name="l00276"></a>00276    stbiw__writefv(s, fmt, v);
<a name="l00277"></a>00277    va_end(v);
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__write3(stbi__write_context *s, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> a, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> arr[3];
<a name="l00283"></a>00283    arr[0] = a, arr[1] = b, arr[2] = c;
<a name="l00284"></a>00284    s-&gt;func(s-&gt;context, arr, 3);
<a name="l00285"></a>00285 }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__write_pixel(stbi__write_context *s, <span class="keywordtype">int</span> rgb_dir, <span class="keywordtype">int</span> comp, <span class="keywordtype">int</span> write_alpha, <span class="keywordtype">int</span> expand_mono, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d)
<a name="l00288"></a>00288 {
<a name="l00289"></a>00289    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bg[3] = { 255, 0, 255}, px[3];
<a name="l00290"></a>00290    <span class="keywordtype">int</span> k;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292    <span class="keywordflow">if</span> (write_alpha &lt; 0)
<a name="l00293"></a>00293       s-&gt;func(s-&gt;context, &amp;d[comp - 1], 1);
<a name="l00294"></a>00294 
<a name="l00295"></a>00295    <span class="keywordflow">switch</span> (comp) {
<a name="l00296"></a>00296       <span class="keywordflow">case</span> 2: <span class="comment">// 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case</span>
<a name="l00297"></a>00297       <span class="keywordflow">case</span> 1:
<a name="l00298"></a>00298          <span class="keywordflow">if</span> (expand_mono)
<a name="l00299"></a>00299             stbiw__write3(s, d[0], d[0], d[0]); <span class="comment">// monochrome bmp</span>
<a name="l00300"></a>00300          <span class="keywordflow">else</span>
<a name="l00301"></a>00301             s-&gt;func(s-&gt;context, d, 1);  <span class="comment">// monochrome TGA</span>
<a name="l00302"></a>00302          <span class="keywordflow">break</span>;
<a name="l00303"></a>00303       <span class="keywordflow">case</span> 4:
<a name="l00304"></a>00304          <span class="keywordflow">if</span> (!write_alpha) {
<a name="l00305"></a>00305             <span class="comment">// composite against pink background</span>
<a name="l00306"></a>00306             <span class="keywordflow">for</span> (k = 0; k &lt; 3; ++k)
<a name="l00307"></a>00307                px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;
<a name="l00308"></a>00308             stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);
<a name="l00309"></a>00309             <span class="keywordflow">break</span>;
<a name="l00310"></a>00310          }
<a name="l00311"></a>00311          <span class="comment">/* FALLTHROUGH */</span>
<a name="l00312"></a>00312       <span class="keywordflow">case</span> 3:
<a name="l00313"></a>00313          stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);
<a name="l00314"></a>00314          <span class="keywordflow">break</span>;
<a name="l00315"></a>00315    }
<a name="l00316"></a>00316    <span class="keywordflow">if</span> (write_alpha &gt; 0)
<a name="l00317"></a>00317       s-&gt;func(s-&gt;context, &amp;d[comp - 1], 1);
<a name="l00318"></a>00318 }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__write_pixels(stbi__write_context *s, <span class="keywordtype">int</span> rgb_dir, <span class="keywordtype">int</span> vdir, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> write_alpha, <span class="keywordtype">int</span> scanline_pad, <span class="keywordtype">int</span> expand_mono)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322    stbiw_uint32 <a class="code" href="group__gtc__constants.html#g888d199297a924864bc2235f5133c30f">zero</a> = 0;
<a name="l00323"></a>00323    <span class="keywordtype">int</span> i,j, j_end;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325    <span class="keywordflow">if</span> (y &lt;= 0)
<a name="l00326"></a>00326       <span class="keywordflow">return</span>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328    <span class="keywordflow">if</span> (vdir &lt; 0)
<a name="l00329"></a>00329       j_end = -1, j = y-1;
<a name="l00330"></a>00330    <span class="keywordflow">else</span>
<a name="l00331"></a>00331       j_end =  y, j = 0;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333    <span class="keywordflow">for</span> (; j != j_end; j += vdir) {
<a name="l00334"></a>00334       <span class="keywordflow">for</span> (i=0; i &lt; x; ++i) {
<a name="l00335"></a>00335          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *d = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) data + (j*x+i)*comp;
<a name="l00336"></a>00336          stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);
<a name="l00337"></a>00337       }
<a name="l00338"></a>00338       s-&gt;func(s-&gt;context, &amp;zero, scanline_pad);
<a name="l00339"></a>00339    }
<a name="l00340"></a>00340 }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="keyword">static</span> <span class="keywordtype">int</span> stbiw__outfile(stbi__write_context *s, <span class="keywordtype">int</span> rgb_dir, <span class="keywordtype">int</span> vdir, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keywordtype">int</span> expand_mono, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> alpha, <span class="keywordtype">int</span> pad, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344    <span class="keywordflow">if</span> (y &lt; 0 || x &lt; 0) {
<a name="l00345"></a>00345       <span class="keywordflow">return</span> 0;
<a name="l00346"></a>00346    } <span class="keywordflow">else</span> {
<a name="l00347"></a>00347       va_list v;
<a name="l00348"></a>00348       va_start(v, fmt);
<a name="l00349"></a>00349       stbiw__writefv(s, fmt, v);
<a name="l00350"></a>00350       va_end(v);
<a name="l00351"></a>00351       stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);
<a name="l00352"></a>00352       <span class="keywordflow">return</span> 1;
<a name="l00353"></a>00353    }
<a name="l00354"></a>00354 }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="keyword">static</span> <span class="keywordtype">int</span> stbi_write_bmp_core(stbi__write_context *s, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00357"></a>00357 {
<a name="l00358"></a>00358    <span class="keywordtype">int</span> pad = (-x*3) &amp; 3;
<a name="l00359"></a>00359    <span class="keywordflow">return</span> stbiw__outfile(s,-1,-1,x,y,comp,1,(<span class="keywordtype">void</span> *) data,0,pad,
<a name="l00360"></a>00360            <span class="stringliteral">"11 4 22 4"</span> <span class="stringliteral">"4 44 22 444444"</span>,
<a name="l00361"></a>00361            <span class="charliteral">'B'</span>, <span class="charliteral">'M'</span>, 14+40+(x*3+pad)*y, 0,0, 14+40,  <span class="comment">// file header</span>
<a name="l00362"></a>00362             40, x,y, 1,24, 0,0,0,0,0,0);             <span class="comment">// bitmap header</span>
<a name="l00363"></a>00363 }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 STBIWDEF <span class="keywordtype">int</span> stbi_write_bmp_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00366"></a>00366 {
<a name="l00367"></a>00367    stbi__write_context s;
<a name="l00368"></a>00368    stbi__start_write_callbacks(&amp;s, func, context);
<a name="l00369"></a>00369    <span class="keywordflow">return</span> stbi_write_bmp_core(&amp;s, x, y, comp, data);
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>STBIWDEF <span class="keywordtype">int</span> stbi_write_bmp(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375    stbi__write_context s;
<a name="l00376"></a>00376    <span class="keywordflow">if</span> (stbi__start_write_file(&amp;s,filename)) {
<a name="l00377"></a>00377       <span class="keywordtype">int</span> r = stbi_write_bmp_core(&amp;s, x, y, comp, data);
<a name="l00378"></a>00378       stbi__end_write_file(&amp;s);
<a name="l00379"></a>00379       <span class="keywordflow">return</span> r;
<a name="l00380"></a>00380    } <span class="keywordflow">else</span>
<a name="l00381"></a>00381       <span class="keywordflow">return</span> 0;
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 <span class="preprocessor">#endif </span>
<a name="l00384"></a>00384 <span class="preprocessor"></span>
<a name="l00385"></a>00385 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> stbi_write_tga_core(stbi__write_context *s, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keywordtype">void</span> *data)
<a name="l00386"></a>00386 {
<a name="l00387"></a>00387    <span class="keywordtype">int</span> has_alpha = (comp == 2 || comp == 4);
<a name="l00388"></a>00388    <span class="keywordtype">int</span> colorbytes = has_alpha ? comp-1 : comp;
<a name="l00389"></a>00389    <span class="keywordtype">int</span> format = colorbytes &lt; 2 ? 3 : 2; <span class="comment">// 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3</span>
<a name="l00390"></a>00390 
<a name="l00391"></a>00391    <span class="keywordflow">if</span> (y &lt; 0 || x &lt; 0)
<a name="l00392"></a>00392       <span class="keywordflow">return</span> 0;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394    <span class="keywordflow">if</span> (!stbi_write_tga_with_rle) {
<a name="l00395"></a>00395       <span class="keywordflow">return</span> stbiw__outfile(s, -1, -1, x, y, comp, 0, (<span class="keywordtype">void</span> *) data, has_alpha, 0,
<a name="l00396"></a>00396          <span class="stringliteral">"111 221 2222 11"</span>, 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);
<a name="l00397"></a>00397    } <span class="keywordflow">else</span> {
<a name="l00398"></a>00398       <span class="keywordtype">int</span> i,j,k;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400       stbiw__writef(s, <span class="stringliteral">"111 221 2222 11"</span>, 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402       <span class="keywordflow">for</span> (j = y - 1; j &gt;= 0; --j) {
<a name="l00403"></a>00403           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) data + j * x * comp;
<a name="l00404"></a>00404          <span class="keywordtype">int</span> len;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406          <span class="keywordflow">for</span> (i = 0; i &lt; x; i += len) {
<a name="l00407"></a>00407             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *begin = row + i * comp;
<a name="l00408"></a>00408             <span class="keywordtype">int</span> diff = 1;
<a name="l00409"></a>00409             len = 1;
<a name="l00410"></a>00410 
<a name="l00411"></a>00411             <span class="keywordflow">if</span> (i &lt; x - 1) {
<a name="l00412"></a>00412                ++len;
<a name="l00413"></a>00413                diff = memcmp(begin, row + (i + 1) * comp, comp);
<a name="l00414"></a>00414                <span class="keywordflow">if</span> (diff) {
<a name="l00415"></a>00415                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *prev = begin;
<a name="l00416"></a>00416                   <span class="keywordflow">for</span> (k = i + 2; k &lt; x &amp;&amp; len &lt; 128; ++k) {
<a name="l00417"></a>00417                      <span class="keywordflow">if</span> (memcmp(prev, row + k * comp, comp)) {
<a name="l00418"></a>00418                         prev += comp;
<a name="l00419"></a>00419                         ++len;
<a name="l00420"></a>00420                      } <span class="keywordflow">else</span> {
<a name="l00421"></a>00421                         --len;
<a name="l00422"></a>00422                         <span class="keywordflow">break</span>;
<a name="l00423"></a>00423                      }
<a name="l00424"></a>00424                   }
<a name="l00425"></a>00425                } <span class="keywordflow">else</span> {
<a name="l00426"></a>00426                   <span class="keywordflow">for</span> (k = i + 2; k &lt; x &amp;&amp; len &lt; 128; ++k) {
<a name="l00427"></a>00427                      <span class="keywordflow">if</span> (!memcmp(begin, row + k * comp, comp)) {
<a name="l00428"></a>00428                         ++len;
<a name="l00429"></a>00429                      } <span class="keywordflow">else</span> {
<a name="l00430"></a>00430                         <span class="keywordflow">break</span>;
<a name="l00431"></a>00431                      }
<a name="l00432"></a>00432                   }
<a name="l00433"></a>00433                }
<a name="l00434"></a>00434             }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436             <span class="keywordflow">if</span> (diff) {
<a name="l00437"></a>00437                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> header = STBIW_UCHAR(len - 1);
<a name="l00438"></a>00438                s-&gt;func(s-&gt;context, &amp;header, 1);
<a name="l00439"></a>00439                <span class="keywordflow">for</span> (k = 0; k &lt; len; ++k) {
<a name="l00440"></a>00440                   stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);
<a name="l00441"></a>00441                }
<a name="l00442"></a>00442             } <span class="keywordflow">else</span> {
<a name="l00443"></a>00443                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> header = STBIW_UCHAR(len - 129);
<a name="l00444"></a>00444                s-&gt;func(s-&gt;context, &amp;header, 1);
<a name="l00445"></a>00445                stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);
<a name="l00446"></a>00446             }
<a name="l00447"></a>00447          }
<a name="l00448"></a>00448       }
<a name="l00449"></a>00449    }
<a name="l00450"></a>00450    <span class="keywordflow">return</span> 1;
<a name="l00451"></a>00451 }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="keywordtype">int</span> stbi_write_tga_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455    stbi__write_context s;
<a name="l00456"></a>00456    stbi__start_write_callbacks(&amp;s, func, context);
<a name="l00457"></a>00457    <span class="keywordflow">return</span> stbi_write_tga_core(&amp;s, x, y, comp, (<span class="keywordtype">void</span> *) data);
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00461"></a>00461 <span class="preprocessor"></span><span class="keywordtype">int</span> stbi_write_tga(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data)
<a name="l00462"></a>00462 {
<a name="l00463"></a>00463    stbi__write_context s;
<a name="l00464"></a>00464    <span class="keywordflow">if</span> (stbi__start_write_file(&amp;s,filename)) {
<a name="l00465"></a>00465       <span class="keywordtype">int</span> r = stbi_write_tga_core(&amp;s, x, y, comp, (<span class="keywordtype">void</span> *) data);
<a name="l00466"></a>00466       stbi__end_write_file(&amp;s);
<a name="l00467"></a>00467       <span class="keywordflow">return</span> r;
<a name="l00468"></a>00468    } <span class="keywordflow">else</span>
<a name="l00469"></a>00469       <span class="keywordflow">return</span> 0;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 <span class="preprocessor">#endif</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span>
<a name="l00473"></a>00473 <span class="comment">// *************************************************************************************************</span>
<a name="l00474"></a>00474 <span class="comment">// Radiance RGBE HDR writer</span>
<a name="l00475"></a>00475 <span class="comment">// by Baldur Karlsson</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="preprocessor">#define stbiw__max(a, b)  ((a) &gt; (b) ? (a) : (b))</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>
<a name="l00479"></a>00479 <span class="keywordtype">void</span> stbiw__linear_to_rgbe(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *rgbe, <span class="keywordtype">float</span> *linear)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481    <span class="keywordtype">int</span> exponent;
<a name="l00482"></a>00482    <span class="keywordtype">float</span> maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));
<a name="l00483"></a>00483 
<a name="l00484"></a>00484    <span class="keywordflow">if</span> (maxcomp &lt; 1<a class="code" href="group__gtc__constants.html#g2425b9c6a54d9d91fd1a634700e85cf1">e</a>-32f) {
<a name="l00485"></a>00485       rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;
<a name="l00486"></a>00486    } <span class="keywordflow">else</span> {
<a name="l00487"></a>00487       <span class="keywordtype">float</span> <a class="code" href="group__gtc__dual__quaternion.html#g861508468b4982401f1ae5b4919c5678">normalize</a> = (float) <a class="code" href="group__core__func__common.html#g70c119cca554aacd36008191e2c4b2bb">frexp</a>(maxcomp, &amp;exponent) * 256.0f/maxcomp;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       rgbe[0] = (<span class="keywordtype">unsigned</span> char)(linear[0] * normalize);
<a name="l00490"></a>00490       rgbe[1] = (<span class="keywordtype">unsigned</span> char)(linear[1] * normalize);
<a name="l00491"></a>00491       rgbe[2] = (<span class="keywordtype">unsigned</span> char)(linear[2] * normalize);
<a name="l00492"></a>00492       rgbe[3] = (<span class="keywordtype">unsigned</span> char)(exponent + 128);
<a name="l00493"></a>00493    }
<a name="l00494"></a>00494 }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 <span class="keywordtype">void</span> stbiw__write_run_data(stbi__write_context *s, <span class="keywordtype">int</span> <a class="code" href="group__gtc__quaternion.html#g286560b01bedb4e046ffb71de22464f4">length</a>, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> databyte)
<a name="l00497"></a>00497 {
<a name="l00498"></a>00498    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lengthbyte = STBIW_UCHAR(length+128);
<a name="l00499"></a>00499    STBIW_ASSERT(length+128 &lt;= 255);
<a name="l00500"></a>00500    s-&gt;func(s-&gt;context, &amp;lengthbyte, 1);
<a name="l00501"></a>00501    s-&gt;func(s-&gt;context, &amp;databyte, 1);
<a name="l00502"></a>00502 }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="keywordtype">void</span> stbiw__write_dump_data(stbi__write_context *s, <span class="keywordtype">int</span> length, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data)
<a name="l00505"></a>00505 {
<a name="l00506"></a>00506    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lengthbyte = STBIW_UCHAR(length);
<a name="l00507"></a>00507    STBIW_ASSERT(length &lt;= 128); <span class="comment">// inconsistent with spec but consistent with official code</span>
<a name="l00508"></a>00508    s-&gt;func(s-&gt;context, &amp;lengthbyte, 1);
<a name="l00509"></a>00509    s-&gt;func(s-&gt;context, data, length);
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="keywordtype">void</span> stbiw__write_hdr_scanline(stbi__write_context *s, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> ncomp, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *scratch, <span class="keywordtype">float</span> *scanline)
<a name="l00513"></a>00513 {
<a name="l00514"></a>00514    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> scanlineheader[4] = { 2, 2, 0, 0 };
<a name="l00515"></a>00515    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> rgbe[4];
<a name="l00516"></a>00516    <span class="keywordtype">float</span> linear[3];
<a name="l00517"></a>00517    <span class="keywordtype">int</span> x;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519    scanlineheader[2] = (width&amp;0xff00)&gt;&gt;8;
<a name="l00520"></a>00520    scanlineheader[3] = (width&amp;0x00ff);
<a name="l00521"></a>00521 
<a name="l00522"></a>00522    <span class="comment">/* skip RLE for images too small or large */</span>
<a name="l00523"></a>00523    <span class="keywordflow">if</span> (width &lt; 8 || width &gt;= 32768) {
<a name="l00524"></a>00524       <span class="keywordflow">for</span> (x=0; x &lt; width; x++) {
<a name="l00525"></a>00525          <span class="keywordflow">switch</span> (ncomp) {
<a name="l00526"></a>00526             <span class="keywordflow">case</span> 4: <span class="comment">/* fallthrough */</span>
<a name="l00527"></a>00527             <span class="keywordflow">case</span> 3: linear[2] = scanline[x*ncomp + 2];
<a name="l00528"></a>00528                     linear[1] = scanline[x*ncomp + 1];
<a name="l00529"></a>00529                     linear[0] = scanline[x*ncomp + 0];
<a name="l00530"></a>00530                     <span class="keywordflow">break</span>;
<a name="l00531"></a>00531             <span class="keywordflow">default</span>:
<a name="l00532"></a>00532                     linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
<a name="l00533"></a>00533                     <span class="keywordflow">break</span>;
<a name="l00534"></a>00534          }
<a name="l00535"></a>00535          stbiw__linear_to_rgbe(rgbe, linear);
<a name="l00536"></a>00536          s-&gt;func(s-&gt;context, rgbe, 4);
<a name="l00537"></a>00537       }
<a name="l00538"></a>00538    } <span class="keywordflow">else</span> {
<a name="l00539"></a>00539       <span class="keywordtype">int</span> c,r;
<a name="l00540"></a>00540       <span class="comment">/* encode into scratch buffer */</span>
<a name="l00541"></a>00541       <span class="keywordflow">for</span> (x=0; x &lt; width; x++) {
<a name="l00542"></a>00542          <span class="keywordflow">switch</span>(ncomp) {
<a name="l00543"></a>00543             <span class="keywordflow">case</span> 4: <span class="comment">/* fallthrough */</span>
<a name="l00544"></a>00544             <span class="keywordflow">case</span> 3: linear[2] = scanline[x*ncomp + 2];
<a name="l00545"></a>00545                     linear[1] = scanline[x*ncomp + 1];
<a name="l00546"></a>00546                     linear[0] = scanline[x*ncomp + 0];
<a name="l00547"></a>00547                     <span class="keywordflow">break</span>;
<a name="l00548"></a>00548             <span class="keywordflow">default</span>:
<a name="l00549"></a>00549                     linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
<a name="l00550"></a>00550                     <span class="keywordflow">break</span>;
<a name="l00551"></a>00551          }
<a name="l00552"></a>00552          stbiw__linear_to_rgbe(rgbe, linear);
<a name="l00553"></a>00553          scratch[x + width*0] = rgbe[0];
<a name="l00554"></a>00554          scratch[x + width*1] = rgbe[1];
<a name="l00555"></a>00555          scratch[x + width*2] = rgbe[2];
<a name="l00556"></a>00556          scratch[x + width*3] = rgbe[3];
<a name="l00557"></a>00557       }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559       s-&gt;func(s-&gt;context, scanlineheader, 4);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561       <span class="comment">/* RLE each component separately */</span>
<a name="l00562"></a>00562       <span class="keywordflow">for</span> (c=0; c &lt; 4; c++) {
<a name="l00563"></a>00563          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *comp = &amp;scratch[width*c];
<a name="l00564"></a>00564 
<a name="l00565"></a>00565          x = 0;
<a name="l00566"></a>00566          <span class="keywordflow">while</span> (x &lt; width) {
<a name="l00567"></a>00567             <span class="comment">// find first run</span>
<a name="l00568"></a>00568             r = x;
<a name="l00569"></a>00569             <span class="keywordflow">while</span> (r+2 &lt; width) {
<a name="l00570"></a>00570                <span class="keywordflow">if</span> (comp[r] == comp[r+1] &amp;&amp; comp[r] == comp[r+2])
<a name="l00571"></a>00571                   <span class="keywordflow">break</span>;
<a name="l00572"></a>00572                ++r;
<a name="l00573"></a>00573             }
<a name="l00574"></a>00574             <span class="keywordflow">if</span> (r+2 &gt;= width)
<a name="l00575"></a>00575                r = width;
<a name="l00576"></a>00576             <span class="comment">// dump up to first run</span>
<a name="l00577"></a>00577             <span class="keywordflow">while</span> (x &lt; r) {
<a name="l00578"></a>00578                <span class="keywordtype">int</span> len = r-x;
<a name="l00579"></a>00579                <span class="keywordflow">if</span> (len &gt; 128) len = 128;
<a name="l00580"></a>00580                stbiw__write_dump_data(s, len, &amp;comp[x]);
<a name="l00581"></a>00581                x += len;
<a name="l00582"></a>00582             }
<a name="l00583"></a>00583             <span class="comment">// if there's a run, output it</span>
<a name="l00584"></a>00584             <span class="keywordflow">if</span> (r+2 &lt; width) { <span class="comment">// same test as what we break out of in search loop, so only true if we break'd</span>
<a name="l00585"></a>00585                <span class="comment">// find next byte after run</span>
<a name="l00586"></a>00586                <span class="keywordflow">while</span> (r &lt; width &amp;&amp; comp[r] == comp[x])
<a name="l00587"></a>00587                   ++r;
<a name="l00588"></a>00588                <span class="comment">// output run up to r</span>
<a name="l00589"></a>00589                <span class="keywordflow">while</span> (x &lt; r) {
<a name="l00590"></a>00590                   <span class="keywordtype">int</span> len = r-x;
<a name="l00591"></a>00591                   <span class="keywordflow">if</span> (len &gt; 127) len = 127;
<a name="l00592"></a>00592                   stbiw__write_run_data(s, len, comp[x]);
<a name="l00593"></a>00593                   x += len;
<a name="l00594"></a>00594                }
<a name="l00595"></a>00595             }
<a name="l00596"></a>00596          }
<a name="l00597"></a>00597       }
<a name="l00598"></a>00598    }
<a name="l00599"></a>00599 }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601 <span class="keyword">static</span> <span class="keywordtype">int</span> stbi_write_hdr_core(stbi__write_context *s, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keywordtype">float</span> *data)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603    <span class="keywordflow">if</span> (y &lt;= 0 || x &lt;= 0 || data == NULL)
<a name="l00604"></a>00604       <span class="keywordflow">return</span> 0;
<a name="l00605"></a>00605    <span class="keywordflow">else</span> {
<a name="l00606"></a>00606       <span class="comment">// Each component is stored separately. Allocate scratch space for full output scanline.</span>
<a name="l00607"></a>00607       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *scratch = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) STBIW_MALLOC(x*4);
<a name="l00608"></a>00608       <span class="keywordtype">int</span> i, len;
<a name="l00609"></a>00609       <span class="keywordtype">char</span> buffer[128];
<a name="l00610"></a>00610       <span class="keywordtype">char</span> header[] = <span class="stringliteral">"#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n"</span>;
<a name="l00611"></a>00611       s-&gt;func(s-&gt;context, header, <span class="keyword">sizeof</span>(header)-1);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613       len = sprintf(buffer, <span class="stringliteral">"EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n"</span>, y, x);
<a name="l00614"></a>00614       s-&gt;func(s-&gt;context, buffer, len);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616       <span class="keywordflow">for</span>(i=0; i &lt; y; i++)
<a name="l00617"></a>00617          stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*i*x);
<a name="l00618"></a>00618       STBIW_FREE(scratch);
<a name="l00619"></a>00619       <span class="keywordflow">return</span> 1;
<a name="l00620"></a>00620    }
<a name="l00621"></a>00621 }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="keywordtype">int</span> stbi_write_hdr_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">float</span> *data)
<a name="l00624"></a>00624 {
<a name="l00625"></a>00625    stbi__write_context s;
<a name="l00626"></a>00626    stbi__start_write_callbacks(&amp;s, func, context);
<a name="l00627"></a>00627    <span class="keywordflow">return</span> stbi_write_hdr_core(&amp;s, x, y, comp, (<span class="keywordtype">float</span> *) data);
<a name="l00628"></a>00628 }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span><span class="keywordtype">int</span> stbi_write_hdr(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">float</span> *data)
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633    stbi__write_context s;
<a name="l00634"></a>00634    <span class="keywordflow">if</span> (stbi__start_write_file(&amp;s,filename)) {
<a name="l00635"></a>00635       <span class="keywordtype">int</span> r = stbi_write_hdr_core(&amp;s, x, y, comp, (<span class="keywordtype">float</span> *) data);
<a name="l00636"></a>00636       stbi__end_write_file(&amp;s);
<a name="l00637"></a>00637       <span class="keywordflow">return</span> r;
<a name="l00638"></a>00638    } <span class="keywordflow">else</span>
<a name="l00639"></a>00639       <span class="keywordflow">return</span> 0;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 <span class="preprocessor">#endif // STBI_WRITE_NO_STDIO</span>
<a name="l00642"></a>00642 <span class="preprocessor"></span>
<a name="l00643"></a>00643 
<a name="l00645"></a>00645 <span class="comment">//</span>
<a name="l00646"></a>00646 <span class="comment">// PNG writer</span>
<a name="l00647"></a>00647 <span class="comment">//</span>
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">// stretchy buffer; stbiw__sbpush() == vector&lt;&gt;::push_back() -- stbiw__sbcount() == vector&lt;&gt;::size()</span>
<a name="l00650"></a>00650 <span class="preprocessor">#define stbiw__sbraw(a) ((int *) (a) - 2)</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbm(a)   stbiw__sbraw(a)[0]</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbn(a)   stbiw__sbraw(a)[1]</span>
<a name="l00653"></a>00653 <span class="preprocessor"></span>
<a name="l00654"></a>00654 <span class="preprocessor">#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n &gt;= stbiw__sbm(a))</span>
<a name="l00655"></a>00655 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &amp;(a), (n), sizeof(*(a)))</span>
<a name="l00657"></a>00657 <span class="preprocessor"></span>
<a name="l00658"></a>00658 <span class="preprocessor">#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)</span>
<a name="l00660"></a>00660 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>
<a name="l00662"></a>00662 <span class="keyword">static</span> <span class="keywordtype">void</span> *stbiw__sbgrowf(<span class="keywordtype">void</span> **arr, <span class="keywordtype">int</span> increment, <span class="keywordtype">int</span> itemsize)
<a name="l00663"></a>00663 {
<a name="l00664"></a>00664    <span class="keywordtype">int</span> m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;
<a name="l00665"></a>00665    <span class="keywordtype">void</span> *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*2) : 0, itemsize * m + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*2);
<a name="l00666"></a>00666    STBIW_ASSERT(p);
<a name="l00667"></a>00667    <span class="keywordflow">if</span> (p) {
<a name="l00668"></a>00668       <span class="keywordflow">if</span> (!*arr) ((<span class="keywordtype">int</span> *) p)[1] = 0;
<a name="l00669"></a>00669       *arr = (<span class="keywordtype">void</span> *) ((<span class="keywordtype">int</span> *) p + 2);
<a name="l00670"></a>00670       stbiw__sbm(*arr) = m;
<a name="l00671"></a>00671    }
<a name="l00672"></a>00672    <span class="keywordflow">return</span> *arr;
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *stbiw__zlib_flushf(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *bitbuffer, <span class="keywordtype">int</span> *bitcount)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677    <span class="keywordflow">while</span> (*bitcount &gt;= 8) {
<a name="l00678"></a>00678       stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));
<a name="l00679"></a>00679       *bitbuffer &gt;&gt;= 8;
<a name="l00680"></a>00680       *bitcount -= 8;
<a name="l00681"></a>00681    }
<a name="l00682"></a>00682    <span class="keywordflow">return</span> data;
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="keyword">static</span> <span class="keywordtype">int</span> stbiw__zlib_bitrev(<span class="keywordtype">int</span> code, <span class="keywordtype">int</span> codebits)
<a name="l00686"></a>00686 {
<a name="l00687"></a>00687    <span class="keywordtype">int</span> res=0;
<a name="l00688"></a>00688    <span class="keywordflow">while</span> (codebits--) {
<a name="l00689"></a>00689       res = (res &lt;&lt; 1) | (code &amp; 1);
<a name="l00690"></a>00690       code &gt;&gt;= 1;
<a name="l00691"></a>00691    }
<a name="l00692"></a>00692    <span class="keywordflow">return</span> res;
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stbiw__zlib_countm(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *a, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *b, <span class="keywordtype">int</span> limit)
<a name="l00696"></a>00696 {
<a name="l00697"></a>00697    <span class="keywordtype">int</span> i;
<a name="l00698"></a>00698    <span class="keywordflow">for</span> (i=0; i &lt; limit &amp;&amp; i &lt; 258; ++i)
<a name="l00699"></a>00699       <span class="keywordflow">if</span> (a[i] != b[i]) <span class="keywordflow">break</span>;
<a name="l00700"></a>00700    <span class="keywordflow">return</span> i;
<a name="l00701"></a>00701 }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stbiw__zhash(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data)
<a name="l00704"></a>00704 {
<a name="l00705"></a>00705    stbiw_uint32 hash = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16);
<a name="l00706"></a>00706    hash ^= hash &lt;&lt; 3;
<a name="l00707"></a>00707    hash += hash &gt;&gt; 5;
<a name="l00708"></a>00708    hash ^= hash &lt;&lt; 4;
<a name="l00709"></a>00709    hash += hash &gt;&gt; 17;
<a name="l00710"></a>00710    hash ^= hash &lt;&lt; 25;
<a name="l00711"></a>00711    hash += hash &gt;&gt; 6;
<a name="l00712"></a>00712    <span class="keywordflow">return</span> hash;
<a name="l00713"></a>00713 }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="preprocessor">#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &amp;bitbuf, &amp;bitcount))</span>
<a name="l00716"></a>00716 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_add(code,codebits) \</span>
<a name="l00717"></a>00717 <span class="preprocessor">      (bitbuf |= (code) &lt;&lt; bitcount, bitcount += (codebits), stbiw__zlib_flush())</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span><span class="comment">// default huffman tables</span>
<a name="l00720"></a>00720 <span class="preprocessor">#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)</span>
<a name="l00722"></a>00722 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)</span>
<a name="l00723"></a>00723 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)</span>
<a name="l00724"></a>00724 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huff(n)  ((n) &lt;= 143 ? stbiw__zlib_huff1(n) : (n) &lt;= 255 ? stbiw__zlib_huff2(n) : (n) &lt;= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__zlib_huffb(n) ((n) &lt;= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))</span>
<a name="l00726"></a>00726 <span class="preprocessor"></span>
<a name="l00727"></a>00727 <span class="preprocessor">#define stbiw__ZHASH   16384</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00729"></a>00729 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * stbi_zlib_compress(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">int</span> data_len, <span class="keywordtype">int</span> *out_len, <span class="keywordtype">int</span> quality)
<a name="l00730"></a>00730 {
<a name="l00731"></a>00731    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
<a name="l00732"></a>00732    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
<a name="l00733"></a>00733    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
<a name="l00734"></a>00734    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
<a name="l00735"></a>00735    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitbuf=0;
<a name="l00736"></a>00736    <span class="keywordtype">int</span> i,j, bitcount=0;
<a name="l00737"></a>00737    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out = NULL;
<a name="l00738"></a>00738    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ***hash_table = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>***) STBIW_MALLOC(stbiw__ZHASH * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>**));
<a name="l00739"></a>00739    <span class="keywordflow">if</span> (quality &lt; 5) quality = 5;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741    stbiw__sbpush(out, 0x78);   <span class="comment">// DEFLATE 32K window</span>
<a name="l00742"></a>00742    stbiw__sbpush(out, 0x5e);   <span class="comment">// FLEVEL = 1</span>
<a name="l00743"></a>00743    stbiw__zlib_add(1,1);  <span class="comment">// BFINAL = 1</span>
<a name="l00744"></a>00744    stbiw__zlib_add(1,2);  <span class="comment">// BTYPE = 1 -- fixed huffman</span>
<a name="l00745"></a>00745 
<a name="l00746"></a>00746    <span class="keywordflow">for</span> (i=0; i &lt; stbiw__ZHASH; ++i)
<a name="l00747"></a>00747       hash_table[i] = NULL;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749    i=0;
<a name="l00750"></a>00750    <span class="keywordflow">while</span> (i &lt; data_len-3) {
<a name="l00751"></a>00751       <span class="comment">// hash next 3 bytes of data to be compressed</span>
<a name="l00752"></a>00752       <span class="keywordtype">int</span> h = stbiw__zhash(data+i)&amp;(stbiw__ZHASH-1), best=3;
<a name="l00753"></a>00753       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bestloc = 0;
<a name="l00754"></a>00754       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **hlist = hash_table[h];
<a name="l00755"></a>00755       <span class="keywordtype">int</span> n = stbiw__sbcount(hlist);
<a name="l00756"></a>00756       <span class="keywordflow">for</span> (j=0; j &lt; n; ++j) {
<a name="l00757"></a>00757          <span class="keywordflow">if</span> (hlist[j]-data &gt; i-32768) { <span class="comment">// if entry lies within window</span>
<a name="l00758"></a>00758             <span class="keywordtype">int</span> d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
<a name="l00759"></a>00759             <span class="keywordflow">if</span> (d &gt;= best) best=d,bestloc=hlist[j];
<a name="l00760"></a>00760          }
<a name="l00761"></a>00761       }
<a name="l00762"></a>00762       <span class="comment">// when hash table entry is too long, delete half the entries</span>
<a name="l00763"></a>00763       <span class="keywordflow">if</span> (hash_table[h] &amp;&amp; stbiw__sbn(hash_table[h]) == 2*quality) {
<a name="l00764"></a>00764          STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, <span class="keyword">sizeof</span>(hash_table[h][0])*quality);
<a name="l00765"></a>00765          stbiw__sbn(hash_table[h]) = quality;
<a name="l00766"></a>00766       }
<a name="l00767"></a>00767       stbiw__sbpush(hash_table[h],data+i);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769       <span class="keywordflow">if</span> (bestloc) {
<a name="l00770"></a>00770          <span class="comment">// "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal</span>
<a name="l00771"></a>00771          h = stbiw__zhash(data+i+1)&amp;(stbiw__ZHASH-1);
<a name="l00772"></a>00772          hlist = hash_table[h];
<a name="l00773"></a>00773          n = stbiw__sbcount(hlist);
<a name="l00774"></a>00774          <span class="keywordflow">for</span> (j=0; j &lt; n; ++j) {
<a name="l00775"></a>00775             <span class="keywordflow">if</span> (hlist[j]-data &gt; i-32767) {
<a name="l00776"></a>00776                <span class="keywordtype">int</span> <a class="code" href="group__gtc__constants.html#g2425b9c6a54d9d91fd1a634700e85cf1">e</a> = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
<a name="l00777"></a>00777                <span class="keywordflow">if</span> (e &gt; best) { <span class="comment">// if next match is better, bail on current match</span>
<a name="l00778"></a>00778                   bestloc = NULL;
<a name="l00779"></a>00779                   <span class="keywordflow">break</span>;
<a name="l00780"></a>00780                }
<a name="l00781"></a>00781             }
<a name="l00782"></a>00782          }
<a name="l00783"></a>00783       }
<a name="l00784"></a>00784 
<a name="l00785"></a>00785       <span class="keywordflow">if</span> (bestloc) {
<a name="l00786"></a>00786          <span class="keywordtype">int</span> d = (int) (data+i - bestloc); <span class="comment">// distance back</span>
<a name="l00787"></a>00787          STBIW_ASSERT(d &lt;= 32767 &amp;&amp; best &lt;= 258);
<a name="l00788"></a>00788          <span class="keywordflow">for</span> (j=0; best &gt; lengthc[j+1]-1; ++j);
<a name="l00789"></a>00789          stbiw__zlib_huff(j+257);
<a name="l00790"></a>00790          <span class="keywordflow">if</span> (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);
<a name="l00791"></a>00791          <span class="keywordflow">for</span> (j=0; d &gt; distc[j+1]-1; ++j);
<a name="l00792"></a>00792          stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);
<a name="l00793"></a>00793          <span class="keywordflow">if</span> (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);
<a name="l00794"></a>00794          i += best;
<a name="l00795"></a>00795       } <span class="keywordflow">else</span> {
<a name="l00796"></a>00796          stbiw__zlib_huffb(data[i]);
<a name="l00797"></a>00797          ++i;
<a name="l00798"></a>00798       }
<a name="l00799"></a>00799    }
<a name="l00800"></a>00800    <span class="comment">// write out final bytes</span>
<a name="l00801"></a>00801    <span class="keywordflow">for</span> (;i &lt; data_len; ++i)
<a name="l00802"></a>00802       stbiw__zlib_huffb(data[i]);
<a name="l00803"></a>00803    stbiw__zlib_huff(256); <span class="comment">// end of block</span>
<a name="l00804"></a>00804    <span class="comment">// pad with 0 bits to byte boundary</span>
<a name="l00805"></a>00805    <span class="keywordflow">while</span> (bitcount)
<a name="l00806"></a>00806       stbiw__zlib_add(0,1);
<a name="l00807"></a>00807 
<a name="l00808"></a>00808    <span class="keywordflow">for</span> (i=0; i &lt; stbiw__ZHASH; ++i)
<a name="l00809"></a>00809       (<span class="keywordtype">void</span>) stbiw__sbfree(hash_table[i]);
<a name="l00810"></a>00810    STBIW_FREE(hash_table);
<a name="l00811"></a>00811 
<a name="l00812"></a>00812    {
<a name="l00813"></a>00813       <span class="comment">// compute adler32 on input</span>
<a name="l00814"></a>00814       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s1=1, s2=0;
<a name="l00815"></a>00815       <span class="keywordtype">int</span> blocklen = (int) (data_len % 5552);
<a name="l00816"></a>00816       j=0;
<a name="l00817"></a>00817       <span class="keywordflow">while</span> (j &lt; data_len) {
<a name="l00818"></a>00818          <span class="keywordflow">for</span> (i=0; i &lt; blocklen; ++i) s1 += data[j+i], s2 += s1;
<a name="l00819"></a>00819          s1 %= 65521, s2 %= 65521;
<a name="l00820"></a>00820          j += blocklen;
<a name="l00821"></a>00821          blocklen = 5552;
<a name="l00822"></a>00822       }
<a name="l00823"></a>00823       stbiw__sbpush(out, STBIW_UCHAR(s2 &gt;&gt; 8));
<a name="l00824"></a>00824       stbiw__sbpush(out, STBIW_UCHAR(s2));
<a name="l00825"></a>00825       stbiw__sbpush(out, STBIW_UCHAR(s1 &gt;&gt; 8));
<a name="l00826"></a>00826       stbiw__sbpush(out, STBIW_UCHAR(s1));
<a name="l00827"></a>00827    }
<a name="l00828"></a>00828    *out_len = stbiw__sbn(out);
<a name="l00829"></a>00829    <span class="comment">// make returned pointer freeable</span>
<a name="l00830"></a>00830    STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
<a name="l00831"></a>00831    <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) stbiw__sbraw(out);
<a name="l00832"></a>00832 }
<a name="l00833"></a>00833 
<a name="l00834"></a>00834 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stbiw__crc32(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> len)
<a name="l00835"></a>00835 {
<a name="l00836"></a>00836    <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> crc_table[256] =
<a name="l00837"></a>00837    {
<a name="l00838"></a>00838       0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
<a name="l00839"></a>00839       0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
<a name="l00840"></a>00840       0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
<a name="l00841"></a>00841       0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
<a name="l00842"></a>00842       0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
<a name="l00843"></a>00843       0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
<a name="l00844"></a>00844       0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
<a name="l00845"></a>00845       0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
<a name="l00846"></a>00846       0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
<a name="l00847"></a>00847       0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
<a name="l00848"></a>00848       0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
<a name="l00849"></a>00849       0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
<a name="l00850"></a>00850       0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
<a name="l00851"></a>00851       0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
<a name="l00852"></a>00852       0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
<a name="l00853"></a>00853       0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
<a name="l00854"></a>00854       0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
<a name="l00855"></a>00855       0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
<a name="l00856"></a>00856       0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
<a name="l00857"></a>00857       0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
<a name="l00858"></a>00858       0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
<a name="l00859"></a>00859       0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
<a name="l00860"></a>00860       0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
<a name="l00861"></a>00861       0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
<a name="l00862"></a>00862       0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
<a name="l00863"></a>00863       0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
<a name="l00864"></a>00864       0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
<a name="l00865"></a>00865       0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
<a name="l00866"></a>00866       0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
<a name="l00867"></a>00867       0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
<a name="l00868"></a>00868       0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
<a name="l00869"></a>00869       0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
<a name="l00870"></a>00870    };
<a name="l00871"></a>00871 
<a name="l00872"></a>00872    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> crc = ~0u;
<a name="l00873"></a>00873    <span class="keywordtype">int</span> i;
<a name="l00874"></a>00874    <span class="keywordflow">for</span> (i=0; i &lt; len; ++i)
<a name="l00875"></a>00875       crc = (crc &gt;&gt; 8) ^ crc_table[buffer[i] ^ (crc &amp; 0xff)];
<a name="l00876"></a>00876    <span class="keywordflow">return</span> ~crc;
<a name="l00877"></a>00877 }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 <span class="preprocessor">#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)&gt;&gt;24,(v)&gt;&gt;16,(v)&gt;&gt;8,(v));</span>
<a name="l00881"></a>00881 <span class="preprocessor"></span><span class="preprocessor">#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>
<a name="l00883"></a>00883 <span class="keyword">static</span> <span class="keywordtype">void</span> stbiw__wpcrc(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> **data, <span class="keywordtype">int</span> len)
<a name="l00884"></a>00884 {
<a name="l00885"></a>00885    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> crc = stbiw__crc32(*data - len - 4, len+4);
<a name="l00886"></a>00886    stbiw__wp32(*data, crc);
<a name="l00887"></a>00887 }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> stbiw__paeth(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c)
<a name="l00890"></a>00890 {
<a name="l00891"></a>00891    <span class="keywordtype">int</span> p = a + b - c, pa = <a class="code" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1">abs</a>(p-a), pb = <a class="code" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1">abs</a>(p-b), pc = <a class="code" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1">abs</a>(p-c);
<a name="l00892"></a>00892    <span class="keywordflow">if</span> (pa &lt;= pb &amp;&amp; pa &lt;= pc) <span class="keywordflow">return</span> STBIW_UCHAR(a);
<a name="l00893"></a>00893    <span class="keywordflow">if</span> (pb &lt;= pc) <span class="keywordflow">return</span> STBIW_UCHAR(b);
<a name="l00894"></a>00894    <span class="keywordflow">return</span> STBIW_UCHAR(c);
<a name="l00895"></a>00895 }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897 <span class="comment">// @OPTIMIZE: provide an option that always forces left-predict or paeth predict</span>
<a name="l00898"></a>00898 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *stbi_write_png_to_mem(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *pixels, <span class="keywordtype">int</span> stride_bytes, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> *out_len)
<a name="l00899"></a>00899 {
<a name="l00900"></a>00900    <span class="keywordtype">int</span> ctype[5] = { -1, 0, 4, 2, 6 };
<a name="l00901"></a>00901    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> sig[8] = { 137,80,78,71,13,10,26,10 };
<a name="l00902"></a>00902    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *out,*o, *filt, *zlib;
<a name="l00903"></a>00903    <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *line_buffer;
<a name="l00904"></a>00904    <span class="keywordtype">int</span> i,j,k,p,zlen;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906    <span class="keywordflow">if</span> (stride_bytes == 0)
<a name="l00907"></a>00907       stride_bytes = x * n;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909    filt = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) STBIW_MALLOC((x*n+1) * y); <span class="keywordflow">if</span> (!filt) <span class="keywordflow">return</span> 0;
<a name="l00910"></a>00910    line_buffer = (<span class="keywordtype">signed</span> <span class="keywordtype">char</span> *) STBIW_MALLOC(x * n); <span class="keywordflow">if</span> (!line_buffer) { STBIW_FREE(filt); <span class="keywordflow">return</span> 0; }
<a name="l00911"></a>00911    <span class="keywordflow">for</span> (j=0; j &lt; y; ++j) {
<a name="l00912"></a>00912       <span class="keyword">static</span> <span class="keywordtype">int</span> mapping[] = { 0,1,2,3,4 };
<a name="l00913"></a>00913       <span class="keyword">static</span> <span class="keywordtype">int</span> firstmap[] = { 0,1,0,5,6 };
<a name="l00914"></a>00914       <span class="keywordtype">int</span> *mymap = (j != 0) ? mapping : firstmap;
<a name="l00915"></a>00915       <span class="keywordtype">int</span> best = 0, bestval = 0x7fffffff;
<a name="l00916"></a>00916       <span class="keywordflow">for</span> (p=0; p &lt; 2; ++p) {
<a name="l00917"></a>00917          <span class="keywordflow">for</span> (k= p?best:0; k &lt; 5; ++k) { <span class="comment">// @TODO: clarity: rewrite this to go 0..5, and 'continue' the unwanted ones during 2nd pass</span>
<a name="l00918"></a>00918             <span class="keywordtype">int</span> type = mymap[k],est=0;
<a name="l00919"></a>00919             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *z = pixels + stride_bytes*j;
<a name="l00920"></a>00920             <span class="keywordflow">for</span> (i=0; i &lt; n; ++i)
<a name="l00921"></a>00921                <span class="keywordflow">switch</span> (type) {
<a name="l00922"></a>00922                   <span class="keywordflow">case</span> 0: line_buffer[i] = z[i]; <span class="keywordflow">break</span>;
<a name="l00923"></a>00923                   <span class="keywordflow">case</span> 1: line_buffer[i] = z[i]; <span class="keywordflow">break</span>;
<a name="l00924"></a>00924                   <span class="keywordflow">case</span> 2: line_buffer[i] = z[i] - z[i-stride_bytes]; <span class="keywordflow">break</span>;
<a name="l00925"></a>00925                   <span class="keywordflow">case</span> 3: line_buffer[i] = z[i] - (z[i-stride_bytes]&gt;&gt;1); <span class="keywordflow">break</span>;
<a name="l00926"></a>00926                   <span class="keywordflow">case</span> 4: line_buffer[i] = (<span class="keywordtype">signed</span> char) (z[i] - stbiw__paeth(0,z[i-stride_bytes],0)); <span class="keywordflow">break</span>;
<a name="l00927"></a>00927                   <span class="keywordflow">case</span> 5: line_buffer[i] = z[i]; <span class="keywordflow">break</span>;
<a name="l00928"></a>00928                   <span class="keywordflow">case</span> 6: line_buffer[i] = z[i]; <span class="keywordflow">break</span>;
<a name="l00929"></a>00929                }
<a name="l00930"></a>00930             <span class="keywordflow">for</span> (i=n; i &lt; x*n; ++i) {
<a name="l00931"></a>00931                <span class="keywordflow">switch</span> (type) {
<a name="l00932"></a>00932                   <span class="keywordflow">case</span> 0: line_buffer[i] = z[i]; <span class="keywordflow">break</span>;
<a name="l00933"></a>00933                   <span class="keywordflow">case</span> 1: line_buffer[i] = z[i] - z[i-n]; <span class="keywordflow">break</span>;
<a name="l00934"></a>00934                   <span class="keywordflow">case</span> 2: line_buffer[i] = z[i] - z[i-stride_bytes]; <span class="keywordflow">break</span>;
<a name="l00935"></a>00935                   <span class="keywordflow">case</span> 3: line_buffer[i] = z[i] - ((z[i-n] + z[i-stride_bytes])&gt;&gt;1); <span class="keywordflow">break</span>;
<a name="l00936"></a>00936                   <span class="keywordflow">case</span> 4: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-stride_bytes], z[i-stride_bytes-n]); <span class="keywordflow">break</span>;
<a name="l00937"></a>00937                   <span class="keywordflow">case</span> 5: line_buffer[i] = z[i] - (z[i-n]&gt;&gt;1); <span class="keywordflow">break</span>;
<a name="l00938"></a>00938                   <span class="keywordflow">case</span> 6: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); <span class="keywordflow">break</span>;
<a name="l00939"></a>00939                }
<a name="l00940"></a>00940             }
<a name="l00941"></a>00941             <span class="keywordflow">if</span> (p) <span class="keywordflow">break</span>;
<a name="l00942"></a>00942             <span class="keywordflow">for</span> (i=0; i &lt; x*n; ++i)
<a name="l00943"></a>00943                est += <a class="code" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1">abs</a>((<span class="keywordtype">signed</span> <span class="keywordtype">char</span>) line_buffer[i]);
<a name="l00944"></a>00944             <span class="keywordflow">if</span> (est &lt; bestval) { bestval = est; best = k; }
<a name="l00945"></a>00945          }
<a name="l00946"></a>00946       }
<a name="l00947"></a>00947       <span class="comment">// when we get here, best contains the filter type, and line_buffer contains the data</span>
<a name="l00948"></a>00948       filt[j*(x*n+1)] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) best;
<a name="l00949"></a>00949       STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
<a name="l00950"></a>00950    }
<a name="l00951"></a>00951    STBIW_FREE(line_buffer);
<a name="l00952"></a>00952    zlib = stbi_zlib_compress(filt, y*( x*n+1), &amp;zlen, 8); <span class="comment">// increase 8 to get smaller but use more memory</span>
<a name="l00953"></a>00953    STBIW_FREE(filt);
<a name="l00954"></a>00954    <span class="keywordflow">if</span> (!zlib) <span class="keywordflow">return</span> 0;
<a name="l00955"></a>00955 
<a name="l00956"></a>00956    <span class="comment">// each tag requires 12 bytes of overhead</span>
<a name="l00957"></a>00957    out = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
<a name="l00958"></a>00958    <span class="keywordflow">if</span> (!out) <span class="keywordflow">return</span> 0;
<a name="l00959"></a>00959    *out_len = 8 + 12+13 + 12+zlen + 12;
<a name="l00960"></a>00960 
<a name="l00961"></a>00961    o=out;
<a name="l00962"></a>00962    STBIW_MEMMOVE(o,sig,8); o+= 8;
<a name="l00963"></a>00963    stbiw__wp32(o, 13); <span class="comment">// header length</span>
<a name="l00964"></a>00964    stbiw__wptag(o, <span class="stringliteral">"IHDR"</span>);
<a name="l00965"></a>00965    stbiw__wp32(o, x);
<a name="l00966"></a>00966    stbiw__wp32(o, y);
<a name="l00967"></a>00967    *o++ = 8;
<a name="l00968"></a>00968    *o++ = STBIW_UCHAR(ctype[n]);
<a name="l00969"></a>00969    *o++ = 0;
<a name="l00970"></a>00970    *o++ = 0;
<a name="l00971"></a>00971    *o++ = 0;
<a name="l00972"></a>00972    stbiw__wpcrc(&amp;o,13);
<a name="l00973"></a>00973 
<a name="l00974"></a>00974    stbiw__wp32(o, zlen);
<a name="l00975"></a>00975    stbiw__wptag(o, <span class="stringliteral">"IDAT"</span>);
<a name="l00976"></a>00976    STBIW_MEMMOVE(o, zlib, zlen);
<a name="l00977"></a>00977    o += zlen;
<a name="l00978"></a>00978    STBIW_FREE(zlib);
<a name="l00979"></a>00979    stbiw__wpcrc(&amp;o, zlen);
<a name="l00980"></a>00980 
<a name="l00981"></a>00981    stbiw__wp32(o,0);
<a name="l00982"></a>00982    stbiw__wptag(o, <span class="stringliteral">"IEND"</span>);
<a name="l00983"></a>00983    stbiw__wpcrc(&amp;o,0);
<a name="l00984"></a>00984 
<a name="l00985"></a>00985    STBIW_ASSERT(o == out + *out_len);
<a name="l00986"></a>00986 
<a name="l00987"></a>00987    <span class="keywordflow">return</span> out;
<a name="l00988"></a>00988 }
<a name="l00989"></a>00989 
<a name="l00990"></a>00990 <span class="preprocessor">#ifndef STBI_WRITE_NO_STDIO</span>
<a name="l00991"></a>00991 <span class="preprocessor"></span>STBIWDEF <span class="keywordtype">int</span> stbi_write_png(<span class="keywordtype">char</span> <span class="keyword">const</span> *filename, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> stride_bytes)
<a name="l00992"></a>00992 {
<a name="l00993"></a>00993    FILE *f;
<a name="l00994"></a>00994    <span class="keywordtype">int</span> len;
<a name="l00995"></a>00995    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *png = stbi_write_png_to_mem((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) data, stride_bytes, x, y, comp, &amp;len);
<a name="l00996"></a>00996    <span class="keywordflow">if</span> (png == NULL) <span class="keywordflow">return</span> 0;
<a name="l00997"></a>00997    f = fopen(filename, <span class="stringliteral">"wb"</span>);
<a name="l00998"></a>00998    <span class="keywordflow">if</span> (!f) { STBIW_FREE(png); <span class="keywordflow">return</span> 0; }
<a name="l00999"></a>00999    fwrite(png, 1, len, f);
<a name="l01000"></a>01000    fclose(f);
<a name="l01001"></a>01001    STBIW_FREE(png);
<a name="l01002"></a>01002    <span class="keywordflow">return</span> 1;
<a name="l01003"></a>01003 }
<a name="l01004"></a>01004 <span class="preprocessor">#endif</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>
<a name="l01006"></a>01006 STBIWDEF <span class="keywordtype">int</span> stbi_write_png_to_func(stbi_write_func *func, <span class="keywordtype">void</span> *context, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> comp, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> stride_bytes)
<a name="l01007"></a>01007 {
<a name="l01008"></a>01008    <span class="keywordtype">int</span> len;
<a name="l01009"></a>01009    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *png = stbi_write_png_to_mem((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) data, stride_bytes, x, y, comp, &amp;len);
<a name="l01010"></a>01010    <span class="keywordflow">if</span> (png == NULL) <span class="keywordflow">return</span> 0;
<a name="l01011"></a>01011    func(context, png, len);
<a name="l01012"></a>01012    STBIW_FREE(png);
<a name="l01013"></a>01013    <span class="keywordflow">return</span> 1;
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="preprocessor">#endif // STB_IMAGE_WRITE_IMPLEMENTATION</span>
<a name="l01017"></a>01017 <span class="preprocessor"></span>
<a name="l01018"></a>01018 <span class="comment">/* Revision history</span>
<a name="l01019"></a>01019 <span class="comment">      1.04 (2017-03-03)</span>
<a name="l01020"></a>01020 <span class="comment">             monochrome BMP expansion</span>
<a name="l01021"></a>01021 <span class="comment">      1.03   ???</span>
<a name="l01022"></a>01022 <span class="comment">      1.02 (2016-04-02)</span>
<a name="l01023"></a>01023 <span class="comment">             avoid allocating large structures on the stack</span>
<a name="l01024"></a>01024 <span class="comment">      1.01 (2016-01-16)</span>
<a name="l01025"></a>01025 <span class="comment">             STBIW_REALLOC_SIZED: support allocators with no realloc support</span>
<a name="l01026"></a>01026 <span class="comment">             avoid race-condition in crc initialization</span>
<a name="l01027"></a>01027 <span class="comment">             minor compile issues</span>
<a name="l01028"></a>01028 <span class="comment">      1.00 (2015-09-14)</span>
<a name="l01029"></a>01029 <span class="comment">             installable file IO function</span>
<a name="l01030"></a>01030 <span class="comment">      0.99 (2015-09-13)</span>
<a name="l01031"></a>01031 <span class="comment">             warning fixes; TGA rle support</span>
<a name="l01032"></a>01032 <span class="comment">      0.98 (2015-04-08)</span>
<a name="l01033"></a>01033 <span class="comment">             added STBIW_MALLOC, STBIW_ASSERT etc</span>
<a name="l01034"></a>01034 <span class="comment">      0.97 (2015-01-18)</span>
<a name="l01035"></a>01035 <span class="comment">             fixed HDR asserts, rewrote HDR rle logic</span>
<a name="l01036"></a>01036 <span class="comment">      0.96 (2015-01-17)</span>
<a name="l01037"></a>01037 <span class="comment">             add HDR output</span>
<a name="l01038"></a>01038 <span class="comment">             fix monochrome BMP</span>
<a name="l01039"></a>01039 <span class="comment">      0.95 (2014-08-17)</span>
<a name="l01040"></a>01040 <span class="comment">                       add monochrome TGA output</span>
<a name="l01041"></a>01041 <span class="comment">      0.94 (2014-05-31)</span>
<a name="l01042"></a>01042 <span class="comment">             rename private functions to avoid conflicts with stb_image.h</span>
<a name="l01043"></a>01043 <span class="comment">      0.93 (2014-05-27)</span>
<a name="l01044"></a>01044 <span class="comment">             warning fixes</span>
<a name="l01045"></a>01045 <span class="comment">      0.92 (2010-08-01)</span>
<a name="l01046"></a>01046 <span class="comment">             casts to unsigned char to fix warnings</span>
<a name="l01047"></a>01047 <span class="comment">      0.91 (2010-07-17)</span>
<a name="l01048"></a>01048 <span class="comment">             first public release</span>
<a name="l01049"></a>01049 <span class="comment">      0.90   first internal release</span>
<a name="l01050"></a>01050 <span class="comment">*/</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="comment">/*</span>
<a name="l01053"></a>01053 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l01054"></a>01054 <span class="comment">This software is available under 2 licenses -- choose whichever you prefer.</span>
<a name="l01055"></a>01055 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l01056"></a>01056 <span class="comment">ALTERNATIVE A - MIT License</span>
<a name="l01057"></a>01057 <span class="comment">Copyright (c) 2017 Sean Barrett</span>
<a name="l01058"></a>01058 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy of </span>
<a name="l01059"></a>01059 <span class="comment">this software and associated documentation files (the "Software"), to deal in </span>
<a name="l01060"></a>01060 <span class="comment">the Software without restriction, including without limitation the rights to </span>
<a name="l01061"></a>01061 <span class="comment">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies </span>
<a name="l01062"></a>01062 <span class="comment">of the Software, and to permit persons to whom the Software is furnished to do </span>
<a name="l01063"></a>01063 <span class="comment">so, subject to the following conditions:</span>
<a name="l01064"></a>01064 <span class="comment">The above copyright notice and this permission notice shall be included in all </span>
<a name="l01065"></a>01065 <span class="comment">copies or substantial portions of the Software.</span>
<a name="l01066"></a>01066 <span class="comment">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR </span>
<a name="l01067"></a>01067 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, </span>
<a name="l01068"></a>01068 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE </span>
<a name="l01069"></a>01069 <span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER </span>
<a name="l01070"></a>01070 <span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, </span>
<a name="l01071"></a>01071 <span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE </span>
<a name="l01072"></a>01072 <span class="comment">SOFTWARE.</span>
<a name="l01073"></a>01073 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l01074"></a>01074 <span class="comment">ALTERNATIVE B - Public Domain (www.unlicense.org)</span>
<a name="l01075"></a>01075 <span class="comment">This is free and unencumbered software released into the public domain.</span>
<a name="l01076"></a>01076 <span class="comment">Anyone is free to copy, modify, publish, use, compile, sell, or distribute this </span>
<a name="l01077"></a>01077 <span class="comment">software, either in source code form or as a compiled binary, for any purpose, </span>
<a name="l01078"></a>01078 <span class="comment">commercial or non-commercial, and by any means.</span>
<a name="l01079"></a>01079 <span class="comment">In jurisdictions that recognize copyright laws, the author or authors of this </span>
<a name="l01080"></a>01080 <span class="comment">software dedicate any and all copyright interest in the software to the public </span>
<a name="l01081"></a>01081 <span class="comment">domain. We make this dedication for the benefit of the public at large and to </span>
<a name="l01082"></a>01082 <span class="comment">the detriment of our heirs and successors. We intend this dedication to be an </span>
<a name="l01083"></a>01083 <span class="comment">overt act of relinquishment in perpetuity of all present and future rights to </span>
<a name="l01084"></a>01084 <span class="comment">this software under copyright law.</span>
<a name="l01085"></a>01085 <span class="comment">THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR </span>
<a name="l01086"></a>01086 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, </span>
<a name="l01087"></a>01087 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE </span>
<a name="l01088"></a>01088 <span class="comment">AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN </span>
<a name="l01089"></a>01089 <span class="comment">ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION </span>
<a name="l01090"></a>01090 <span class="comment">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l01091"></a>01091 <span class="comment">------------------------------------------------------------------------------</span>
<a name="l01092"></a>01092 <span class="comment">*/</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 12:56:53 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
