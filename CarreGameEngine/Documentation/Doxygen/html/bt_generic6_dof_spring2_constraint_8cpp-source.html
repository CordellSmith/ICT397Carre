<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Bullet Continuous Collision Detection and Physics Library</span>
<a name="l00003"></a>00003 <span class="comment">Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">This software is provided 'as-is', without any express or implied warranty.</span>
<a name="l00006"></a>00006 <span class="comment">In no event will the authors be held liable for any damages arising from the use of this software.</span>
<a name="l00007"></a>00007 <span class="comment">Permission is granted to anyone to use this software for any purpose,</span>
<a name="l00008"></a>00008 <span class="comment">including commercial applications, and to alter it and redistribute it freely,</span>
<a name="l00009"></a>00009 <span class="comment">subject to the following restrictions:</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.</span>
<a name="l00012"></a>00012 <span class="comment">2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.</span>
<a name="l00013"></a>00013 <span class="comment">3. This notice may not be removed or altered from any source distribution.</span>
<a name="l00014"></a>00014 <span class="comment">*/</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">/*</span>
<a name="l00017"></a>00017 <span class="comment">2014 May: btGeneric6DofSpring2Constraint is created from the original (2.82.2712) btGeneric6DofConstraint by Gabor Puhr and Tamas Umenhoffer</span>
<a name="l00018"></a>00018 <span class="comment">Pros:</span>
<a name="l00019"></a>00019 <span class="comment">- Much more accurate and stable in a lot of situation. (Especially when a sleeping chain of RBs connected with 6dof2 is pulled)</span>
<a name="l00020"></a>00020 <span class="comment">- Stable and accurate spring with minimal energy loss that works with all of the solvers. (latter is not true for the original 6dof spring)</span>
<a name="l00021"></a>00021 <span class="comment">- Servo motor functionality</span>
<a name="l00022"></a>00022 <span class="comment">- Much more accurate bouncing. 0 really means zero bouncing (not true for the original 6odf) and there is only a minimal energy loss when the value is 1 (because of the solvers' precision)</span>
<a name="l00023"></a>00023 <span class="comment">- Rotation order for the Euler system can be set. (One axis' freedom is still limited to pi/2)</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">Cons:</span>
<a name="l00026"></a>00026 <span class="comment">- It is slower than the original 6dof. There is no exact ratio, but half speed is a good estimation. (with PGS)</span>
<a name="l00027"></a>00027 <span class="comment">- At bouncing the correct velocity is calculated, but not the correct position. (it is because of the solver can correct position or velocity, but not both.)</span>
<a name="l00028"></a>00028 <span class="comment">*/</span>
<a name="l00029"></a>00029 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/*</span>
<a name="l00034"></a>00034 <span class="comment">2007-09-09</span>
<a name="l00035"></a>00035 <span class="comment">btGeneric6DofConstraint Refactored by Francisco Le?n</span>
<a name="l00036"></a>00036 <span class="comment">email: projectileman@yahoo.com</span>
<a name="l00037"></a>00037 <span class="comment">http://gimpact.sf.net</span>
<a name="l00038"></a>00038 <span class="comment">*/</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include "btGeneric6DofSpring2Constraint.h"</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include "BulletDynamics/Dynamics/btRigidBody.h"</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include "LinearMath/btTransformUtil.h"</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;new&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 btGeneric6DofSpring2Constraint::btGeneric6DofSpring2Constraint(<a class="code" href="classbt_rigid_body.html">btRigidBody</a>&amp; rbA, <a class="code" href="classbt_rigid_body.html">btRigidBody</a>&amp; rbB, <span class="keyword">const</span> btTransform&amp; frameInA, <span class="keyword">const</span> btTransform&amp; frameInB, RotateOrder rotOrder)
<a name="l00050"></a>00050         : btTypedConstraint(D6_SPRING_2_CONSTRAINT_TYPE, rbA, rbB)
<a name="l00051"></a>00051         , m_frameInA(frameInA)
<a name="l00052"></a>00052         , m_frameInB(frameInB)
<a name="l00053"></a>00053         , m_rotateOrder(rotOrder)       
<a name="l00054"></a>00054         , m_flags(0)
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056         calculateTransforms();
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 btGeneric6DofSpring2Constraint::btGeneric6DofSpring2Constraint(<a class="code" href="classbt_rigid_body.html">btRigidBody</a>&amp; rbB, <span class="keyword">const</span> btTransform&amp; frameInB, RotateOrder rotOrder)
<a name="l00061"></a>00061         : btTypedConstraint(D6_SPRING_2_CONSTRAINT_TYPE, getFixedBody(), rbB)
<a name="l00062"></a>00062         , m_frameInB(frameInB)
<a name="l00063"></a>00063         , m_rotateOrder(rotOrder)
<a name="l00064"></a>00064         , m_flags(0)
<a name="l00065"></a>00065 {
<a name="l00067"></a>00067         m_frameInA = rbB.<a class="code" href="classbt_rigid_body.html#5eaee89e89e7498cfb39709e58fdc477">getCenterOfMassTransform</a>() * m_frameInB;
<a name="l00068"></a>00068         calculateTransforms();
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 btScalar btGeneric6DofSpring2Constraint::btGetMatrixElem(<span class="keyword">const</span> btMatrix3x3&amp; mat, <span class="keywordtype">int</span> index)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074         <span class="keywordtype">int</span> i = index%3;
<a name="l00075"></a>00075         <span class="keywordtype">int</span> j = index/3;
<a name="l00076"></a>00076         <span class="keywordflow">return</span> mat[i][j];
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">// MatrixToEulerXYZ from http://www.geometrictools.com/LibFoundation/Mathematics/Wm4Matrix3.inl.html</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerXYZ(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083         <span class="comment">// rot =  cy*cz          -cy*sz           sy</span>
<a name="l00084"></a>00084         <span class="comment">//        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx</span>
<a name="l00085"></a>00085         <span class="comment">//       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         btScalar fi = btGetMatrixElem(mat,2);
<a name="l00088"></a>00088         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00089"></a>00089         {
<a name="l00090"></a>00090                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00091"></a>00091                 {
<a name="l00092"></a>00092                         xyz[0] = btAtan2(-btGetMatrixElem(mat,5),btGetMatrixElem(mat,8));
<a name="l00093"></a>00093                         xyz[1] = btAsin(btGetMatrixElem(mat,2));
<a name="l00094"></a>00094                         xyz[2] = btAtan2(-btGetMatrixElem(mat,1),btGetMatrixElem(mat,0));
<a name="l00095"></a>00095                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00096"></a>00096                 }
<a name="l00097"></a>00097                 <span class="keywordflow">else</span>
<a name="l00098"></a>00098                 {
<a name="l00099"></a>00099                         <span class="comment">// WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)</span>
<a name="l00100"></a>00100                         xyz[0] = -btAtan2(btGetMatrixElem(mat,3),btGetMatrixElem(mat,4));
<a name="l00101"></a>00101                         xyz[1] = -SIMD_HALF_PI;
<a name="l00102"></a>00102                         xyz[2] = btScalar(0.0);
<a name="l00103"></a>00103                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00104"></a>00104                 }
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106         <span class="keywordflow">else</span>
<a name="l00107"></a>00107         {
<a name="l00108"></a>00108                 <span class="comment">// WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)</span>
<a name="l00109"></a>00109                 xyz[0] = btAtan2(btGetMatrixElem(mat,3),btGetMatrixElem(mat,4));
<a name="l00110"></a>00110                 xyz[1] = SIMD_HALF_PI;
<a name="l00111"></a>00111                 xyz[2] = 0.0;
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerXZY(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118         <span class="comment">// rot =  cy*cz          -sz           sy*cz</span>
<a name="l00119"></a>00119         <span class="comment">//        cy*cx*sz+sx*sy  cx*cz        sy*cx*sz-cy*sx</span>
<a name="l00120"></a>00120         <span class="comment">//        cy*sx*sz-cx*sy  sx*cz        sy*sx*sz+cx*cy</span>
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         btScalar fi = btGetMatrixElem(mat,1);
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00124"></a>00124         {
<a name="l00125"></a>00125                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00126"></a>00126                 {
<a name="l00127"></a>00127                         xyz[0] = btAtan2(btGetMatrixElem(mat,7),btGetMatrixElem(mat,4));
<a name="l00128"></a>00128                         xyz[1] = btAtan2(btGetMatrixElem(mat,2),btGetMatrixElem(mat,0));
<a name="l00129"></a>00129                         xyz[2] = btAsin(-btGetMatrixElem(mat,1));
<a name="l00130"></a>00130                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00131"></a>00131                 }
<a name="l00132"></a>00132                 <span class="keywordflow">else</span>
<a name="l00133"></a>00133                 {
<a name="l00134"></a>00134                         xyz[0] = -btAtan2(-btGetMatrixElem(mat,6),btGetMatrixElem(mat,8));
<a name="l00135"></a>00135                         xyz[1] = btScalar(0.0);
<a name="l00136"></a>00136                         xyz[2] = SIMD_HALF_PI;
<a name="l00137"></a>00137                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00138"></a>00138                 }
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140         <span class="keywordflow">else</span>
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142                 xyz[0] = btAtan2(-btGetMatrixElem(mat,6),btGetMatrixElem(mat,8));
<a name="l00143"></a>00143                 xyz[1] = 0.0;
<a name="l00144"></a>00144                 xyz[2] = -SIMD_HALF_PI;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerYXZ(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151         <span class="comment">// rot =  cy*cz+sy*sx*sz  cz*sy*sx-cy*sz  cx*sy</span>
<a name="l00152"></a>00152         <span class="comment">//        cx*sz           cx*cz           -sx</span>
<a name="l00153"></a>00153         <span class="comment">//        cy*sx*sz-cz*sy  sy*sz+cy*cz*sx  cy*cx</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         btScalar fi = btGetMatrixElem(mat,5);
<a name="l00156"></a>00156         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00157"></a>00157         {
<a name="l00158"></a>00158                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00159"></a>00159                 {
<a name="l00160"></a>00160                         xyz[0] = btAsin(-btGetMatrixElem(mat,5));
<a name="l00161"></a>00161                         xyz[1] = btAtan2(btGetMatrixElem(mat,2),btGetMatrixElem(mat,8));
<a name="l00162"></a>00162                         xyz[2] = btAtan2(btGetMatrixElem(mat,3),btGetMatrixElem(mat,4));
<a name="l00163"></a>00163                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00164"></a>00164                 }
<a name="l00165"></a>00165                 <span class="keywordflow">else</span>
<a name="l00166"></a>00166                 {
<a name="l00167"></a>00167                         xyz[0] = SIMD_HALF_PI;
<a name="l00168"></a>00168                         xyz[1] = -btAtan2(-btGetMatrixElem(mat,1),btGetMatrixElem(mat,0));
<a name="l00169"></a>00169                         xyz[2] = btScalar(0.0);
<a name="l00170"></a>00170                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00171"></a>00171                 }
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173         <span class="keywordflow">else</span>
<a name="l00174"></a>00174         {
<a name="l00175"></a>00175                 xyz[0] = -SIMD_HALF_PI;
<a name="l00176"></a>00176                 xyz[1] = btAtan2(-btGetMatrixElem(mat,1),btGetMatrixElem(mat,0));
<a name="l00177"></a>00177                 xyz[2] = 0.0;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00180"></a>00180 }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerYZX(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184         <span class="comment">// rot =  cy*cz   sy*sx-cy*cx*sz   cx*sy+cy*sz*sx</span>
<a name="l00185"></a>00185         <span class="comment">//        sz           cz*cx           -cz*sx</span>
<a name="l00186"></a>00186         <span class="comment">//        -cz*sy  cy*sx+cx*sy*sz   cy*cx-sy*sz*sx</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188         btScalar fi = btGetMatrixElem(mat,3);
<a name="l00189"></a>00189         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00192"></a>00192                 {
<a name="l00193"></a>00193                         xyz[0] = btAtan2(-btGetMatrixElem(mat,5),btGetMatrixElem(mat,4));
<a name="l00194"></a>00194                         xyz[1] = btAtan2(-btGetMatrixElem(mat,6),btGetMatrixElem(mat,0));
<a name="l00195"></a>00195                         xyz[2] = btAsin(btGetMatrixElem(mat,3));
<a name="l00196"></a>00196                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00197"></a>00197                 }
<a name="l00198"></a>00198                 <span class="keywordflow">else</span>
<a name="l00199"></a>00199                 {
<a name="l00200"></a>00200                         xyz[0] = btScalar(0.0);
<a name="l00201"></a>00201                         xyz[1] = -btAtan2(btGetMatrixElem(mat,7),btGetMatrixElem(mat,8));
<a name="l00202"></a>00202                         xyz[2] = -SIMD_HALF_PI;
<a name="l00203"></a>00203                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00204"></a>00204                 }
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206         <span class="keywordflow">else</span>
<a name="l00207"></a>00207         {
<a name="l00208"></a>00208                 xyz[0] = btScalar(0.0);
<a name="l00209"></a>00209                 xyz[1] = btAtan2(btGetMatrixElem(mat,7),btGetMatrixElem(mat,8));
<a name="l00210"></a>00210                 xyz[2] = SIMD_HALF_PI;
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00213"></a>00213 }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerZXY(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217         <span class="comment">// rot =  cz*cy-sz*sx*sy    -cx*sz   cz*sy+cy*sz*sx</span>
<a name="l00218"></a>00218         <span class="comment">//        cy*sz+cz*sx*sy     cz*cx   sz*sy-cz*xy*sx</span>
<a name="l00219"></a>00219         <span class="comment">//        -cx*sy              sx     cx*cy</span>
<a name="l00220"></a>00220 
<a name="l00221"></a>00221         btScalar fi = btGetMatrixElem(mat,7);
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00223"></a>00223         {
<a name="l00224"></a>00224                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00225"></a>00225                 {
<a name="l00226"></a>00226                         xyz[0] = btAsin(btGetMatrixElem(mat,7));
<a name="l00227"></a>00227                         xyz[1] = btAtan2(-btGetMatrixElem(mat,6),btGetMatrixElem(mat,8));
<a name="l00228"></a>00228                         xyz[2] = btAtan2(-btGetMatrixElem(mat,1),btGetMatrixElem(mat,4));
<a name="l00229"></a>00229                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00230"></a>00230                 }
<a name="l00231"></a>00231                 <span class="keywordflow">else</span>
<a name="l00232"></a>00232                 {
<a name="l00233"></a>00233                         xyz[0] = -SIMD_HALF_PI;
<a name="l00234"></a>00234                         xyz[1] = btScalar(0.0);
<a name="l00235"></a>00235                         xyz[2] = -btAtan2(btGetMatrixElem(mat,2),btGetMatrixElem(mat,0));
<a name="l00236"></a>00236                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00237"></a>00237                 }
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         <span class="keywordflow">else</span>
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241                 xyz[0] = SIMD_HALF_PI;
<a name="l00242"></a>00242                 xyz[1] = btScalar(0.0);
<a name="l00243"></a>00243                 xyz[2] = btAtan2(btGetMatrixElem(mat,2),btGetMatrixElem(mat,0));
<a name="l00244"></a>00244         }
<a name="l00245"></a>00245         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="keywordtype">bool</span> btGeneric6DofSpring2Constraint::matrixToEulerZYX(<span class="keyword">const</span> btMatrix3x3&amp; mat,btVector3&amp; xyz)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250         <span class="comment">// rot =  cz*cy   cz*sy*sx-cx*sz   sz*sx+cz*cx*sy</span>
<a name="l00251"></a>00251         <span class="comment">//        cy*sz   cz*cx+sz*sy*sx   cx*sz*sy-cz*sx</span>
<a name="l00252"></a>00252         <span class="comment">//        -sy          cy*sx         cy*cx</span>
<a name="l00253"></a>00253 
<a name="l00254"></a>00254         btScalar fi = btGetMatrixElem(mat,6);
<a name="l00255"></a>00255         <span class="keywordflow">if</span> (fi &lt; btScalar(1.0f))
<a name="l00256"></a>00256         {
<a name="l00257"></a>00257                 <span class="keywordflow">if</span> (fi &gt; btScalar(-1.0f))
<a name="l00258"></a>00258                 {
<a name="l00259"></a>00259                         xyz[0] = btAtan2(btGetMatrixElem(mat,7), btGetMatrixElem(mat,8));
<a name="l00260"></a>00260                         xyz[1] = btAsin(-btGetMatrixElem(mat,6));
<a name="l00261"></a>00261                         xyz[2] = btAtan2(btGetMatrixElem(mat,3),btGetMatrixElem(mat,0));
<a name="l00262"></a>00262                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00263"></a>00263                 }
<a name="l00264"></a>00264                 <span class="keywordflow">else</span>
<a name="l00265"></a>00265                 {
<a name="l00266"></a>00266                         xyz[0] = btScalar(0.0);
<a name="l00267"></a>00267                         xyz[1] = SIMD_HALF_PI;
<a name="l00268"></a>00268                         xyz[2] = -btAtan2(btGetMatrixElem(mat,1),btGetMatrixElem(mat,2));
<a name="l00269"></a>00269                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00270"></a>00270                 }
<a name="l00271"></a>00271         }
<a name="l00272"></a>00272         <span class="keywordflow">else</span>
<a name="l00273"></a>00273         {
<a name="l00274"></a>00274                 xyz[0] = btScalar(0.0);
<a name="l00275"></a>00275                 xyz[1] = -SIMD_HALF_PI;
<a name="l00276"></a>00276                 xyz[2] = btAtan2(-btGetMatrixElem(mat,1),-btGetMatrixElem(mat,2));
<a name="l00277"></a>00277         }
<a name="l00278"></a>00278         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00279"></a>00279 }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::calculateAngleInfo()
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283         btMatrix3x3 relative_frame = m_calculatedTransformA.getBasis().inverse()*m_calculatedTransformB.getBasis();
<a name="l00284"></a>00284         <span class="keywordflow">switch</span> (m_rotateOrder)
<a name="l00285"></a>00285         {
<a name="l00286"></a>00286                 <span class="keywordflow">case</span> RO_XYZ : matrixToEulerXYZ(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00287"></a>00287                 <span class="keywordflow">case</span> RO_XZY : matrixToEulerXZY(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00288"></a>00288                 <span class="keywordflow">case</span> RO_YXZ : matrixToEulerYXZ(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00289"></a>00289                 <span class="keywordflow">case</span> RO_YZX : matrixToEulerYZX(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00290"></a>00290                 <span class="keywordflow">case</span> RO_ZXY : matrixToEulerZXY(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00291"></a>00291                 <span class="keywordflow">case</span> RO_ZYX : matrixToEulerZYX(relative_frame,m_calculatedAxisAngleDiff); <span class="keywordflow">break</span>;
<a name="l00292"></a>00292                 <span class="keywordflow">default</span> : btAssert(<span class="keyword">false</span>);
<a name="l00293"></a>00293         }
<a name="l00294"></a>00294         <span class="comment">// in euler angle mode we do not actually constrain the angular velocity</span>
<a name="l00295"></a>00295         <span class="comment">// along the axes axis[0] and axis[2] (although we do use axis[1]) :</span>
<a name="l00296"></a>00296         <span class="comment">//</span>
<a name="l00297"></a>00297         <span class="comment">//    to get                    constrain w2-w1 along           ...not</span>
<a name="l00298"></a>00298         <span class="comment">//    ------                    ---------------------           ------</span>
<a name="l00299"></a>00299         <span class="comment">//    d(angle[0])/dt = 0        ax[1] x ax[2]                   ax[0]</span>
<a name="l00300"></a>00300         <span class="comment">//    d(angle[1])/dt = 0        ax[1]</span>
<a name="l00301"></a>00301         <span class="comment">//    d(angle[2])/dt = 0        ax[0] x ax[1]                   ax[2]</span>
<a name="l00302"></a>00302         <span class="comment">//</span>
<a name="l00303"></a>00303         <span class="comment">// constraining w2-w1 along an axis 'a' means that a'*(w2-w1)=0.</span>
<a name="l00304"></a>00304         <span class="comment">// to prove the result for angle[0], write the expression for angle[0] from</span>
<a name="l00305"></a>00305         <span class="comment">// GetInfo1 then take the derivative. to prove this for angle[2] it is</span>
<a name="l00306"></a>00306         <span class="comment">// easier to take the euler rate expression for d(angle[2])/dt with respect</span>
<a name="l00307"></a>00307         <span class="comment">// to the components of w and set that to 0.</span>
<a name="l00308"></a>00308         <span class="keywordflow">switch</span> (m_rotateOrder)
<a name="l00309"></a>00309         {
<a name="l00310"></a>00310         <span class="keywordflow">case</span> RO_XYZ :
<a name="l00311"></a>00311                 {
<a name="l00312"></a>00312                         <span class="comment">//Is this the "line of nodes" calculation choosing planes YZ (B coordinate system) and xy (A coordinate system)? (http://en.wikipedia.org/wiki/Euler_angles)</span>
<a name="l00313"></a>00313                         <span class="comment">//The two planes are non-homologous, so this is a Tait–Bryan angle formalism and not a proper Euler</span>
<a name="l00314"></a>00314                         <span class="comment">//Extrinsic rotations are equal to the reversed order intrinsic rotations so the above xyz extrinsic rotations (axes are fixed) are the same as the zy'x" intrinsic rotations (axes are refreshed after each rotation)</span>
<a name="l00315"></a>00315                         <span class="comment">//that is why xy and YZ planes are chosen (this will describe a zy'x" intrinsic rotation) (see the figure on the left at http://en.wikipedia.org/wiki/Euler_angles under Tait–Bryan angles)</span>
<a name="l00316"></a>00316                         <span class="comment">// x' = Nperp = N.cross(axis2)</span>
<a name="l00317"></a>00317                         <span class="comment">// y' = N = axis2.cross(axis0)  </span>
<a name="l00318"></a>00318                         <span class="comment">// z' = z</span>
<a name="l00319"></a>00319                         <span class="comment">//</span>
<a name="l00320"></a>00320                         <span class="comment">// x" = X</span>
<a name="l00321"></a>00321                         <span class="comment">// y" = y'</span>
<a name="l00322"></a>00322                         <span class="comment">// z" = ??</span>
<a name="l00323"></a>00323                         <span class="comment">//in other words:</span>
<a name="l00324"></a>00324                         <span class="comment">//first rotate around z</span>
<a name="l00325"></a>00325                         <span class="comment">//second rotate around y'= z.cross(X)</span>
<a name="l00326"></a>00326                         <span class="comment">//third rotate around x" = X</span>
<a name="l00327"></a>00327                         <span class="comment">//Original XYZ extrinsic rotation order. </span>
<a name="l00328"></a>00328                         <span class="comment">//Planes: xy and YZ normals: z, X.  Plane intersection (N) is z.cross(X)</span>
<a name="l00329"></a>00329                         btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
<a name="l00330"></a>00330                         btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);
<a name="l00331"></a>00331                         m_calculatedAxis[1] = axis2.cross(axis0);
<a name="l00332"></a>00332                         m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
<a name="l00333"></a>00333                         m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);
<a name="l00334"></a>00334                         <span class="keywordflow">break</span>;
<a name="l00335"></a>00335                 }
<a name="l00336"></a>00336         <span class="keywordflow">case</span> RO_XZY :
<a name="l00337"></a>00337                 {
<a name="l00338"></a>00338                         <span class="comment">//planes: xz,ZY normals: y, X</span>
<a name="l00339"></a>00339                         <span class="comment">//first rotate around y</span>
<a name="l00340"></a>00340                         <span class="comment">//second rotate around z'= y.cross(X)</span>
<a name="l00341"></a>00341                         <span class="comment">//third rotate around x" = X</span>
<a name="l00342"></a>00342                         btVector3 axis0 = m_calculatedTransformB.getBasis().getColumn(0);
<a name="l00343"></a>00343                         btVector3 axis1 = m_calculatedTransformA.getBasis().getColumn(1);
<a name="l00344"></a>00344                         m_calculatedAxis[2] = axis0.cross(axis1);
<a name="l00345"></a>00345                         m_calculatedAxis[0] = axis1.cross(m_calculatedAxis[2]);
<a name="l00346"></a>00346                         m_calculatedAxis[1] = m_calculatedAxis[2].cross(axis0);
<a name="l00347"></a>00347                         <span class="keywordflow">break</span>;
<a name="l00348"></a>00348                 }
<a name="l00349"></a>00349         <span class="keywordflow">case</span> RO_YXZ :
<a name="l00350"></a>00350                 {
<a name="l00351"></a>00351                         <span class="comment">//planes: yx,XZ normals: z, Y</span>
<a name="l00352"></a>00352                         <span class="comment">//first rotate around z</span>
<a name="l00353"></a>00353                         <span class="comment">//second rotate around x'= z.cross(Y)</span>
<a name="l00354"></a>00354                         <span class="comment">//third rotate around y" = Y</span>
<a name="l00355"></a>00355                         btVector3 axis1 = m_calculatedTransformB.getBasis().getColumn(1);
<a name="l00356"></a>00356                         btVector3 axis2 = m_calculatedTransformA.getBasis().getColumn(2);
<a name="l00357"></a>00357                         m_calculatedAxis[0] = axis1.cross(axis2);
<a name="l00358"></a>00358                         m_calculatedAxis[1] = axis2.cross(m_calculatedAxis[0]);
<a name="l00359"></a>00359                         m_calculatedAxis[2] = m_calculatedAxis[0].cross(axis1);
<a name="l00360"></a>00360                         <span class="keywordflow">break</span>;
<a name="l00361"></a>00361                 }
<a name="l00362"></a>00362         <span class="keywordflow">case</span> RO_YZX :
<a name="l00363"></a>00363                 {
<a name="l00364"></a>00364                         <span class="comment">//planes: yz,ZX normals: x, Y</span>
<a name="l00365"></a>00365                         <span class="comment">//first rotate around x</span>
<a name="l00366"></a>00366                         <span class="comment">//second rotate around z'= x.cross(Y)</span>
<a name="l00367"></a>00367                         <span class="comment">//third rotate around y" = Y</span>
<a name="l00368"></a>00368                         btVector3 axis0 = m_calculatedTransformA.getBasis().getColumn(0);
<a name="l00369"></a>00369                         btVector3 axis1 = m_calculatedTransformB.getBasis().getColumn(1);
<a name="l00370"></a>00370                         m_calculatedAxis[2] = axis0.cross(axis1);
<a name="l00371"></a>00371                         m_calculatedAxis[0] = axis1.cross(m_calculatedAxis[2]);
<a name="l00372"></a>00372                         m_calculatedAxis[1] = m_calculatedAxis[2].cross(axis0);
<a name="l00373"></a>00373                         <span class="keywordflow">break</span>;
<a name="l00374"></a>00374                 }
<a name="l00375"></a>00375         <span class="keywordflow">case</span> RO_ZXY :
<a name="l00376"></a>00376                 {
<a name="l00377"></a>00377                         <span class="comment">//planes: zx,XY normals: y, Z</span>
<a name="l00378"></a>00378                         <span class="comment">//first rotate around y</span>
<a name="l00379"></a>00379                         <span class="comment">//second rotate around x'= y.cross(Z)</span>
<a name="l00380"></a>00380                         <span class="comment">//third rotate around z" = Z</span>
<a name="l00381"></a>00381                         btVector3 axis1 = m_calculatedTransformA.getBasis().getColumn(1);
<a name="l00382"></a>00382                         btVector3 axis2 = m_calculatedTransformB.getBasis().getColumn(2);
<a name="l00383"></a>00383                         m_calculatedAxis[0] = axis1.cross(axis2);
<a name="l00384"></a>00384                         m_calculatedAxis[1] = axis2.cross(m_calculatedAxis[0]);
<a name="l00385"></a>00385                         m_calculatedAxis[2] = m_calculatedAxis[0].cross(axis1);
<a name="l00386"></a>00386                         <span class="keywordflow">break</span>;
<a name="l00387"></a>00387                 }
<a name="l00388"></a>00388         <span class="keywordflow">case</span> RO_ZYX :
<a name="l00389"></a>00389                 {
<a name="l00390"></a>00390                         <span class="comment">//planes: zy,YX normals: x, Z</span>
<a name="l00391"></a>00391                         <span class="comment">//first rotate around x</span>
<a name="l00392"></a>00392                         <span class="comment">//second rotate around y' = x.cross(Z)</span>
<a name="l00393"></a>00393                         <span class="comment">//third rotate around z" = Z</span>
<a name="l00394"></a>00394                         btVector3 axis0 = m_calculatedTransformA.getBasis().getColumn(0);
<a name="l00395"></a>00395                         btVector3 axis2 = m_calculatedTransformB.getBasis().getColumn(2);
<a name="l00396"></a>00396                         m_calculatedAxis[1] = axis2.cross(axis0);
<a name="l00397"></a>00397                         m_calculatedAxis[0] = m_calculatedAxis[1].cross(axis2);
<a name="l00398"></a>00398                         m_calculatedAxis[2] = axis0.cross(m_calculatedAxis[1]);
<a name="l00399"></a>00399                         <span class="keywordflow">break</span>;
<a name="l00400"></a>00400                 }
<a name="l00401"></a>00401         <span class="keywordflow">default</span>:
<a name="l00402"></a>00402                 btAssert(<span class="keyword">false</span>);
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         m_calculatedAxis[0].normalize();
<a name="l00406"></a>00406         m_calculatedAxis[1].normalize();
<a name="l00407"></a>00407         m_calculatedAxis[2].normalize();
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::calculateTransforms()
<a name="l00412"></a>00412 {
<a name="l00413"></a>00413         calculateTransforms(m_rbA.getCenterOfMassTransform(),m_rbB.getCenterOfMassTransform());
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::calculateTransforms(<span class="keyword">const</span> btTransform&amp; transA,<span class="keyword">const</span> btTransform&amp; transB)
<a name="l00417"></a>00417 {
<a name="l00418"></a>00418         m_calculatedTransformA = transA * m_frameInA;
<a name="l00419"></a>00419         m_calculatedTransformB = transB * m_frameInB;
<a name="l00420"></a>00420         calculateLinearInfo();
<a name="l00421"></a>00421         calculateAngleInfo();
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         btScalar miA = getRigidBodyA().getInvMass();
<a name="l00424"></a>00424         btScalar miB = getRigidBodyB().getInvMass();
<a name="l00425"></a>00425         m_hasStaticBody = (miA &lt; SIMD_EPSILON) || (miB &lt; SIMD_EPSILON);
<a name="l00426"></a>00426         btScalar miS = miA + miB;
<a name="l00427"></a>00427         <span class="keywordflow">if</span>(miS &gt; btScalar(0.f))
<a name="l00428"></a>00428         {
<a name="l00429"></a>00429                 m_factA = miB / miS;
<a name="l00430"></a>00430         }
<a name="l00431"></a>00431         <span class="keywordflow">else</span> 
<a name="l00432"></a>00432         {
<a name="l00433"></a>00433                 m_factA = btScalar(0.5f);
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435         m_factB = btScalar(1.0f) - m_factA;
<a name="l00436"></a>00436 }
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::testAngularLimitMotor(<span class="keywordtype">int</span> axis_index)
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441         btScalar <a class="code" href="group__gtx__vector__angle.html#gb57ebeaf612eb26ab8e47e80b9af2678">angle</a> = m_calculatedAxisAngleDiff[axis_index];
<a name="l00442"></a>00442         angle = btAdjustAngleToLimits(angle, m_angularLimits[axis_index].<a class="code" href="classbt_rotational_limit_motor.html#57ff414e1856d661d81b797702c4f986" title="joint limit">m_loLimit</a>, m_angularLimits[axis_index].<a class="code" href="classbt_rotational_limit_motor.html#3201531c631a779615146a373840239c" title="joint limit">m_hiLimit</a>);
<a name="l00443"></a>00443         m_angularLimits[axis_index].m_currentPosition = angle;
<a name="l00444"></a>00444         m_angularLimits[axis_index].testLimitValue(angle);
<a name="l00445"></a>00445 }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::getInfo1 (btConstraintInfo1* info)
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450         <span class="comment">//prepare constraint</span>
<a name="l00451"></a>00451         calculateTransforms(m_rbA.getCenterOfMassTransform(),m_rbB.getCenterOfMassTransform());
<a name="l00452"></a>00452         info-&gt;m_numConstraintRows = 0;
<a name="l00453"></a>00453         info-&gt;nub = 0;
<a name="l00454"></a>00454         <span class="keywordtype">int</span> i;
<a name="l00455"></a>00455         <span class="comment">//test linear limits</span>
<a name="l00456"></a>00456         <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
<a name="l00457"></a>00457         {
<a name="l00458"></a>00458                      <span class="keywordflow">if</span> (m_linearLimits.m_currentLimit[i]==4) info-&gt;m_numConstraintRows += 2;
<a name="l00459"></a>00459                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_linearLimits.m_currentLimit[i]!=0) info-&gt;m_numConstraintRows += 1;
<a name="l00460"></a>00460                 <span class="keywordflow">if</span> (m_linearLimits.m_enableMotor[i] ) info-&gt;m_numConstraintRows += 1;
<a name="l00461"></a>00461                 <span class="keywordflow">if</span> (m_linearLimits.m_enableSpring[i]) info-&gt;m_numConstraintRows += 1;
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463         <span class="comment">//test angular limits</span>
<a name="l00464"></a>00464         <span class="keywordflow">for</span> (i=0;i&lt;3 ;i++ )
<a name="l00465"></a>00465         {
<a name="l00466"></a>00466                 testAngularLimitMotor(i);
<a name="l00467"></a>00467                      <span class="keywordflow">if</span> (m_angularLimits[i].<a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a>==4) info-&gt;m_numConstraintRows += 2;
<a name="l00468"></a>00468                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_angularLimits[i].<a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a>!=0) info-&gt;m_numConstraintRows += 1;
<a name="l00469"></a>00469                 <span class="keywordflow">if</span> (m_angularLimits[i].m_enableMotor ) info-&gt;m_numConstraintRows += 1;
<a name="l00470"></a>00470                 <span class="keywordflow">if</span> (m_angularLimits[i].m_enableSpring) info-&gt;m_numConstraintRows += 1;
<a name="l00471"></a>00471         }
<a name="l00472"></a>00472 }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::getInfo2 (btConstraintInfo2* info)
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477         <span class="keyword">const</span> btTransform&amp; transA = m_rbA.getCenterOfMassTransform();
<a name="l00478"></a>00478         <span class="keyword">const</span> btTransform&amp; transB = m_rbB.getCenterOfMassTransform();
<a name="l00479"></a>00479         <span class="keyword">const</span> btVector3&amp; linVelA = m_rbA.getLinearVelocity();
<a name="l00480"></a>00480         <span class="keyword">const</span> btVector3&amp; linVelB = m_rbB.getLinearVelocity();
<a name="l00481"></a>00481         <span class="keyword">const</span> btVector3&amp; angVelA = m_rbA.getAngularVelocity();
<a name="l00482"></a>00482         <span class="keyword">const</span> btVector3&amp; angVelB = m_rbB.getAngularVelocity();
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="comment">// for stability better to solve angular limits first</span>
<a name="l00485"></a>00485         <span class="keywordtype">int</span> <a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a> = setAngularLimits(info, 0,transA,transB,linVelA,linVelB,angVelA,angVelB);
<a name="l00486"></a>00486         setLinearLimits(info, row, transA,transB,linVelA,linVelB,angVelA,angVelB);
<a name="l00487"></a>00487 }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keywordtype">int</span> btGeneric6DofSpring2Constraint::setLinearLimits(btConstraintInfo2* info, <span class="keywordtype">int</span> <a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>, <span class="keyword">const</span> btTransform&amp; transA,<span class="keyword">const</span> btTransform&amp; transB,<span class="keyword">const</span> btVector3&amp; linVelA,<span class="keyword">const</span> btVector3&amp; linVelB,<span class="keyword">const</span> btVector3&amp; angVelA,<span class="keyword">const</span> btVector3&amp; angVelB)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492         <span class="comment">//solve linear limits</span>
<a name="l00493"></a>00493         btRotationalLimitMotor2 limot;
<a name="l00494"></a>00494         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;3 ;i++ )
<a name="l00495"></a>00495         {
<a name="l00496"></a>00496                 <span class="keywordflow">if</span>(m_linearLimits.m_currentLimit[i] || m_linearLimits.m_enableMotor[i] || m_linearLimits.m_enableSpring[i])
<a name="l00497"></a>00497                 { <span class="comment">// re-use rotational motor code</span>
<a name="l00498"></a>00498                         limot.m_bounce                 = m_linearLimits.m_bounce[i];
<a name="l00499"></a>00499                         limot.m_currentLimit           = m_linearLimits.m_currentLimit[i];
<a name="l00500"></a>00500                         limot.m_currentPosition        = m_linearLimits.m_currentLinearDiff[i];
<a name="l00501"></a>00501                         limot.m_currentLimitError      = m_linearLimits.m_currentLimitError[i];
<a name="l00502"></a>00502                         limot.m_currentLimitErrorHi    = m_linearLimits.m_currentLimitErrorHi[i];
<a name="l00503"></a>00503                         limot.m_enableMotor            = m_linearLimits.m_enableMotor[i];
<a name="l00504"></a>00504                         limot.m_servoMotor             = m_linearLimits.m_servoMotor[i];
<a name="l00505"></a>00505                         limot.m_servoTarget            = m_linearLimits.m_servoTarget[i];
<a name="l00506"></a>00506                         limot.m_enableSpring           = m_linearLimits.m_enableSpring[i];
<a name="l00507"></a>00507                         limot.m_springStiffness        = m_linearLimits.m_springStiffness[i];
<a name="l00508"></a>00508                         limot.m_springStiffnessLimited = m_linearLimits.m_springStiffnessLimited[i];
<a name="l00509"></a>00509                         limot.m_springDamping          = m_linearLimits.m_springDamping[i];
<a name="l00510"></a>00510                         limot.m_springDampingLimited   = m_linearLimits.m_springDampingLimited[i];
<a name="l00511"></a>00511                         limot.m_equilibriumPoint       = m_linearLimits.m_equilibriumPoint[i];
<a name="l00512"></a>00512                         limot.m_hiLimit                = m_linearLimits.m_upperLimit[i];
<a name="l00513"></a>00513                         limot.m_loLimit                = m_linearLimits.m_lowerLimit[i];
<a name="l00514"></a>00514                         limot.m_maxMotorForce          = m_linearLimits.m_maxMotorForce[i];
<a name="l00515"></a>00515                         limot.m_targetVelocity         = m_linearLimits.m_targetVelocity[i];
<a name="l00516"></a>00516                         btVector3 <a class="code" href="group__gtc__quaternion.html#g5c243b588291c790bf1b5ec3f0f08d1b">axis</a> = m_calculatedTransformA.getBasis().getColumn(i);
<a name="l00517"></a>00517                         <span class="keywordtype">int</span> flags = m_flags &gt;&gt; (i * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00518"></a>00518                         limot.m_stopCFM  = (flags &amp; BT_6DOF_FLAGS_CFM_STOP2) ? m_linearLimits.m_stopCFM[i] : info-&gt;cfm[0];
<a name="l00519"></a>00519                         limot.m_stopERP  = (flags &amp; BT_6DOF_FLAGS_ERP_STOP2) ? m_linearLimits.m_stopERP[i] : info-&gt;erp;
<a name="l00520"></a>00520                         limot.m_motorCFM = (flags &amp; BT_6DOF_FLAGS_CFM_MOTO2) ? m_linearLimits.m_motorCFM[i] : info-&gt;cfm[0];
<a name="l00521"></a>00521                         limot.m_motorERP = (flags &amp; BT_6DOF_FLAGS_ERP_MOTO2) ? m_linearLimits.m_motorERP[i] : info-&gt;erp;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523                         <span class="comment">//rotAllowed is a bit of a magic from the original 6dof. The calculation of it here is something that imitates the original behavior as much as possible.</span>
<a name="l00524"></a>00524                         <span class="keywordtype">int</span> indx1 = (i + 1) % 3;
<a name="l00525"></a>00525                         <span class="keywordtype">int</span> indx2 = (i + 2) % 3;
<a name="l00526"></a>00526                         <span class="keywordtype">int</span> rotAllowed = 1; <span class="comment">// rotations around orthos to current axis (it is used only when one of the body is static)</span>
<a name="l00527"></a>00527 <span class="preprocessor">                        #define D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION 1.0e-3</span>
<a name="l00528"></a>00528 <span class="preprocessor"></span>                        <span class="keywordtype">bool</span> indx1Violated = m_angularLimits[indx1].m_currentLimit == 1 ||
<a name="l00529"></a>00529                                 m_angularLimits[indx1].m_currentLimit == 2 ||
<a name="l00530"></a>00530                                 ( m_angularLimits[indx1].m_currentLimit == 3 &amp;&amp; ( m_angularLimits[indx1].m_currentLimitError &lt; -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx1].m_currentLimitError &gt; D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION ) ) ||
<a name="l00531"></a>00531                                 ( m_angularLimits[indx1].m_currentLimit == 4 &amp;&amp; ( m_angularLimits[indx1].m_currentLimitError &lt; -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx1].m_currentLimitErrorHi &gt; D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION ) );
<a name="l00532"></a>00532                         <span class="keywordtype">bool</span> indx2Violated = m_angularLimits[indx2].m_currentLimit == 1 ||
<a name="l00533"></a>00533                                 m_angularLimits[indx2].m_currentLimit == 2 ||
<a name="l00534"></a>00534                                 ( m_angularLimits[indx2].m_currentLimit == 3 &amp;&amp; ( m_angularLimits[indx2].m_currentLimitError &lt; -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx2].m_currentLimitError &gt; D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION ) ) ||
<a name="l00535"></a>00535                                 ( m_angularLimits[indx2].m_currentLimit == 4 &amp;&amp; ( m_angularLimits[indx2].m_currentLimitError &lt; -D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION || m_angularLimits[indx2].m_currentLimitErrorHi &gt; D6_LIMIT_ERROR_THRESHOLD_FOR_ROTATION ) );
<a name="l00536"></a>00536                         <span class="keywordflow">if</span>( indx1Violated &amp;&amp; indx2Violated )
<a name="l00537"></a>00537                         {
<a name="l00538"></a>00538                                 rotAllowed = 0;
<a name="l00539"></a>00539                         }
<a name="l00540"></a>00540                         row += get_limit_motor_info2(&amp;limot, transA,transB,linVelA,linVelB,angVelA,angVelB, info, row, axis, 0, rotAllowed);
<a name="l00541"></a>00541 
<a name="l00542"></a>00542                 }
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544         <span class="keywordflow">return</span> row;
<a name="l00545"></a>00545 }
<a name="l00546"></a>00546 
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="keywordtype">int</span> btGeneric6DofSpring2Constraint::setAngularLimits(btConstraintInfo2 *info, <span class="keywordtype">int</span> row_offset, <span class="keyword">const</span> btTransform&amp; transA,<span class="keyword">const</span> btTransform&amp; transB,<span class="keyword">const</span> btVector3&amp; linVelA,<span class="keyword">const</span> btVector3&amp; linVelB,<span class="keyword">const</span> btVector3&amp; angVelA,<span class="keyword">const</span> btVector3&amp; angVelB)
<a name="l00550"></a>00550 {
<a name="l00551"></a>00551         <span class="keywordtype">int</span> row = row_offset;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         <span class="comment">//order of rotational constraint rows</span>
<a name="l00554"></a>00554         <span class="keywordtype">int</span> cIdx[] = {0, 1, 2};
<a name="l00555"></a>00555         <span class="keywordflow">switch</span>(m_rotateOrder)
<a name="l00556"></a>00556         {
<a name="l00557"></a>00557                 <span class="keywordflow">case</span> RO_XYZ : cIdx[0] = 0; cIdx[1] = 1; cIdx[2] = 2; <span class="keywordflow">break</span>;
<a name="l00558"></a>00558                 <span class="keywordflow">case</span> RO_XZY : cIdx[0] = 0; cIdx[1] = 2; cIdx[2] = 1; <span class="keywordflow">break</span>;
<a name="l00559"></a>00559                 <span class="keywordflow">case</span> RO_YXZ : cIdx[0] = 1; cIdx[1] = 0; cIdx[2] = 2; <span class="keywordflow">break</span>;
<a name="l00560"></a>00560                 <span class="keywordflow">case</span> RO_YZX : cIdx[0] = 1; cIdx[1] = 2; cIdx[2] = 0; <span class="keywordflow">break</span>;
<a name="l00561"></a>00561                 <span class="keywordflow">case</span> RO_ZXY : cIdx[0] = 2; cIdx[1] = 0; cIdx[2] = 1; <span class="keywordflow">break</span>;
<a name="l00562"></a>00562                 <span class="keywordflow">case</span> RO_ZYX : cIdx[0] = 2; cIdx[1] = 1; cIdx[2] = 0; <span class="keywordflow">break</span>;
<a name="l00563"></a>00563                 <span class="keywordflow">default</span> : btAssert(<span class="keyword">false</span>);
<a name="l00564"></a>00564         }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; 3 ; ii++ )
<a name="l00567"></a>00567         {
<a name="l00568"></a>00568                 <span class="keywordtype">int</span> i = cIdx[ii];
<a name="l00569"></a>00569                 <span class="keywordflow">if</span>(m_angularLimits[i].<a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a> || m_angularLimits[i].m_enableMotor || m_angularLimits[i].m_enableSpring)
<a name="l00570"></a>00570                 {
<a name="l00571"></a>00571                         btVector3 axis = getAxis(i);
<a name="l00572"></a>00572                         <span class="keywordtype">int</span> flags = m_flags &gt;&gt; ((i + 3) * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00573"></a>00573                         <span class="keywordflow">if</span>(!(flags &amp; BT_6DOF_FLAGS_CFM_STOP2))
<a name="l00574"></a>00574                         {
<a name="l00575"></a>00575                                 m_angularLimits[i].m_stopCFM = info-&gt;cfm[0];
<a name="l00576"></a>00576                         }
<a name="l00577"></a>00577                         <span class="keywordflow">if</span>(!(flags &amp; BT_6DOF_FLAGS_ERP_STOP2))
<a name="l00578"></a>00578                         {
<a name="l00579"></a>00579                                 m_angularLimits[i].m_stopERP = info-&gt;erp;
<a name="l00580"></a>00580                         }
<a name="l00581"></a>00581                         <span class="keywordflow">if</span>(!(flags &amp; BT_6DOF_FLAGS_CFM_MOTO2))
<a name="l00582"></a>00582                         {
<a name="l00583"></a>00583                                 m_angularLimits[i].m_motorCFM = info-&gt;cfm[0];
<a name="l00584"></a>00584                         }
<a name="l00585"></a>00585                         <span class="keywordflow">if</span>(!(flags &amp; BT_6DOF_FLAGS_ERP_MOTO2))
<a name="l00586"></a>00586                         {
<a name="l00587"></a>00587                                 m_angularLimits[i].m_motorERP = info-&gt;erp;
<a name="l00588"></a>00588                         }
<a name="l00589"></a>00589                         row += get_limit_motor_info2(&amp;m_angularLimits[i],transA,transB,linVelA,linVelB,angVelA,angVelB, info,row,axis,1);
<a name="l00590"></a>00590                 }
<a name="l00591"></a>00591         }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593         <span class="keywordflow">return</span> row;
<a name="l00594"></a>00594 }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setFrames(<span class="keyword">const</span> btTransform&amp; frameA, <span class="keyword">const</span> btTransform&amp; frameB)
<a name="l00598"></a>00598 {
<a name="l00599"></a>00599         m_frameInA = frameA;
<a name="l00600"></a>00600         m_frameInB = frameB;
<a name="l00601"></a>00601         buildJacobian();
<a name="l00602"></a>00602         calculateTransforms();
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::calculateLinearInfo()
<a name="l00607"></a>00607 {
<a name="l00608"></a>00608         m_calculatedLinearDiff = m_calculatedTransformB.getOrigin() - m_calculatedTransformA.getOrigin();
<a name="l00609"></a>00609         m_calculatedLinearDiff = m_calculatedTransformA.getBasis().inverse() * m_calculatedLinearDiff;
<a name="l00610"></a>00610         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00611"></a>00611         {
<a name="l00612"></a>00612                 m_linearLimits.m_currentLinearDiff[i] = m_calculatedLinearDiff[i];
<a name="l00613"></a>00613                 m_linearLimits.testLimitValue(i, m_calculatedLinearDiff[i]);
<a name="l00614"></a>00614         }
<a name="l00615"></a>00615 }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::calculateJacobi(btRotationalLimitMotor2 * limot, <span class="keyword">const</span> btTransform&amp; transA,<span class="keyword">const</span> btTransform&amp; transB, btConstraintInfo2 *info, <span class="keywordtype">int</span> srow, btVector3&amp; ax1, <span class="keywordtype">int</span> rotational, <span class="keywordtype">int</span> rotAllowed)
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619         btScalar *J1 = rotational ? info-&gt;m_J1angularAxis : info-&gt;m_J1linearAxis;
<a name="l00620"></a>00620         btScalar *J2 = rotational ? info-&gt;m_J2angularAxis : info-&gt;m_J2linearAxis;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622         J1[srow+0] = ax1[0];
<a name="l00623"></a>00623         J1[srow+1] = ax1[1];
<a name="l00624"></a>00624         J1[srow+2] = ax1[2];
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         J2[srow+0] = -ax1[0];
<a name="l00627"></a>00627         J2[srow+1] = -ax1[1];
<a name="l00628"></a>00628         J2[srow+2] = -ax1[2];
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="keywordflow">if</span>(!rotational)
<a name="l00631"></a>00631         {
<a name="l00632"></a>00632                 btVector3 tmpA, tmpB, relA, relB;
<a name="l00633"></a>00633                 <span class="comment">// get vector from bodyB to frameB in WCS</span>
<a name="l00634"></a>00634                 relB = m_calculatedTransformB.getOrigin() - transB.getOrigin();
<a name="l00635"></a>00635                 <span class="comment">// same for bodyA</span>
<a name="l00636"></a>00636                 relA = m_calculatedTransformA.getOrigin() - transA.getOrigin();
<a name="l00637"></a>00637                 tmpA = relA.cross(ax1);
<a name="l00638"></a>00638                 tmpB = relB.cross(ax1);
<a name="l00639"></a>00639                 <span class="keywordflow">if</span>(m_hasStaticBody &amp;&amp; (!rotAllowed))
<a name="l00640"></a>00640                 {
<a name="l00641"></a>00641                         tmpA *= m_factA;
<a name="l00642"></a>00642                         tmpB *= m_factB;
<a name="l00643"></a>00643                 }
<a name="l00644"></a>00644                 <span class="keywordtype">int</span> i;
<a name="l00645"></a>00645                 <span class="keywordflow">for</span> (i=0; i&lt;3; i++) info-&gt;m_J1angularAxis[srow+i] = tmpA[i];
<a name="l00646"></a>00646                 for (i=0; i&lt;3; i++) info-&gt;m_J2angularAxis[srow+i] = -tmpB[i];
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 }
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="keywordtype">int</span> btGeneric6DofSpring2Constraint::get_limit_motor_info2(
<a name="l00652"></a>00652         btRotationalLimitMotor2 * limot,
<a name="l00653"></a>00653         <span class="keyword">const</span> btTransform&amp; transA,<span class="keyword">const</span> btTransform&amp; transB,<span class="keyword">const</span> btVector3&amp; linVelA,<span class="keyword">const</span> btVector3&amp; linVelB,<span class="keyword">const</span> btVector3&amp; angVelA,<span class="keyword">const</span> btVector3&amp; angVelB,
<a name="l00654"></a>00654         btConstraintInfo2 *info, <span class="keywordtype">int</span> row, btVector3&amp; ax1, <span class="keywordtype">int</span> rotational,<span class="keywordtype">int</span> rotAllowed)
<a name="l00655"></a>00655 {
<a name="l00656"></a>00656         <span class="keywordtype">int</span> count = 0;
<a name="l00657"></a>00657         <span class="keywordtype">int</span> srow = row * info-&gt;rowskip;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         <span class="keywordflow">if</span> (limot-&gt;m_currentLimit==4) 
<a name="l00660"></a>00660         {
<a name="l00661"></a>00661                 btScalar vel = rotational ? angVelA.dot(ax1) - angVelB.dot(ax1) : linVelA.dot(ax1) - linVelB.dot(ax1);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00664"></a>00664                 info-&gt;m_constraintError[srow] = info-&gt;fps * limot-&gt;m_stopERP * limot-&gt;m_currentLimitError * (rotational ? -1 : 1);
<a name="l00665"></a>00665                 <span class="keywordflow">if</span> (rotational) {
<a name="l00666"></a>00666                         <span class="keywordflow">if</span> (info-&gt;m_constraintError[srow]-vel*limot-&gt;m_stopERP &gt; 0) {
<a name="l00667"></a>00667                                 btScalar bounceerror = -limot-&gt;m_bounce* vel;
<a name="l00668"></a>00668                                 <span class="keywordflow">if</span> (bounceerror &gt; info-&gt;m_constraintError[srow]) info-&gt;m_constraintError[srow] = bounceerror;
<a name="l00669"></a>00669                         }
<a name="l00670"></a>00670                 } <span class="keywordflow">else</span> {
<a name="l00671"></a>00671                         <span class="keywordflow">if</span> (info-&gt;m_constraintError[srow]-vel*limot-&gt;m_stopERP &lt; 0) {
<a name="l00672"></a>00672                                 btScalar bounceerror = -limot-&gt;m_bounce* vel;
<a name="l00673"></a>00673                                 <span class="keywordflow">if</span> (bounceerror &lt; info-&gt;m_constraintError[srow]) info-&gt;m_constraintError[srow] = bounceerror;
<a name="l00674"></a>00674                         }
<a name="l00675"></a>00675                 }
<a name="l00676"></a>00676                 info-&gt;m_lowerLimit[srow] = rotational ? 0 : -SIMD_INFINITY;
<a name="l00677"></a>00677                 info-&gt;m_upperLimit[srow] = rotational ? SIMD_INFINITY : 0;
<a name="l00678"></a>00678                 info-&gt;cfm[srow] = limot-&gt;m_stopCFM;
<a name="l00679"></a>00679                 srow += info-&gt;rowskip;
<a name="l00680"></a>00680                 ++count;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00683"></a>00683                 info-&gt;m_constraintError[srow] = info-&gt;fps * limot-&gt;m_stopERP * limot-&gt;m_currentLimitErrorHi * (rotational ? -1 : 1);
<a name="l00684"></a>00684                 <span class="keywordflow">if</span> (rotational) {
<a name="l00685"></a>00685                         <span class="keywordflow">if</span> (info-&gt;m_constraintError[srow]-vel*limot-&gt;m_stopERP &lt; 0) {
<a name="l00686"></a>00686                                 btScalar bounceerror = -limot-&gt;m_bounce* vel;
<a name="l00687"></a>00687                                 <span class="keywordflow">if</span> (bounceerror &lt; info-&gt;m_constraintError[srow]) info-&gt;m_constraintError[srow] = bounceerror;
<a name="l00688"></a>00688                         }
<a name="l00689"></a>00689                 } <span class="keywordflow">else</span> {
<a name="l00690"></a>00690                         <span class="keywordflow">if</span> (info-&gt;m_constraintError[srow]-vel*limot-&gt;m_stopERP &gt; 0) {
<a name="l00691"></a>00691                                 btScalar bounceerror = -limot-&gt;m_bounce* vel;
<a name="l00692"></a>00692                                 <span class="keywordflow">if</span> (bounceerror &gt; info-&gt;m_constraintError[srow]) info-&gt;m_constraintError[srow] = bounceerror;
<a name="l00693"></a>00693                         }
<a name="l00694"></a>00694                 }
<a name="l00695"></a>00695                 info-&gt;m_lowerLimit[srow] = rotational ? -SIMD_INFINITY : 0;
<a name="l00696"></a>00696                 info-&gt;m_upperLimit[srow] = rotational ? 0 : SIMD_INFINITY;
<a name="l00697"></a>00697                 info-&gt;cfm[srow] = limot-&gt;m_stopCFM;
<a name="l00698"></a>00698                 srow += info-&gt;rowskip;
<a name="l00699"></a>00699                 ++count;
<a name="l00700"></a>00700         } <span class="keywordflow">else</span>
<a name="l00701"></a>00701         <span class="keywordflow">if</span> (limot-&gt;m_currentLimit==3) 
<a name="l00702"></a>00702         {
<a name="l00703"></a>00703                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00704"></a>00704                 info-&gt;m_constraintError[srow] = info-&gt;fps * limot-&gt;m_stopERP * limot-&gt;m_currentLimitError * (rotational ? -1 : 1);
<a name="l00705"></a>00705                 info-&gt;m_lowerLimit[srow] = -SIMD_INFINITY;
<a name="l00706"></a>00706                 info-&gt;m_upperLimit[srow] = SIMD_INFINITY;
<a name="l00707"></a>00707                 info-&gt;cfm[srow] = limot-&gt;m_stopCFM;
<a name="l00708"></a>00708                 srow += info-&gt;rowskip;
<a name="l00709"></a>00709                 ++count;
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         <span class="keywordflow">if</span> (limot-&gt;m_enableMotor &amp;&amp; !limot-&gt;m_servoMotor)
<a name="l00713"></a>00713         {
<a name="l00714"></a>00714                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00715"></a>00715                 btScalar tag_vel = rotational ? limot-&gt;m_targetVelocity : -limot-&gt;m_targetVelocity;
<a name="l00716"></a>00716                 btScalar mot_fact = getMotorFactor(limot-&gt;m_currentPosition, 
<a name="l00717"></a>00717                         limot-&gt;m_loLimit,
<a name="l00718"></a>00718                         limot-&gt;m_hiLimit,
<a name="l00719"></a>00719                         tag_vel,
<a name="l00720"></a>00720                         info-&gt;fps * limot-&gt;m_motorERP);
<a name="l00721"></a>00721                 info-&gt;m_constraintError[srow] = mot_fact * limot-&gt;m_targetVelocity;
<a name="l00722"></a>00722                 info-&gt;m_lowerLimit[srow] = -limot-&gt;m_maxMotorForce;
<a name="l00723"></a>00723                 info-&gt;m_upperLimit[srow] = limot-&gt;m_maxMotorForce;
<a name="l00724"></a>00724                 info-&gt;cfm[srow] = limot-&gt;m_motorCFM;
<a name="l00725"></a>00725                 srow += info-&gt;rowskip;
<a name="l00726"></a>00726                 ++count;
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729         <span class="keywordflow">if</span> (limot-&gt;m_enableMotor &amp;&amp; limot-&gt;m_servoMotor)
<a name="l00730"></a>00730         {
<a name="l00731"></a>00731                 btScalar error = limot-&gt;m_currentPosition - limot-&gt;m_servoTarget;
<a name="l00732"></a>00732                 btScalar curServoTarget = limot-&gt;m_servoTarget;
<a name="l00733"></a>00733                 <span class="keywordflow">if</span> (rotational)
<a name="l00734"></a>00734                 {
<a name="l00735"></a>00735                         <span class="keywordflow">if</span> (error &gt; SIMD_PI)
<a name="l00736"></a>00736                         {
<a name="l00737"></a>00737                                 error -= SIMD_2_PI;
<a name="l00738"></a>00738                                 curServoTarget +=SIMD_2_PI;
<a name="l00739"></a>00739                         }
<a name="l00740"></a>00740                         <span class="keywordflow">if</span> (error &lt; -SIMD_PI)
<a name="l00741"></a>00741                         {
<a name="l00742"></a>00742                                 error += SIMD_2_PI;
<a name="l00743"></a>00743                                 curServoTarget -=SIMD_2_PI;
<a name="l00744"></a>00744                         }
<a name="l00745"></a>00745                 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00748"></a>00748                 btScalar targetvelocity = error&lt;0 ? -limot-&gt;m_targetVelocity : limot-&gt;m_targetVelocity;
<a name="l00749"></a>00749                 btScalar tag_vel = -targetvelocity;
<a name="l00750"></a>00750                 btScalar mot_fact;
<a name="l00751"></a>00751                 <span class="keywordflow">if</span>(error != 0)
<a name="l00752"></a>00752                 {
<a name="l00753"></a>00753                         btScalar lowLimit;
<a name="l00754"></a>00754                         btScalar hiLimit;
<a name="l00755"></a>00755                         <span class="keywordflow">if</span>(limot-&gt;m_loLimit &gt; limot-&gt;m_hiLimit)
<a name="l00756"></a>00756                         {
<a name="l00757"></a>00757                                 lowLimit = error &gt; 0 ? curServoTarget : -SIMD_INFINITY;
<a name="l00758"></a>00758                                 hiLimit  = error &lt; 0 ? curServoTarget :  SIMD_INFINITY;
<a name="l00759"></a>00759                         }
<a name="l00760"></a>00760                         <span class="keywordflow">else</span>
<a name="l00761"></a>00761                         {
<a name="l00762"></a>00762                                 lowLimit = error &gt; 0 &amp;&amp; curServoTarget&gt;limot-&gt;m_loLimit ? curServoTarget : limot-&gt;m_loLimit;
<a name="l00763"></a>00763                                 hiLimit  = error &lt; 0 &amp;&amp; curServoTarget&lt;limot-&gt;m_hiLimit ? curServoTarget : limot-&gt;m_hiLimit;
<a name="l00764"></a>00764                         }
<a name="l00765"></a>00765                         mot_fact = getMotorFactor(limot-&gt;m_currentPosition, lowLimit, hiLimit, tag_vel, info-&gt;fps * limot-&gt;m_motorERP);
<a name="l00766"></a>00766                 } 
<a name="l00767"></a>00767                 <span class="keywordflow">else</span> 
<a name="l00768"></a>00768                 {
<a name="l00769"></a>00769                         mot_fact = 0;
<a name="l00770"></a>00770                 }
<a name="l00771"></a>00771                 info-&gt;m_constraintError[srow] = mot_fact * targetvelocity * (rotational ? -1 : 1);
<a name="l00772"></a>00772                 info-&gt;m_lowerLimit[srow] = -limot-&gt;m_maxMotorForce;
<a name="l00773"></a>00773                 info-&gt;m_upperLimit[srow] = limot-&gt;m_maxMotorForce;
<a name="l00774"></a>00774                 info-&gt;cfm[srow] = limot-&gt;m_motorCFM;
<a name="l00775"></a>00775                 srow += info-&gt;rowskip;
<a name="l00776"></a>00776                 ++count;
<a name="l00777"></a>00777         }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="keywordflow">if</span> (limot-&gt;m_enableSpring)
<a name="l00780"></a>00780         {
<a name="l00781"></a>00781                 btScalar error = limot-&gt;m_currentPosition - limot-&gt;m_equilibriumPoint;
<a name="l00782"></a>00782                 calculateJacobi(limot,transA,transB,info,srow,ax1,rotational,rotAllowed);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784                 <span class="comment">//btScalar cfm = 1.0 / ((1.0/info-&gt;fps)*limot-&gt;m_springStiffness+ limot-&gt;m_springDamping);</span>
<a name="l00785"></a>00785                 <span class="comment">//if(cfm &gt; 0.99999)</span>
<a name="l00786"></a>00786                 <span class="comment">//      cfm = 0.99999;</span>
<a name="l00787"></a>00787                 <span class="comment">//btScalar erp = (1.0/info-&gt;fps)*limot-&gt;m_springStiffness / ((1.0/info-&gt;fps)*limot-&gt;m_springStiffness + limot-&gt;m_springDamping);</span>
<a name="l00788"></a>00788                 <span class="comment">//info-&gt;m_constraintError[srow] = info-&gt;fps * erp * error * (rotational ? -1.0 : 1.0);</span>
<a name="l00789"></a>00789                 <span class="comment">//info-&gt;m_lowerLimit[srow] = -SIMD_INFINITY;</span>
<a name="l00790"></a>00790                 <span class="comment">//info-&gt;m_upperLimit[srow] = SIMD_INFINITY;</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792                 btScalar dt = BT_ONE / info-&gt;fps;
<a name="l00793"></a>00793                 btScalar kd = limot-&gt;m_springDamping;
<a name="l00794"></a>00794                 btScalar ks = limot-&gt;m_springStiffness;
<a name="l00795"></a>00795                 btScalar vel = rotational ? angVelA.dot(ax1) - angVelB.dot(ax1) : linVelA.dot(ax1) - linVelB.dot(ax1);
<a name="l00796"></a>00796 <span class="comment">//              btScalar erp = 0.1;</span>
<a name="l00797"></a>00797                 btScalar cfm = BT_ZERO;
<a name="l00798"></a>00798                 btScalar mA = BT_ONE / m_rbA.getInvMass();
<a name="l00799"></a>00799                 btScalar mB = BT_ONE / m_rbB.getInvMass();
<a name="l00800"></a>00800                 btScalar m = mA &gt; mB ? mB : mA;
<a name="l00801"></a>00801                 btScalar angularfreq = <a class="code" href="group__gtx__integer.html#g457e9efca8339bf918d319e9c55f7c8f">sqrt</a>(ks / m);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 
<a name="l00804"></a>00804                 <span class="comment">//limit stiffness (the spring should not be sampled faster that the quarter of its angular frequency)</span>
<a name="l00805"></a>00805                 <span class="keywordflow">if</span>(limot-&gt;m_springStiffnessLimited &amp;&amp; 0.25 &lt; angularfreq * dt)
<a name="l00806"></a>00806                 {
<a name="l00807"></a>00807                         ks = BT_ONE / dt / dt / btScalar(16.0) * m;
<a name="l00808"></a>00808                 }
<a name="l00809"></a>00809                 <span class="comment">//avoid damping that would blow up the spring</span>
<a name="l00810"></a>00810                 <span class="keywordflow">if</span>(limot-&gt;m_springDampingLimited &amp;&amp; kd * dt &gt; m)
<a name="l00811"></a>00811                 {
<a name="l00812"></a>00812                         kd = m / dt;
<a name="l00813"></a>00813                 }
<a name="l00814"></a>00814                 btScalar fs = ks * error * dt;
<a name="l00815"></a>00815                 btScalar fd = -kd * (vel) * (rotational ? -1 : 1) * dt;
<a name="l00816"></a>00816                 btScalar f = (fs+fd);
<a name="l00817"></a>00817 
<a name="l00818"></a>00818                 info-&gt;m_constraintError[srow] = (vel + f * (rotational ? -1 : 1)) ;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820                 btScalar minf = f &lt; fd ? f : fd;
<a name="l00821"></a>00821                 btScalar maxf = f &lt; fd ? fd : f;
<a name="l00822"></a>00822                 <span class="keywordflow">if</span>(!rotational)
<a name="l00823"></a>00823                 {
<a name="l00824"></a>00824                         info-&gt;m_lowerLimit[srow] = minf &gt; 0 ? 0 : minf;
<a name="l00825"></a>00825                         info-&gt;m_upperLimit[srow] = maxf &lt; 0 ? 0 : maxf;
<a name="l00826"></a>00826                 }
<a name="l00827"></a>00827                 <span class="keywordflow">else</span>
<a name="l00828"></a>00828                 {
<a name="l00829"></a>00829                         info-&gt;m_lowerLimit[srow] = -maxf &gt; 0 ? 0 : -maxf;
<a name="l00830"></a>00830                         info-&gt;m_upperLimit[srow] = -minf &lt; 0 ? 0 : -minf;
<a name="l00831"></a>00831                 }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833                 info-&gt;cfm[srow] = cfm;
<a name="l00834"></a>00834                 srow += info-&gt;rowskip;
<a name="l00835"></a>00835                 ++count;
<a name="l00836"></a>00836         }
<a name="l00837"></a>00837 
<a name="l00838"></a>00838         <span class="keywordflow">return</span> count;
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="comment">//override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5). </span>
<a name="l00843"></a>00843 <span class="comment">//If no axis is provided, it uses the default axis for this constraint.</span>
<a name="l00844"></a>00844 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setParam(<span class="keywordtype">int</span> num, btScalar value, <span class="keywordtype">int</span> axis)
<a name="l00845"></a>00845 {
<a name="l00846"></a>00846         <span class="keywordflow">if</span>((axis &gt;= 0) &amp;&amp; (axis &lt; 3))
<a name="l00847"></a>00847         {
<a name="l00848"></a>00848                 <span class="keywordflow">switch</span>(num)
<a name="l00849"></a>00849                 {
<a name="l00850"></a>00850                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_ERP : 
<a name="l00851"></a>00851                                 m_linearLimits.m_stopERP[axis] = value;
<a name="l00852"></a>00852                                 m_flags |= BT_6DOF_FLAGS_ERP_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00853"></a>00853                                 <span class="keywordflow">break</span>;
<a name="l00854"></a>00854                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_CFM : 
<a name="l00855"></a>00855                                 m_linearLimits.m_stopCFM[axis] = value;
<a name="l00856"></a>00856                                 m_flags |= BT_6DOF_FLAGS_CFM_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00857"></a>00857                                 <span class="keywordflow">break</span>;
<a name="l00858"></a>00858                         <span class="keywordflow">case</span> BT_CONSTRAINT_ERP : 
<a name="l00859"></a>00859                                 m_linearLimits.m_motorERP[axis] = value;
<a name="l00860"></a>00860                                 m_flags |= BT_6DOF_FLAGS_ERP_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00861"></a>00861                                 <span class="keywordflow">break</span>;
<a name="l00862"></a>00862                         <span class="keywordflow">case</span> BT_CONSTRAINT_CFM : 
<a name="l00863"></a>00863                                 m_linearLimits.m_motorCFM[axis] = value;
<a name="l00864"></a>00864                                 m_flags |= BT_6DOF_FLAGS_CFM_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00865"></a>00865                                 <span class="keywordflow">break</span>;
<a name="l00866"></a>00866                         <span class="keywordflow">default</span> : 
<a name="l00867"></a>00867                                 btAssertConstrParams(0);
<a name="l00868"></a>00868                 }
<a name="l00869"></a>00869         }
<a name="l00870"></a>00870         <span class="keywordflow">else</span> <span class="keywordflow">if</span>((axis &gt;=3) &amp;&amp; (axis &lt; 6))
<a name="l00871"></a>00871         {
<a name="l00872"></a>00872                 <span class="keywordflow">switch</span>(num)
<a name="l00873"></a>00873                 {
<a name="l00874"></a>00874                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_ERP : 
<a name="l00875"></a>00875                                 m_angularLimits[axis - 3].m_stopERP = value;
<a name="l00876"></a>00876                                 m_flags |= BT_6DOF_FLAGS_ERP_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00877"></a>00877                                 <span class="keywordflow">break</span>;
<a name="l00878"></a>00878                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_CFM : 
<a name="l00879"></a>00879                                 m_angularLimits[axis - 3].m_stopCFM = value;
<a name="l00880"></a>00880                                 m_flags |= BT_6DOF_FLAGS_CFM_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00881"></a>00881                                 <span class="keywordflow">break</span>;
<a name="l00882"></a>00882                         <span class="keywordflow">case</span> BT_CONSTRAINT_ERP : 
<a name="l00883"></a>00883                                 m_angularLimits[axis - 3].m_motorERP = value;
<a name="l00884"></a>00884                                 m_flags |= BT_6DOF_FLAGS_ERP_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00885"></a>00885                                 <span class="keywordflow">break</span>;
<a name="l00886"></a>00886                         <span class="keywordflow">case</span> BT_CONSTRAINT_CFM : 
<a name="l00887"></a>00887                                 m_angularLimits[axis - 3].m_motorCFM = value;
<a name="l00888"></a>00888                                 m_flags |= BT_6DOF_FLAGS_CFM_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2);
<a name="l00889"></a>00889                                 <span class="keywordflow">break</span>;
<a name="l00890"></a>00890                         <span class="keywordflow">default</span> : 
<a name="l00891"></a>00891                                 btAssertConstrParams(0);
<a name="l00892"></a>00892                 }
<a name="l00893"></a>00893         }
<a name="l00894"></a>00894         <span class="keywordflow">else</span>
<a name="l00895"></a>00895         {
<a name="l00896"></a>00896                 btAssertConstrParams(0);
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="comment">//return the local value of parameter</span>
<a name="l00901"></a>00901 btScalar btGeneric6DofSpring2Constraint::getParam(<span class="keywordtype">int</span> num, <span class="keywordtype">int</span> axis)<span class="keyword"> const </span>
<a name="l00902"></a>00902 <span class="keyword"></span>{
<a name="l00903"></a>00903         btScalar retVal = 0;
<a name="l00904"></a>00904         <span class="keywordflow">if</span>((axis &gt;= 0) &amp;&amp; (axis &lt; 3))
<a name="l00905"></a>00905         {
<a name="l00906"></a>00906                 <span class="keywordflow">switch</span>(num)
<a name="l00907"></a>00907                 {
<a name="l00908"></a>00908                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_ERP : 
<a name="l00909"></a>00909                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_ERP_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00910"></a>00910                                 retVal = m_linearLimits.m_stopERP[axis];
<a name="l00911"></a>00911                                 <span class="keywordflow">break</span>;
<a name="l00912"></a>00912                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_CFM : 
<a name="l00913"></a>00913                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_CFM_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00914"></a>00914                                 retVal = m_linearLimits.m_stopCFM[axis];
<a name="l00915"></a>00915                                 <span class="keywordflow">break</span>;
<a name="l00916"></a>00916                         <span class="keywordflow">case</span> BT_CONSTRAINT_ERP : 
<a name="l00917"></a>00917                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_ERP_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00918"></a>00918                                 retVal = m_linearLimits.m_motorERP[axis];
<a name="l00919"></a>00919                                 <span class="keywordflow">break</span>;
<a name="l00920"></a>00920                         <span class="keywordflow">case</span> BT_CONSTRAINT_CFM : 
<a name="l00921"></a>00921                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_CFM_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00922"></a>00922                                 retVal = m_linearLimits.m_motorCFM[axis];
<a name="l00923"></a>00923                                 <span class="keywordflow">break</span>;
<a name="l00924"></a>00924                         <span class="keywordflow">default</span> : 
<a name="l00925"></a>00925                                 btAssertConstrParams(0);
<a name="l00926"></a>00926                 }
<a name="l00927"></a>00927         }
<a name="l00928"></a>00928         <span class="keywordflow">else</span> <span class="keywordflow">if</span>((axis &gt;=3) &amp;&amp; (axis &lt; 6))
<a name="l00929"></a>00929         {
<a name="l00930"></a>00930                 <span class="keywordflow">switch</span>(num)
<a name="l00931"></a>00931                 {
<a name="l00932"></a>00932                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_ERP : 
<a name="l00933"></a>00933                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_ERP_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00934"></a>00934                                 retVal = m_angularLimits[axis - 3].m_stopERP;
<a name="l00935"></a>00935                                 <span class="keywordflow">break</span>;
<a name="l00936"></a>00936                         <span class="keywordflow">case</span> BT_CONSTRAINT_STOP_CFM : 
<a name="l00937"></a>00937                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_CFM_STOP2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00938"></a>00938                                 retVal = m_angularLimits[axis - 3].m_stopCFM;
<a name="l00939"></a>00939                                 <span class="keywordflow">break</span>;
<a name="l00940"></a>00940                         <span class="keywordflow">case</span> BT_CONSTRAINT_ERP : 
<a name="l00941"></a>00941                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_ERP_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00942"></a>00942                                 retVal = m_angularLimits[axis - 3].m_motorERP;
<a name="l00943"></a>00943                                 <span class="keywordflow">break</span>;
<a name="l00944"></a>00944                         <span class="keywordflow">case</span> BT_CONSTRAINT_CFM : 
<a name="l00945"></a>00945                                 btAssertConstrParams(m_flags &amp; (BT_6DOF_FLAGS_CFM_MOTO2 &lt;&lt; (axis * BT_6DOF_FLAGS_AXIS_SHIFT2)));
<a name="l00946"></a>00946                                 retVal = m_angularLimits[axis - 3].m_motorCFM;
<a name="l00947"></a>00947                                 <span class="keywordflow">break</span>;
<a name="l00948"></a>00948                         <span class="keywordflow">default</span> : 
<a name="l00949"></a>00949                                 btAssertConstrParams(0);
<a name="l00950"></a>00950                 }
<a name="l00951"></a>00951         }
<a name="l00952"></a>00952         <span class="keywordflow">else</span>
<a name="l00953"></a>00953         {
<a name="l00954"></a>00954                 btAssertConstrParams(0);
<a name="l00955"></a>00955         }
<a name="l00956"></a>00956         <span class="keywordflow">return</span> retVal;
<a name="l00957"></a>00957 }
<a name="l00958"></a>00958 
<a name="l00959"></a>00959  
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setAxis(<span class="keyword">const</span> btVector3&amp; axis1,<span class="keyword">const</span> btVector3&amp; axis2)
<a name="l00962"></a>00962 {
<a name="l00963"></a>00963         btVector3 zAxis = axis1.normalized();
<a name="l00964"></a>00964         btVector3 yAxis = axis2.normalized();
<a name="l00965"></a>00965         btVector3 xAxis = yAxis.cross(zAxis); <span class="comment">// we want right coordinate system</span>
<a name="l00966"></a>00966         
<a name="l00967"></a>00967         btTransform frameInW;
<a name="l00968"></a>00968         frameInW.setIdentity();
<a name="l00969"></a>00969         frameInW.getBasis().setValue( xAxis[0], yAxis[0], zAxis[0],
<a name="l00970"></a>00970                                       xAxis[1], yAxis[1], zAxis[1],
<a name="l00971"></a>00971                                       xAxis[2], yAxis[2], zAxis[2]);
<a name="l00972"></a>00972         
<a name="l00973"></a>00973         <span class="comment">// now get constraint frame in local coordinate systems</span>
<a name="l00974"></a>00974         m_frameInA = m_rbA.getCenterOfMassTransform().inverse() * frameInW;
<a name="l00975"></a>00975         m_frameInB = m_rbB.getCenterOfMassTransform().inverse() * frameInW;
<a name="l00976"></a>00976         
<a name="l00977"></a>00977         calculateTransforms();
<a name="l00978"></a>00978 }
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setBounce(<span class="keywordtype">int</span> index, btScalar bounce)
<a name="l00981"></a>00981 {
<a name="l00982"></a>00982         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l00983"></a>00983         <span class="keywordflow">if</span> (index&lt;3)
<a name="l00984"></a>00984                 m_linearLimits.m_bounce[index] = bounce;
<a name="l00985"></a>00985         <span class="keywordflow">else</span>
<a name="l00986"></a>00986                 m_angularLimits[index - 3].m_bounce = bounce;
<a name="l00987"></a>00987 }
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::enableMotor(<span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> onOff)
<a name="l00990"></a>00990 {
<a name="l00991"></a>00991         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l00992"></a>00992         <span class="keywordflow">if</span> (index&lt;3)
<a name="l00993"></a>00993                 m_linearLimits.m_enableMotor[index] = onOff;
<a name="l00994"></a>00994         <span class="keywordflow">else</span>
<a name="l00995"></a>00995                 m_angularLimits[index - 3].m_enableMotor = onOff;
<a name="l00996"></a>00996 }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setServo(<span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> onOff)
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01001"></a>01001         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01002"></a>01002                 m_linearLimits.m_servoMotor[index] = onOff;
<a name="l01003"></a>01003         <span class="keywordflow">else</span>
<a name="l01004"></a>01004                 m_angularLimits[index - 3].m_servoMotor = onOff;
<a name="l01005"></a>01005 }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setTargetVelocity(<span class="keywordtype">int</span> index, btScalar velocity)
<a name="l01008"></a>01008 {
<a name="l01009"></a>01009         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01010"></a>01010         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01011"></a>01011                 m_linearLimits.m_targetVelocity[index] = velocity;
<a name="l01012"></a>01012         <span class="keywordflow">else</span>
<a name="l01013"></a>01013                 m_angularLimits[index - 3].m_targetVelocity = velocity;
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setServoTarget(<span class="keywordtype">int</span> index, btScalar targetOrg)
<a name="l01019"></a>01019 {
<a name="l01020"></a>01020         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01021"></a>01021         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01022"></a>01022         {
<a name="l01023"></a>01023                 m_linearLimits.m_servoTarget[index] = targetOrg;
<a name="l01024"></a>01024         }
<a name="l01025"></a>01025         <span class="keywordflow">else</span>
<a name="l01026"></a>01026         {
<a name="l01027"></a>01027                 <span class="comment">//wrap between -PI and PI, see also</span>
<a name="l01028"></a>01028                 <span class="comment">//https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi</span>
<a name="l01029"></a>01029 
<a name="l01030"></a>01030                 btScalar target = targetOrg+SIMD_PI;
<a name="l01031"></a>01031                 <span class="keywordflow">if</span> (1)
<a name="l01032"></a>01032                 {
<a name="l01033"></a>01033                         btScalar m = target - SIMD_2_PI * <a class="code" href="group__core__func__common.html#gf87c2d5cbed8b293dcb7506b7c06c9e1">floor</a>(target/SIMD_2_PI);
<a name="l01034"></a>01034                         <span class="comment">// handle boundary cases resulted from floating-point cut off:</span>
<a name="l01035"></a>01035                         {
<a name="l01036"></a>01036                                 <span class="keywordflow">if</span> (m&gt;=SIMD_2_PI)
<a name="l01037"></a>01037                                 {
<a name="l01038"></a>01038                                         target = 0;
<a name="l01039"></a>01039                                 } <span class="keywordflow">else</span>
<a name="l01040"></a>01040                                 {
<a name="l01041"></a>01041                                         <span class="keywordflow">if</span> (m&lt;0 )
<a name="l01042"></a>01042                                         {
<a name="l01043"></a>01043                                                 <span class="keywordflow">if</span> (SIMD_2_PI+m == SIMD_2_PI)
<a name="l01044"></a>01044                                                         target = 0;
<a name="l01045"></a>01045                                                 <span class="keywordflow">else</span>
<a name="l01046"></a>01046                                                         target = SIMD_2_PI+m;
<a name="l01047"></a>01047                                         }
<a name="l01048"></a>01048                                         <span class="keywordflow">else</span>
<a name="l01049"></a>01049                                         {
<a name="l01050"></a>01050                                                 target = m;
<a name="l01051"></a>01051                                         }
<a name="l01052"></a>01052                                 }
<a name="l01053"></a>01053                         }
<a name="l01054"></a>01054                         target -= SIMD_PI;
<a name="l01055"></a>01055                 }
<a name="l01056"></a>01056                 
<a name="l01057"></a>01057                 m_angularLimits[index - 3].m_servoTarget = target;
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059 }
<a name="l01060"></a>01060 
<a name="l01061"></a>01061 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setMaxMotorForce(<span class="keywordtype">int</span> index, btScalar force)
<a name="l01062"></a>01062 {
<a name="l01063"></a>01063         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01065"></a>01065                 m_linearLimits.m_maxMotorForce[index] = force;
<a name="l01066"></a>01066         <span class="keywordflow">else</span>
<a name="l01067"></a>01067                 m_angularLimits[index - 3].m_maxMotorForce = force;
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::enableSpring(<span class="keywordtype">int</span> index, <span class="keywordtype">bool</span> onOff)
<a name="l01071"></a>01071 {
<a name="l01072"></a>01072         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01073"></a>01073         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01074"></a>01074                 m_linearLimits.m_enableSpring[index] = onOff;
<a name="l01075"></a>01075         <span class="keywordflow">else</span>
<a name="l01076"></a>01076                 m_angularLimits[index - 3] .m_enableSpring = onOff;
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setStiffness(<span class="keywordtype">int</span> index, btScalar stiffness, <span class="keywordtype">bool</span> limitIfNeeded)
<a name="l01080"></a>01080 {
<a name="l01081"></a>01081         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01082"></a>01082         <span class="keywordflow">if</span> (index&lt;3) {
<a name="l01083"></a>01083                 m_linearLimits.m_springStiffness[index] = stiffness;
<a name="l01084"></a>01084                 m_linearLimits.m_springStiffnessLimited[index] = limitIfNeeded;
<a name="l01085"></a>01085         } <span class="keywordflow">else</span> {
<a name="l01086"></a>01086                 m_angularLimits[index - 3].m_springStiffness = stiffness;
<a name="l01087"></a>01087                 m_angularLimits[index - 3].m_springStiffnessLimited = limitIfNeeded;
<a name="l01088"></a>01088         }
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setDamping(<span class="keywordtype">int</span> index, btScalar damping, <span class="keywordtype">bool</span> limitIfNeeded)
<a name="l01092"></a>01092 {
<a name="l01093"></a>01093         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01094"></a>01094         <span class="keywordflow">if</span> (index&lt;3) {
<a name="l01095"></a>01095                 m_linearLimits.m_springDamping[index] = damping;
<a name="l01096"></a>01096                 m_linearLimits.m_springDampingLimited[index] = limitIfNeeded;
<a name="l01097"></a>01097         } <span class="keywordflow">else</span> {
<a name="l01098"></a>01098                 m_angularLimits[index - 3].m_springDamping = damping;
<a name="l01099"></a>01099                 m_angularLimits[index - 3].m_springDampingLimited = limitIfNeeded;
<a name="l01100"></a>01100         }
<a name="l01101"></a>01101 }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setEquilibriumPoint()
<a name="l01104"></a>01104 {
<a name="l01105"></a>01105         calculateTransforms();
<a name="l01106"></a>01106         <span class="keywordtype">int</span> i;
<a name="l01107"></a>01107         <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++)
<a name="l01108"></a>01108                 m_linearLimits.m_equilibriumPoint[i] = m_calculatedLinearDiff[i];
<a name="l01109"></a>01109         <span class="keywordflow">for</span>(i = 0; i &lt; 3; i++)
<a name="l01110"></a>01110                 m_angularLimits[i].m_equilibriumPoint = m_calculatedAxisAngleDiff[i];
<a name="l01111"></a>01111 }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setEquilibriumPoint(<span class="keywordtype">int</span> index)
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01116"></a>01116         calculateTransforms();
<a name="l01117"></a>01117         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01118"></a>01118                 m_linearLimits.m_equilibriumPoint[index] = m_calculatedLinearDiff[index];
<a name="l01119"></a>01119         <span class="keywordflow">else</span>
<a name="l01120"></a>01120                 m_angularLimits[index - 3] .m_equilibriumPoint = m_calculatedAxisAngleDiff[index - 3];
<a name="l01121"></a>01121 }
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="keywordtype">void</span> btGeneric6DofSpring2Constraint::setEquilibriumPoint(<span class="keywordtype">int</span> index, btScalar val)
<a name="l01124"></a>01124 {
<a name="l01125"></a>01125         btAssert((index &gt;= 0) &amp;&amp; (index &lt; 6));
<a name="l01126"></a>01126         <span class="keywordflow">if</span> (index&lt;3)
<a name="l01127"></a>01127                 m_linearLimits.m_equilibriumPoint[index] = val;
<a name="l01128"></a>01128         <span class="keywordflow">else</span>
<a name="l01129"></a>01129                 m_angularLimits[index - 3] .m_equilibriumPoint = val;
<a name="l01130"></a>01130 }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132 
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 <span class="keywordtype">void</span> btRotationalLimitMotor2::testLimitValue(btScalar test_value)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137         <span class="comment">//we can't normalize the angles here because we would lost the sign that we use later, but it doesn't seem to be a problem</span>
<a name="l01138"></a>01138         <span class="keywordflow">if</span>(<a class="code" href="classbt_rotational_limit_motor.html#57ff414e1856d661d81b797702c4f986" title="joint limit">m_loLimit</a> &gt; <a class="code" href="classbt_rotational_limit_motor.html#3201531c631a779615146a373840239c" title="joint limit">m_hiLimit</a>) {
<a name="l01139"></a>01139                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a> = 0;
<a name="l01140"></a>01140                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a> = btScalar(0.f);
<a name="l01141"></a>01141         }
<a name="l01142"></a>01142         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classbt_rotational_limit_motor.html#57ff414e1856d661d81b797702c4f986" title="joint limit">m_loLimit</a> == <a class="code" href="classbt_rotational_limit_motor.html#3201531c631a779615146a373840239c" title="joint limit">m_hiLimit</a>) {
<a name="l01143"></a>01143                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a> = test_value - <a class="code" href="classbt_rotational_limit_motor.html#57ff414e1856d661d81b797702c4f986" title="joint limit">m_loLimit</a>;
<a name="l01144"></a>01144                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a> = 3;
<a name="l01145"></a>01145         } <span class="keywordflow">else</span> {
<a name="l01146"></a>01146                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a> = test_value - <a class="code" href="classbt_rotational_limit_motor.html#57ff414e1856d661d81b797702c4f986" title="joint limit">m_loLimit</a>;
<a name="l01147"></a>01147                 m_currentLimitErrorHi = test_value - <a class="code" href="classbt_rotational_limit_motor.html#3201531c631a779615146a373840239c" title="joint limit">m_hiLimit</a>;
<a name="l01148"></a>01148                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a> = 4;
<a name="l01149"></a>01149         }
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 
<a name="l01153"></a>01153 
<a name="l01154"></a>01154 <span class="keywordtype">void</span> btTranslationalLimitMotor2::testLimitValue(<span class="keywordtype">int</span> limitIndex, btScalar test_value)
<a name="l01155"></a>01155 {
<a name="l01156"></a>01156         btScalar loLimit = m_lowerLimit[limitIndex];
<a name="l01157"></a>01157         btScalar hiLimit = m_upperLimit[limitIndex];
<a name="l01158"></a>01158         <span class="keywordflow">if</span>(loLimit &gt; hiLimit) {
<a name="l01159"></a>01159                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a>[limitIndex] = 0;
<a name="l01160"></a>01160                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a>[limitIndex] = 0;
<a name="l01161"></a>01161         }
<a name="l01162"></a>01162         <span class="keywordflow">else</span> <span class="keywordflow">if</span>(loLimit == hiLimit) {
<a name="l01163"></a>01163                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a>[limitIndex] = test_value - loLimit;
<a name="l01164"></a>01164                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a>[limitIndex] = 3;
<a name="l01165"></a>01165         } <span class="keywordflow">else</span> {
<a name="l01166"></a>01166                 <a class="code" href="classbt_rotational_limit_motor.html#7128feccb391176842f287b584e375d3">m_currentLimitError</a>[limitIndex] = test_value - loLimit;
<a name="l01167"></a>01167                 m_currentLimitErrorHi[limitIndex] = test_value - hiLimit;
<a name="l01168"></a>01168                 <a class="code" href="classbt_rotational_limit_motor.html#d1e4fa6cb3ea2e4b78c96feab97448e8" title="current value of angle">m_currentLimit</a>[limitIndex] = 4;
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170 }
<a name="l01171"></a>01171 
<a name="l01172"></a>01172 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 12:56:47 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
