<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btConvexConvexAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btConvexConvexAlgorithm Class Reference</h1><!-- doxytag: class="btConvexConvexAlgorithm" --><!-- doxytag: inherits="btActivatingCollisionAlgorithm" --><code>#include &lt;<a class="el" href="bt_convex_convex_algorithm_8h-source.html">btConvexConvexAlgorithm.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for btConvexConvexAlgorithm:</div>
<div class="dynsection">
<p><center><img src="classbt_convex_convex_algorithm__inherit__graph.png" border="0" usemap="#bt_convex_convex_algorithm__inherit__map" alt="Inheritance graph"></center>
<map name="bt_convex_convex_algorithm__inherit__map">
<area shape="rect" href="classbt_activating_collision_algorithm.html" title="This class is not enabled yet (work&#45;in&#45;progress) to more aggressively activate objects..." alt="" coords="5,80,197,107"><area shape="rect" href="classbt_collision_algorithm.html" title="btCollisionAlgorithm" alt="" coords="33,5,169,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for btConvexConvexAlgorithm:</div>
<div class="dynsection">
<p><center><img src="classbt_convex_convex_algorithm__coll__graph.png" border="0" usemap="#bt_convex_convex_algorithm__coll__map" alt="Collaboration graph"></center>
<map name="bt_convex_convex_algorithm__coll__map">
<area shape="rect" href="classbt_activating_collision_algorithm.html" title="This class is not enabled yet (work&#45;in&#45;progress) to more aggressively activate objects..." alt="" coords="1160,8,1352,35"><area shape="rect" href="classbt_collision_algorithm.html" title="btCollisionAlgorithm" alt="" coords="860,8,996,35"><area shape="rect" href="classbt_dispatcher.html" title="btDispatcher" alt="" coords="425,8,519,35"><area shape="rect" href="classbt_convex_penetration_depth_solver.html" title="ConvexPenetrationDepthSolver provides an interface for penetration depth calculation..." alt="" coords="1152,59,1360,85"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btVector3 \&gt;" alt="" coords="1144,121,1368,148"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btVector3, 16 \&gt;" alt="" coords="588,79,815,105"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, Alignment \&gt;" alt="" coords="5,105,229,132"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, 16 \&gt;" alt="" coords="383,132,561,159"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; T \&gt;" alt="" coords="840,135,1016,161"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_convex_convex_algorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="70134c01925ca835c4e29ab1bb0a049c"></a><!-- doxytag: member="btConvexConvexAlgorithm::btConvexConvexAlgorithm" ref="70134c01925ca835c4e29ab1bb0a049c" args="(btPersistentManifold *mf, const btCollisionAlgorithmConstructionInfo &amp;ci, const btCollisionObjectWrapper *body0Wrap, const btCollisionObjectWrapper *body1Wrap, btConvexPenetrationDepthSolver *pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex_convex_algorithm.html#70134c01925ca835c4e29ab1bb0a049c">btConvexConvexAlgorithm</a> (btPersistentManifold *mf, const btCollisionAlgorithmConstructionInfo &amp;ci, const btCollisionObjectWrapper *body0Wrap, const btCollisionObjectWrapper *body1Wrap, <a class="el" href="classbt_convex_penetration_depth_solver.html">btConvexPenetrationDepthSolver</a> *pdSolver, int numPerturbationIterations, int minimumPointsPerturbationThreshold)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cache separating vector to speedup collision detection <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex_convex_algorithm.html#b566631355a17f7a4bcbddf9454eb9e5">processCollision</a> (const btCollisionObjectWrapper *body0Wrap, const btCollisionObjectWrapper *body1Wrap, const btDispatcherInfo &amp;dispatchInfo, <a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *resultOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual btScalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex_convex_algorithm.html#55f817b690c4e858d2b02607b382ce6b">calculateTimeOfImpact</a> (btCollisionObject *body0, btCollisionObject *body1, const btDispatcherInfo &amp;dispatchInfo, <a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *resultOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex_convex_algorithm.html#a2a195cdd3b45c169c15ea2de85c4038">getAllContactManifolds</a> (<a class="el" href="classbt_aligned_object_array.html">btManifoldArray</a> &amp;manifoldArray)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Enabling USE_SEPDISTANCE_UTIL2 requires 100% reliable distance computation. However, when using large size ratios GJK can be imprecise so the distance is not conservative. In that case, enabling this USE_SEPDISTANCE_UTIL2 would result in failing/missing collisions. Either improve GJK for large size ratios (testing a 100 units versus a 0.1 unit object) or only enable the util for certain pairs that have a small size ratio The convexConvexAlgorithm collision algorithm implements time of impact, convex closest points and penetration depth calculations between two convex objects. Multiple contact points are calculated by perturbing the orientation of the smallest object orthogonal to the separating normal. This idea was described by Gino van den Bergen in this forum topic <a href="http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=4&t=288&p=888#p888">http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=4&amp;t=288&amp;p=888#p888</a> 
<p>Definition at line <a class="el" href="bt_convex_convex_algorithm_8h-source.html#l00041">41</a> of file <a class="el" href="bt_convex_convex_algorithm_8h-source.html">btConvexConvexAlgorithm.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b566631355a17f7a4bcbddf9454eb9e5"></a><!-- doxytag: member="btConvexConvexAlgorithm::processCollision" ref="b566631355a17f7a4bcbddf9454eb9e5" args="(const btCollisionObjectWrapper *body0Wrap, const btCollisionObjectWrapper *body1Wrap, const btDispatcherInfo &amp;dispatchInfo, btManifoldResult *resultOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btConvexConvexAlgorithm::processCollision           </td>
          <td>(</td>
          <td class="paramtype">const btCollisionObjectWrapper *&nbsp;</td>
          <td class="paramname"> <em>body0Wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btCollisionObjectWrapper *&nbsp;</td>
          <td class="paramname"> <em>body1Wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btDispatcherInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatchInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *&nbsp;</td>
          <td class="paramname"> <em>resultOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
btBoxShape is an exception: its vertices are created WITH margin so don't subtract it 
<p>Implements <a class="el" href="classbt_collision_algorithm.html">btCollisionAlgorithm</a>.</p>

<p>Definition at line <a class="el" href="bt_convex_convex_algorithm_8cpp-source.html#l00290">290</a> of file <a class="el" href="bt_convex_convex_algorithm_8cpp-source.html">btConvexConvexAlgorithm.cpp</a>.</p>

<p>References <a class="el" href="bt_manifold_result_8cpp-source.html#l00104">btManifoldResult::addContactPoint()</a>, <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00080">btGjkPairDetector::getCachedSeparatingAxis()</a>, <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00084">btGjkPairDetector::getCachedSeparatingDistance()</a>, <a class="el" href="bt_gjk_pair_detector_8cpp-source.html#l00079">btGjkPairDetector::getClosestPoints()</a>, btDispatcher::getNewManifold(), <a class="el" href="bt_manifold_result_8h-source.html#l00077">btManifoldResult::getPersistentManifold()</a>, <a class="el" href="bt_manifold_result_8h-source.html#l00147">btManifoldResult::m_closestPointDistanceThreshold</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>, <a class="el" href="bt_manifold_result_8h-source.html#l00101">btManifoldResult::refreshContactPoints()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00095">btGjkPairDetector::setIgnoreMargin()</a>, <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00066">btGjkPairDetector::setMinkowskiA()</a>, <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00071">btGjkPairDetector::setMinkowskiB()</a>, and <a class="el" href="bt_manifold_result_8h-source.html#l00072">btManifoldResult::setPersistentManifold()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00291"></a>00291 {
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="keywordflow">if</span> (!m_manifoldPtr)
<a name="l00294"></a>00294         {
<a name="l00295"></a>00295                 <span class="comment">//swapped?</span>
<a name="l00296"></a>00296                 m_manifoldPtr = m_dispatcher-&gt;<a class="code" href="classbt_dispatcher.html#8c7798c84a4ec8da239b70797fa5abf2">getNewManifold</a>(body0Wrap-&gt;getCollisionObject(),body1Wrap-&gt;getCollisionObject());
<a name="l00297"></a>00297                 m_ownManifold = <span class="keyword">true</span>;
<a name="l00298"></a>00298         }
<a name="l00299"></a>00299         resultOut-&gt;<a class="code" href="classbt_manifold_result.html#7a46d46b9a13c2896695e458c1d6df1f">setPersistentManifold</a>(m_manifoldPtr);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="comment">//comment-out next line to test multi-contact generation</span>
<a name="l00302"></a>00302         <span class="comment">//resultOut-&gt;getPersistentManifold()-&gt;clearManifold();</span>
<a name="l00303"></a>00303         
<a name="l00304"></a>00304 
<a name="l00305"></a>00305         <span class="keyword">const</span> btConvexShape* min0 = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>btConvexShape*<span class="keyword">&gt;</span>(body0Wrap-&gt;getCollisionShape());
<a name="l00306"></a>00306         <span class="keyword">const</span> btConvexShape* min1 = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>btConvexShape*<span class="keyword">&gt;</span>(body1Wrap-&gt;getCollisionShape());
<a name="l00307"></a>00307 
<a name="l00308"></a>00308         btVector3  normalOnB;
<a name="l00309"></a>00309                 btVector3  pointOnBWorld;
<a name="l00310"></a>00310 <span class="preprocessor">#ifndef BT_DISABLE_CAPSULE_CAPSULE_COLLIDER</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((min0-&gt;getShapeType() == CAPSULE_SHAPE_PROXYTYPE) &amp;&amp; (min1-&gt;getShapeType() == CAPSULE_SHAPE_PROXYTYPE))
<a name="l00312"></a>00312         {
<a name="l00313"></a>00313                 <span class="comment">//m_manifoldPtr-&gt;clearManifold();</span>
<a name="l00314"></a>00314 
<a name="l00315"></a>00315                 btCapsuleShape* capsuleA = (btCapsuleShape*) min0;
<a name="l00316"></a>00316                 btCapsuleShape* capsuleB = (btCapsuleShape*) min1;
<a name="l00317"></a>00317                 
<a name="l00318"></a>00318                 btScalar threshold = m_manifoldPtr-&gt;getContactBreakingThreshold();
<a name="l00319"></a>00319 
<a name="l00320"></a>00320                 btScalar dist = capsuleCapsuleDistance(normalOnB,       pointOnBWorld,capsuleA-&gt;getHalfHeight(),capsuleA-&gt;getRadius(),
<a name="l00321"></a>00321                         capsuleB-&gt;getHalfHeight(),capsuleB-&gt;getRadius(),capsuleA-&gt;getUpAxis(),capsuleB-&gt;getUpAxis(),
<a name="l00322"></a>00322                         body0Wrap-&gt;getWorldTransform(),body1Wrap-&gt;getWorldTransform(),threshold);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324                 <span class="keywordflow">if</span> (dist&lt;threshold)
<a name="l00325"></a>00325                 {
<a name="l00326"></a>00326                         btAssert(normalOnB.length2()&gt;=(SIMD_EPSILON*SIMD_EPSILON));
<a name="l00327"></a>00327                         resultOut-&gt;<a class="code" href="classbt_manifold_result.html#ebe32f0c202d988d0458e88d768602c6">addContactPoint</a>(normalOnB,pointOnBWorld,dist);       
<a name="l00328"></a>00328                 }
<a name="l00329"></a>00329                 resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00330"></a>00330                 <span class="keywordflow">return</span>;
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333         <span class="keywordflow">if</span> ((min0-&gt;getShapeType() == CAPSULE_SHAPE_PROXYTYPE) &amp;&amp; (min1-&gt;getShapeType() == SPHERE_SHAPE_PROXYTYPE))
<a name="l00334"></a>00334         {
<a name="l00335"></a>00335                 <span class="comment">//m_manifoldPtr-&gt;clearManifold();</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337                 btCapsuleShape* capsuleA = (btCapsuleShape*) min0;
<a name="l00338"></a>00338                 btSphereShape* capsuleB = (btSphereShape*) min1;
<a name="l00339"></a>00339                 
<a name="l00340"></a>00340                 btScalar threshold = m_manifoldPtr-&gt;getContactBreakingThreshold();
<a name="l00341"></a>00341 
<a name="l00342"></a>00342                 btScalar dist = capsuleCapsuleDistance(normalOnB,       pointOnBWorld,capsuleA-&gt;getHalfHeight(),capsuleA-&gt;getRadius(),
<a name="l00343"></a>00343                         0.,capsuleB-&gt;getRadius(),capsuleA-&gt;getUpAxis(),1,
<a name="l00344"></a>00344                         body0Wrap-&gt;getWorldTransform(),body1Wrap-&gt;getWorldTransform(),threshold);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346                 <span class="keywordflow">if</span> (dist&lt;threshold)
<a name="l00347"></a>00347                 {
<a name="l00348"></a>00348                         btAssert(normalOnB.length2()&gt;=(SIMD_EPSILON*SIMD_EPSILON));
<a name="l00349"></a>00349                         resultOut-&gt;<a class="code" href="classbt_manifold_result.html#ebe32f0c202d988d0458e88d768602c6">addContactPoint</a>(normalOnB,pointOnBWorld,dist);       
<a name="l00350"></a>00350                 }
<a name="l00351"></a>00351                 resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00352"></a>00352                 <span class="keywordflow">return</span>;
<a name="l00353"></a>00353         }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="keywordflow">if</span> ((min0-&gt;getShapeType() == SPHERE_SHAPE_PROXYTYPE) &amp;&amp; (min1-&gt;getShapeType() == CAPSULE_SHAPE_PROXYTYPE))
<a name="l00356"></a>00356         {
<a name="l00357"></a>00357                 <span class="comment">//m_manifoldPtr-&gt;clearManifold();</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359                 btSphereShape* capsuleA = (btSphereShape*) min0;
<a name="l00360"></a>00360                 btCapsuleShape* capsuleB = (btCapsuleShape*) min1;
<a name="l00361"></a>00361                 
<a name="l00362"></a>00362                 btScalar threshold = m_manifoldPtr-&gt;getContactBreakingThreshold();
<a name="l00363"></a>00363 
<a name="l00364"></a>00364                 btScalar dist = capsuleCapsuleDistance(normalOnB,       pointOnBWorld,0.,capsuleA-&gt;getRadius(),
<a name="l00365"></a>00365                         capsuleB-&gt;getHalfHeight(),capsuleB-&gt;getRadius(),1,capsuleB-&gt;getUpAxis(),
<a name="l00366"></a>00366                         body0Wrap-&gt;getWorldTransform(),body1Wrap-&gt;getWorldTransform(),threshold);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368                 <span class="keywordflow">if</span> (dist&lt;threshold)
<a name="l00369"></a>00369                 {
<a name="l00370"></a>00370                         btAssert(normalOnB.length2()&gt;=(SIMD_EPSILON*SIMD_EPSILON));
<a name="l00371"></a>00371                         resultOut-&gt;<a class="code" href="classbt_manifold_result.html#ebe32f0c202d988d0458e88d768602c6">addContactPoint</a>(normalOnB,pointOnBWorld,dist);       
<a name="l00372"></a>00372                 }
<a name="l00373"></a>00373                 resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00374"></a>00374                 <span class="keywordflow">return</span>;
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376 <span class="preprocessor">#endif //BT_DISABLE_CAPSULE_CAPSULE_COLLIDER</span>
<a name="l00377"></a>00377 <span class="preprocessor"></span>
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="preprocessor">#ifdef USE_SEPDISTANCE_UTIL2</span>
<a name="l00382"></a>00382 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (dispatchInfo.m_useConvexConservativeDistanceUtil)
<a name="l00383"></a>00383         {
<a name="l00384"></a>00384                 m_sepDistance.updateSeparatingDistance(body0-&gt;getWorldTransform(),body1-&gt;getWorldTransform());
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386 
<a name="l00387"></a>00387         <span class="keywordflow">if</span> (!dispatchInfo.m_useConvexConservativeDistanceUtil || m_sepDistance.getConservativeSeparatingDistance()&lt;=0.f)
<a name="l00388"></a>00388 #endif <span class="comment">//USE_SEPDISTANCE_UTIL2</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         {
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         
<a name="l00393"></a>00393         btGjkPairDetector::ClosestPointInput input;
<a name="l00394"></a>00394     btVoronoiSimplexSolver simplexSolver;
<a name="l00395"></a>00395     <a class="code" href="classbt_gjk_pair_detector.html" title="btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface">btGjkPairDetector</a>   gjkPairDetector( min0, min1, &amp;simplexSolver, m_pdSolver );
<a name="l00396"></a>00396         <span class="comment">//TODO: if (dispatchInfo.m_useContinuous)</span>
<a name="l00397"></a>00397         gjkPairDetector.setMinkowskiA(min0);
<a name="l00398"></a>00398         gjkPairDetector.setMinkowskiB(min1);
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="preprocessor">#ifdef USE_SEPDISTANCE_UTIL2</span>
<a name="l00401"></a>00401 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (dispatchInfo.m_useConvexConservativeDistanceUtil)
<a name="l00402"></a>00402         {
<a name="l00403"></a>00403                 input.m_maximumDistanceSquared = BT_LARGE_FLOAT;
<a name="l00404"></a>00404         } <span class="keywordflow">else</span>
<a name="l00405"></a>00405 <span class="preprocessor">#endif //USE_SEPDISTANCE_UTIL2</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>        {
<a name="l00407"></a>00407                 <span class="comment">//if (dispatchInfo.m_convexMaxDistanceUseCPT)</span>
<a name="l00408"></a>00408                 <span class="comment">//{</span>
<a name="l00409"></a>00409                 <span class="comment">//      input.m_maximumDistanceSquared = min0-&gt;getMargin() + min1-&gt;getMargin() + m_manifoldPtr-&gt;getContactProcessingThreshold();</span>
<a name="l00410"></a>00410                 <span class="comment">//} else</span>
<a name="l00411"></a>00411                 <span class="comment">//{</span>
<a name="l00412"></a>00412                 input.m_maximumDistanceSquared = min0-&gt;getMargin() + min1-&gt;getMargin() + m_manifoldPtr-&gt;getContactBreakingThreshold()+resultOut-&gt;<a class="code" href="classbt_manifold_result.html#a582b802c2131a6072e313fb8b028b55">m_closestPointDistanceThreshold</a>;
<a name="l00413"></a>00413 <span class="comment">//              }</span>
<a name="l00414"></a>00414 
<a name="l00415"></a>00415                 input.m_maximumDistanceSquared*= input.m_maximumDistanceSquared;
<a name="l00416"></a>00416         }
<a name="l00417"></a>00417 
<a name="l00418"></a>00418         input.m_transformA = body0Wrap-&gt;getWorldTransform();
<a name="l00419"></a>00419         input.m_transformB = body1Wrap-&gt;getWorldTransform();
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="preprocessor">#ifdef USE_SEPDISTANCE_UTIL2</span>
<a name="l00426"></a>00426 <span class="preprocessor"></span>        btScalar sepDist = 0.f;
<a name="l00427"></a>00427         <span class="keywordflow">if</span> (dispatchInfo.m_useConvexConservativeDistanceUtil)
<a name="l00428"></a>00428         {
<a name="l00429"></a>00429                 sepDist = gjkPairDetector.getCachedSeparatingDistance();
<a name="l00430"></a>00430                 <span class="keywordflow">if</span> (sepDist&gt;SIMD_EPSILON)
<a name="l00431"></a>00431                 {
<a name="l00432"></a>00432                         sepDist += dispatchInfo.m_convexConservativeDistanceThreshold;
<a name="l00433"></a>00433                         <span class="comment">//now perturbe directions to get multiple contact points</span>
<a name="l00434"></a>00434                         
<a name="l00435"></a>00435                 }
<a name="l00436"></a>00436         }
<a name="l00437"></a>00437 <span class="preprocessor">#endif //USE_SEPDISTANCE_UTIL2</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>
<a name="l00439"></a>00439         <span class="keywordflow">if</span> (min0-&gt;isPolyhedral() &amp;&amp; min1-&gt;isPolyhedral())
<a name="l00440"></a>00440         {
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 
<a name="l00443"></a>00443                 <span class="keyword">struct </span>btDummyResult : <span class="keyword">public</span> <a class="code" href="structbt_discrete_collision_detector_interface.html">btDiscreteCollisionDetectorInterface</a>::Result
<a name="l00444"></a>00444                 {
<a name="l00445"></a>00445                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setShapeIdentifiersA(<span class="keywordtype">int</span> partId0,<span class="keywordtype">int</span> index0){}
<a name="l00446"></a>00446                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setShapeIdentifiersB(<span class="keywordtype">int</span> partId1,<span class="keywordtype">int</span> index1){}
<a name="l00447"></a>00447                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> addContactPoint(<span class="keyword">const</span> btVector3&amp; normalOnBInWorld,<span class="keyword">const</span> btVector3&amp; pointInWorld,btScalar depth) 
<a name="l00448"></a>00448                         {
<a name="l00449"></a>00449                         }
<a name="l00450"></a>00450                 };
<a name="l00451"></a>00451 
<a name="l00452"></a>00452                 
<a name="l00453"></a>00453                 <span class="keyword">struct </span>btWithoutMarginResult : <span class="keyword">public</span> <a class="code" href="structbt_discrete_collision_detector_interface.html">btDiscreteCollisionDetectorInterface</a>::Result
<a name="l00454"></a>00454                 {
<a name="l00455"></a>00455                         btDiscreteCollisionDetectorInterface::Result* m_originalResult;
<a name="l00456"></a>00456                         btVector3       m_reportedNormalOnWorld;
<a name="l00457"></a>00457                         btScalar m_marginOnA;
<a name="l00458"></a>00458                         btScalar m_marginOnB;
<a name="l00459"></a>00459                         btScalar        m_reportedDistance;
<a name="l00460"></a>00460                         
<a name="l00461"></a>00461                         <span class="keywordtype">bool</span>            m_foundResult;
<a name="l00462"></a>00462                         btWithoutMarginResult(btDiscreteCollisionDetectorInterface::Result* result, btScalar marginOnA, btScalar marginOnB)
<a name="l00463"></a>00463                         :m_originalResult(result),
<a name="l00464"></a>00464                         m_marginOnA(marginOnA),
<a name="l00465"></a>00465                         m_marginOnB(marginOnB),
<a name="l00466"></a>00466                         m_foundResult(false)
<a name="l00467"></a>00467                         {
<a name="l00468"></a>00468                         }
<a name="l00469"></a>00469                         
<a name="l00470"></a>00470                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setShapeIdentifiersA(<span class="keywordtype">int</span> partId0,<span class="keywordtype">int</span> index0){}
<a name="l00471"></a>00471                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setShapeIdentifiersB(<span class="keywordtype">int</span> partId1,<span class="keywordtype">int</span> index1){}
<a name="l00472"></a>00472                         <span class="keyword">virtual</span> <span class="keywordtype">void</span> addContactPoint(<span class="keyword">const</span> btVector3&amp; normalOnBInWorld,<span class="keyword">const</span> btVector3&amp; pointInWorldOrg,btScalar depthOrg) 
<a name="l00473"></a>00473                         {
<a name="l00474"></a>00474                                 m_reportedDistance = depthOrg;
<a name="l00475"></a>00475                                 m_reportedNormalOnWorld = normalOnBInWorld;
<a name="l00476"></a>00476                                 
<a name="l00477"></a>00477                                 btVector3 adjustedPointB = pointInWorldOrg - normalOnBInWorld*m_marginOnB;
<a name="l00478"></a>00478                                 m_reportedDistance = depthOrg+(m_marginOnA+m_marginOnB);
<a name="l00479"></a>00479                                 <span class="keywordflow">if</span> (m_reportedDistance&lt;0.f)
<a name="l00480"></a>00480                                 {
<a name="l00481"></a>00481                                         m_foundResult = <span class="keyword">true</span>;                                   
<a name="l00482"></a>00482                                 }
<a name="l00483"></a>00483                                 m_originalResult-&gt;addContactPoint(normalOnBInWorld,adjustedPointB,m_reportedDistance);
<a name="l00484"></a>00484                         }
<a name="l00485"></a>00485                 };
<a name="l00486"></a>00486 
<a name="l00487"></a>00487                 
<a name="l00488"></a>00488                 btDummyResult dummy;
<a name="l00489"></a>00489 
<a name="l00491"></a>00491 
<a name="l00492"></a>00492                 btScalar min0Margin = min0-&gt;getShapeType()==BOX_SHAPE_PROXYTYPE? 0.f : min0-&gt;getMargin();
<a name="l00493"></a>00493                 btScalar min1Margin = min1-&gt;getShapeType()==BOX_SHAPE_PROXYTYPE? 0.f : min1-&gt;getMargin();
<a name="l00494"></a>00494 
<a name="l00495"></a>00495                 btWithoutMarginResult   withoutMargin(resultOut, min0Margin,min1Margin);
<a name="l00496"></a>00496 
<a name="l00497"></a>00497                 btPolyhedralConvexShape* polyhedronA = (btPolyhedralConvexShape*) min0;
<a name="l00498"></a>00498                 btPolyhedralConvexShape* polyhedronB = (btPolyhedralConvexShape*) min1;
<a name="l00499"></a>00499                 <span class="keywordflow">if</span> (polyhedronA-&gt;getConvexPolyhedron() &amp;&amp; polyhedronB-&gt;getConvexPolyhedron())
<a name="l00500"></a>00500                 {
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 
<a name="l00503"></a>00503                         
<a name="l00504"></a>00504 
<a name="l00505"></a>00505                         btScalar threshold = m_manifoldPtr-&gt;getContactBreakingThreshold();
<a name="l00506"></a>00506 
<a name="l00507"></a>00507                         btScalar minDist = -1e30f;
<a name="l00508"></a>00508                         btVector3 sepNormalWorldSpace;
<a name="l00509"></a>00509                         <span class="keywordtype">bool</span> foundSepAxis  = <span class="keyword">true</span>;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511                         <span class="keywordflow">if</span> (dispatchInfo.m_enableSatConvex)
<a name="l00512"></a>00512                         {
<a name="l00513"></a>00513                                 foundSepAxis = btPolyhedralContactClipping::findSeparatingAxis(
<a name="l00514"></a>00514                                         *polyhedronA-&gt;getConvexPolyhedron(), *polyhedronB-&gt;getConvexPolyhedron(),
<a name="l00515"></a>00515                                         body0Wrap-&gt;getWorldTransform(), 
<a name="l00516"></a>00516                                         body1Wrap-&gt;getWorldTransform(),
<a name="l00517"></a>00517                                         sepNormalWorldSpace,*resultOut);
<a name="l00518"></a>00518                         } <span class="keywordflow">else</span>
<a name="l00519"></a>00519                         {
<a name="l00520"></a>00520 <span class="preprocessor">#ifdef ZERO_MARGIN</span>
<a name="l00521"></a>00521 <span class="preprocessor"></span>                                gjkPairDetector.setIgnoreMargin(<span class="keyword">true</span>);
<a name="l00522"></a>00522                                 gjkPairDetector.getClosestPoints(input,*resultOut,dispatchInfo.m_debugDraw);
<a name="l00523"></a>00523 <span class="preprocessor">#else</span>
<a name="l00524"></a>00524 <span class="preprocessor"></span>
<a name="l00525"></a>00525 
<a name="l00526"></a>00526                                 gjkPairDetector.getClosestPoints(input,withoutMargin,dispatchInfo.m_debugDraw);
<a name="l00527"></a>00527                                 <span class="comment">//gjkPairDetector.getClosestPoints(input,dummy,dispatchInfo.m_debugDraw);</span>
<a name="l00528"></a>00528 <span class="preprocessor">#endif //ZERO_MARGIN</span>
<a name="l00529"></a>00529 <span class="preprocessor"></span>                                <span class="comment">//btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();</span>
<a name="l00530"></a>00530                                 <span class="comment">//if (l2&gt;SIMD_EPSILON)</span>
<a name="l00531"></a>00531                                 {
<a name="l00532"></a>00532                                         sepNormalWorldSpace = withoutMargin.m_reportedNormalOnWorld;<span class="comment">//gjkPairDetector.getCachedSeparatingAxis()*(1.f/l2);</span>
<a name="l00533"></a>00533                                         <span class="comment">//minDist = -1e30f;//gjkPairDetector.getCachedSeparatingDistance();</span>
<a name="l00534"></a>00534                                         minDist = withoutMargin.m_reportedDistance;<span class="comment">//gjkPairDetector.getCachedSeparatingDistance()+min0-&gt;getMargin()+min1-&gt;getMargin();</span>
<a name="l00535"></a>00535         
<a name="l00536"></a>00536 <span class="preprocessor">#ifdef ZERO_MARGIN</span>
<a name="l00537"></a>00537 <span class="preprocessor"></span>                                        foundSepAxis = <span class="keyword">true</span>;<span class="comment">//gjkPairDetector.getCachedSeparatingDistance()&lt;0.f;</span>
<a name="l00538"></a>00538 <span class="preprocessor">#else</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>                                        foundSepAxis = withoutMargin.m_foundResult &amp;&amp; minDist&lt;0;<span class="comment">//-(min0-&gt;getMargin()+min1-&gt;getMargin());</span>
<a name="l00540"></a>00540 <span class="preprocessor">#endif</span>
<a name="l00541"></a>00541 <span class="preprocessor"></span>                                }
<a name="l00542"></a>00542                         }
<a name="l00543"></a>00543                         <span class="keywordflow">if</span> (foundSepAxis)
<a name="l00544"></a>00544                         {
<a name="l00545"></a>00545                                 
<a name="l00546"></a>00546 <span class="comment">//                              printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());</span>
<a name="l00547"></a>00547 
<a name="l00548"></a>00548                                 worldVertsB1.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(0);
<a name="l00549"></a>00549                                 btPolyhedralContactClipping::clipHullAgainstHull(sepNormalWorldSpace, *polyhedronA-&gt;getConvexPolyhedron(), *polyhedronB-&gt;getConvexPolyhedron(),
<a name="l00550"></a>00550                                         body0Wrap-&gt;getWorldTransform(), 
<a name="l00551"></a>00551                                                                                                                                  body1Wrap-&gt;getWorldTransform(), minDist-threshold, threshold, worldVertsB1,worldVertsB2,
<a name="l00552"></a>00552                                                                                                                                  *resultOut);
<a name="l00553"></a>00553                                 
<a name="l00554"></a>00554                         }
<a name="l00555"></a>00555                         <span class="keywordflow">if</span> (m_ownManifold)
<a name="l00556"></a>00556                         {
<a name="l00557"></a>00557                                 resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00558"></a>00558                         }
<a name="l00559"></a>00559                         <span class="keywordflow">return</span>;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561                 } <span class="keywordflow">else</span>
<a name="l00562"></a>00562                 {
<a name="l00563"></a>00563                         <span class="comment">//we can also deal with convex versus triangle (without connectivity data)</span>
<a name="l00564"></a>00564                         <span class="keywordflow">if</span> (polyhedronA-&gt;getConvexPolyhedron() &amp;&amp; polyhedronB-&gt;getShapeType()==TRIANGLE_SHAPE_PROXYTYPE)
<a name="l00565"></a>00565                         {
<a name="l00566"></a>00566 
<a name="l00567"></a>00567                                 <a class="code" href="classbt_aligned_object_array.html">btVertexArray</a> vertices;
<a name="l00568"></a>00568                                 btTriangleShape* tri = (btTriangleShape*)polyhedronB;
<a name="l00569"></a>00569                                 vertices.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(     body1Wrap-&gt;getWorldTransform()*tri-&gt;m_vertices1[0]);
<a name="l00570"></a>00570                                 vertices.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(     body1Wrap-&gt;getWorldTransform()*tri-&gt;m_vertices1[1]);
<a name="l00571"></a>00571                                 vertices.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(     body1Wrap-&gt;getWorldTransform()*tri-&gt;m_vertices1[2]);
<a name="l00572"></a>00572                                 
<a name="l00573"></a>00573                                 <span class="comment">//tri-&gt;initializePolyhedralFeatures();</span>
<a name="l00574"></a>00574 
<a name="l00575"></a>00575                                 btScalar threshold = m_manifoldPtr-&gt;getContactBreakingThreshold();
<a name="l00576"></a>00576 
<a name="l00577"></a>00577                                 btVector3 sepNormalWorldSpace;
<a name="l00578"></a>00578                                 btScalar minDist =-1e30f;
<a name="l00579"></a>00579                                 btScalar maxDist = threshold;
<a name="l00580"></a>00580                                 
<a name="l00581"></a>00581                                 <span class="keywordtype">bool</span> foundSepAxis = <span class="keyword">false</span>;
<a name="l00582"></a>00582                                 <span class="keywordflow">if</span> (0)
<a name="l00583"></a>00583                                 {
<a name="l00584"></a>00584                                         polyhedronB-&gt;initializePolyhedralFeatures();
<a name="l00585"></a>00585                                          foundSepAxis = btPolyhedralContactClipping::findSeparatingAxis(
<a name="l00586"></a>00586                                         *polyhedronA-&gt;getConvexPolyhedron(), *polyhedronB-&gt;getConvexPolyhedron(),
<a name="l00587"></a>00587                                         body0Wrap-&gt;getWorldTransform(), 
<a name="l00588"></a>00588                                         body1Wrap-&gt;getWorldTransform(),
<a name="l00589"></a>00589                                         sepNormalWorldSpace,*resultOut);
<a name="l00590"></a>00590                                 <span class="comment">//       printf("sepNormalWorldSpace=%f,%f,%f\n",sepNormalWorldSpace.getX(),sepNormalWorldSpace.getY(),sepNormalWorldSpace.getZ());</span>
<a name="l00591"></a>00591 
<a name="l00592"></a>00592                                 } <span class="keywordflow">else</span>
<a name="l00593"></a>00593                                 {
<a name="l00594"></a>00594 <span class="preprocessor">#ifdef ZERO_MARGIN</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span>                                        gjkPairDetector.setIgnoreMargin(<span class="keyword">true</span>);
<a name="l00596"></a>00596                                         gjkPairDetector.getClosestPoints(input,*resultOut,dispatchInfo.m_debugDraw);
<a name="l00597"></a>00597 <span class="preprocessor">#else</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>                                        gjkPairDetector.getClosestPoints(input,dummy,dispatchInfo.m_debugDraw);
<a name="l00599"></a>00599 <span class="preprocessor">#endif//ZERO_MARGIN</span>
<a name="l00600"></a>00600 <span class="preprocessor"></span>                                        
<a name="l00601"></a>00601                                         btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();
<a name="l00602"></a>00602                                         <span class="keywordflow">if</span> (l2&gt;SIMD_EPSILON)
<a name="l00603"></a>00603                                         {
<a name="l00604"></a>00604                                                 sepNormalWorldSpace = gjkPairDetector.getCachedSeparatingAxis()*(1.f/l2);
<a name="l00605"></a>00605                                                 <span class="comment">//minDist = gjkPairDetector.getCachedSeparatingDistance();</span>
<a name="l00606"></a>00606                                                 <span class="comment">//maxDist = threshold;</span>
<a name="l00607"></a>00607                                                 minDist = gjkPairDetector.getCachedSeparatingDistance()-min0-&gt;getMargin()-min1-&gt;getMargin();
<a name="l00608"></a>00608                                                 foundSepAxis = <span class="keyword">true</span>;
<a name="l00609"></a>00609                                         }
<a name="l00610"></a>00610                                 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612                                 
<a name="l00613"></a>00613                         <span class="keywordflow">if</span> (foundSepAxis)
<a name="l00614"></a>00614                         {
<a name="l00615"></a>00615                                 worldVertsB2.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(0);
<a name="l00616"></a>00616                                 btPolyhedralContactClipping::clipFaceAgainstHull(sepNormalWorldSpace, *polyhedronA-&gt;getConvexPolyhedron(), 
<a name="l00617"></a>00617                                         body0Wrap-&gt;getWorldTransform(), vertices, worldVertsB2,minDist-threshold, maxDist, *resultOut);
<a name="l00618"></a>00618                         }
<a name="l00619"></a>00619                                 
<a name="l00620"></a>00620                                 
<a name="l00621"></a>00621                                 <span class="keywordflow">if</span> (m_ownManifold)
<a name="l00622"></a>00622                                 {
<a name="l00623"></a>00623                                         resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00624"></a>00624                                 }
<a name="l00625"></a>00625                                 
<a name="l00626"></a>00626                                 <span class="keywordflow">return</span>;
<a name="l00627"></a>00627                         }
<a name="l00628"></a>00628                         
<a name="l00629"></a>00629                 }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         }
<a name="l00633"></a>00633         
<a name="l00634"></a>00634         gjkPairDetector.getClosestPoints(input,*resultOut,dispatchInfo.m_debugDraw);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         <span class="comment">//now perform 'm_numPerturbationIterations' collision queries with the perturbated collision objects</span>
<a name="l00637"></a>00637         
<a name="l00638"></a>00638         <span class="comment">//perform perturbation when more then 'm_minimumPointsPerturbationThreshold' points</span>
<a name="l00639"></a>00639         <span class="keywordflow">if</span> (m_numPerturbationIterations &amp;&amp; resultOut-&gt;<a class="code" href="classbt_manifold_result.html#1c5ab928075fd6a12ebcf54e7e95b534">getPersistentManifold</a>()-&gt;getNumContacts() &lt; m_minimumPointsPerturbationThreshold)
<a name="l00640"></a>00640         {
<a name="l00641"></a>00641                 
<a name="l00642"></a>00642                 <span class="keywordtype">int</span> i;
<a name="l00643"></a>00643                 btVector3 v0,v1;
<a name="l00644"></a>00644                 btVector3 sepNormalWorldSpace;
<a name="l00645"></a>00645                 btScalar l2 = gjkPairDetector.getCachedSeparatingAxis().length2();
<a name="l00646"></a>00646         
<a name="l00647"></a>00647                 <span class="keywordflow">if</span> (l2&gt;SIMD_EPSILON)
<a name="l00648"></a>00648                 {
<a name="l00649"></a>00649                         sepNormalWorldSpace = gjkPairDetector.getCachedSeparatingAxis()*(1.f/l2);
<a name="l00650"></a>00650                         
<a name="l00651"></a>00651                         btPlaneSpace1(sepNormalWorldSpace,v0,v1);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 
<a name="l00654"></a>00654                         <span class="keywordtype">bool</span> perturbeA = <span class="keyword">true</span>;
<a name="l00655"></a>00655                         <span class="keyword">const</span> btScalar angleLimit = 0.125f * SIMD_PI;
<a name="l00656"></a>00656                         btScalar perturbeAngle;
<a name="l00657"></a>00657                         btScalar radiusA = min0-&gt;getAngularMotionDisc();
<a name="l00658"></a>00658                         btScalar radiusB = min1-&gt;getAngularMotionDisc();
<a name="l00659"></a>00659                         <span class="keywordflow">if</span> (radiusA &lt; radiusB)
<a name="l00660"></a>00660                         {
<a name="l00661"></a>00661                                 perturbeAngle = gContactBreakingThreshold /radiusA;
<a name="l00662"></a>00662                                 perturbeA = <span class="keyword">true</span>;
<a name="l00663"></a>00663                         } <span class="keywordflow">else</span>
<a name="l00664"></a>00664                         {
<a name="l00665"></a>00665                                 perturbeAngle = gContactBreakingThreshold / radiusB;
<a name="l00666"></a>00666                                 perturbeA = <span class="keyword">false</span>;
<a name="l00667"></a>00667                         }
<a name="l00668"></a>00668                         <span class="keywordflow">if</span> ( perturbeAngle &gt; angleLimit ) 
<a name="l00669"></a>00669                                         perturbeAngle = angleLimit;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671                         btTransform unPerturbedTransform;
<a name="l00672"></a>00672                         <span class="keywordflow">if</span> (perturbeA)
<a name="l00673"></a>00673                         {
<a name="l00674"></a>00674                                 unPerturbedTransform = input.m_transformA;
<a name="l00675"></a>00675                         } <span class="keywordflow">else</span>
<a name="l00676"></a>00676                         {
<a name="l00677"></a>00677                                 unPerturbedTransform = input.m_transformB;
<a name="l00678"></a>00678                         }
<a name="l00679"></a>00679                         
<a name="l00680"></a>00680                         <span class="keywordflow">for</span> ( i=0;i&lt;m_numPerturbationIterations;i++)
<a name="l00681"></a>00681                         {
<a name="l00682"></a>00682                                 <span class="keywordflow">if</span> (v0.length2()&gt;SIMD_EPSILON)
<a name="l00683"></a>00683                                 {
<a name="l00684"></a>00684                                 <a class="code" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination...">btQuaternion</a> perturbeRot(v0,perturbeAngle);
<a name="l00685"></a>00685                                 btScalar iterationAngle = i*(SIMD_2_PI/btScalar(m_numPerturbationIterations));
<a name="l00686"></a>00686                                 <a class="code" href="classbt_quaternion.html" title="The btQuaternion implements quaternion to perform linear algebra rotations in combination...">btQuaternion</a> rotq(sepNormalWorldSpace,iterationAngle);
<a name="l00687"></a>00687                                 
<a name="l00688"></a>00688                                 
<a name="l00689"></a>00689                                 <span class="keywordflow">if</span> (perturbeA)
<a name="l00690"></a>00690                                 {
<a name="l00691"></a>00691                                         input.m_transformA.setBasis(  btMatrix3x3(rotq.inverse()*perturbeRot*rotq)*body0Wrap-&gt;getWorldTransform().getBasis());
<a name="l00692"></a>00692                                         input.m_transformB = body1Wrap-&gt;getWorldTransform();
<a name="l00693"></a>00693 <span class="preprocessor">        #ifdef DEBUG_CONTACTS</span>
<a name="l00694"></a>00694 <span class="preprocessor"></span>                                        dispatchInfo.m_debugDraw-&gt;drawTransform(input.m_transformA,10.0);
<a name="l00695"></a>00695 <span class="preprocessor">        #endif //DEBUG_CONTACTS</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>                                } <span class="keywordflow">else</span>
<a name="l00697"></a>00697                                 {
<a name="l00698"></a>00698                                         input.m_transformA = body0Wrap-&gt;getWorldTransform();
<a name="l00699"></a>00699                                         input.m_transformB.setBasis( btMatrix3x3(rotq.inverse()*perturbeRot*rotq)*body1Wrap-&gt;getWorldTransform().getBasis());
<a name="l00700"></a>00700 <span class="preprocessor">        #ifdef DEBUG_CONTACTS</span>
<a name="l00701"></a>00701 <span class="preprocessor"></span>                                        dispatchInfo.m_debugDraw-&gt;drawTransform(input.m_transformB,10.0);
<a name="l00702"></a>00702 <span class="preprocessor">        #endif</span>
<a name="l00703"></a>00703 <span class="preprocessor"></span>                                }
<a name="l00704"></a>00704                                 
<a name="l00705"></a>00705                                 btPerturbedContactResult perturbedResultOut(resultOut,input.m_transformA,input.m_transformB,unPerturbedTransform,perturbeA,dispatchInfo.m_debugDraw);
<a name="l00706"></a>00706                                 gjkPairDetector.getClosestPoints(input,perturbedResultOut,dispatchInfo.m_debugDraw);
<a name="l00707"></a>00707                                 }
<a name="l00708"></a>00708                         }
<a name="l00709"></a>00709                 }
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="preprocessor">#ifdef USE_SEPDISTANCE_UTIL2</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (dispatchInfo.m_useConvexConservativeDistanceUtil &amp;&amp; (sepDist&gt;SIMD_EPSILON))
<a name="l00716"></a>00716         {
<a name="l00717"></a>00717                 m_sepDistance.initSeparatingDistance(gjkPairDetector.getCachedSeparatingAxis(),sepDist,body0-&gt;getWorldTransform(),body1-&gt;getWorldTransform());
<a name="l00718"></a>00718         }
<a name="l00719"></a>00719 <span class="preprocessor">#endif //USE_SEPDISTANCE_UTIL2</span>
<a name="l00720"></a>00720 <span class="preprocessor"></span>
<a name="l00721"></a>00721 
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="keywordflow">if</span> (m_ownManifold)
<a name="l00725"></a>00725         {
<a name="l00726"></a>00726                 resultOut-&gt;<a class="code" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1">refreshContactPoints</a>();
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_convex_convex_algorithm_b566631355a17f7a4bcbddf9454eb9e5_cgraph.png" border="0" usemap="#classbt_convex_convex_algorithm_b566631355a17f7a4bcbddf9454eb9e5_cgraph_map" alt=""></center>
<map name="classbt_convex_convex_algorithm_b566631355a17f7a4bcbddf9454eb9e5_cgraph_map">
<area shape="rect" href="classbt_manifold_result.html#ebe32f0c202d988d0458e88d768602c6" title="btManifoldResult::addContactPoint" alt="" coords="372,31,593,57"><area shape="rect" href="classbt_gjk_pair_detector.html#1a812a6b875660bc66de1a60bf6a76ab" title="btGjkPairDetector::getCachedSeparatingAxis" alt="" coords="341,81,624,108"><area shape="rect" href="classbt_gjk_pair_detector.html#e27d863f35ce718af83c46a896e80fd6" title="btGjkPairDetector::getCachedSeparatingDistance" alt="" coords="329,132,636,159"><area shape="rect" href="classbt_gjk_pair_detector.html#42505a0ccc728c82595febe9af3a3bc8" title="btGjkPairDetector::getClosestPoints" alt="" coords="367,183,599,209"><area shape="rect" href="classbt_dispatcher.html#8c7798c84a4ec8da239b70797fa5abf2" title="btDispatcher::getNewManifold" alt="" coords="387,233,579,260"><area shape="rect" href="classbt_manifold_result.html#1c5ab928075fd6a12ebcf54e7e95b534" title="btManifoldResult::getPersistentManifold" alt="" coords="357,284,608,311"><area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="375,335,591,361"><area shape="rect" href="classbt_manifold_result.html#dbcfd865252ac9dc8a3543f404e2dcf1" title="btManifoldResult::refreshContactPoints" alt="" coords="360,385,605,412"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="389,436,576,463"><area shape="rect" href="classbt_gjk_pair_detector.html#93e9752920c57c39faca247fc005750e" title="don&#39;t use setIgnoreMargin, it&#39;s for Bullet&#39;s internal use" alt="" coords="371,487,595,513"><area shape="rect" href="classbt_gjk_pair_detector.html#a1c126f716f8c80f355ad48a5234ca73" title="btGjkPairDetector::setMinkowskiA" alt="" coords="373,537,592,564"><area shape="rect" href="classbt_gjk_pair_detector.html#ee8fc2c182e482574ba9e819eea7b23a" title="btGjkPairDetector::setMinkowskiB" alt="" coords="373,588,592,615"><area shape="rect" href="classbt_manifold_result.html#7a46d46b9a13c2896695e458c1d6df1f" title="btManifoldResult::setPersistentManifold" alt="" coords="357,639,608,665"><area shape="rect" href="classbt_manifold_result.html#162717dce3ef3a756ae55ec04a179ed5" title="User can override this material combiner by implementing gContactAddedCallback and..." alt="" coords="696,5,973,32"><area shape="rect" href="classbt_manifold_result.html#a4419fc3b0d13ccc2cbfd7739b047c04" title="in the future we can let the user override the methods to combine restitution and..." alt="" coords="687,56,983,83"></map>
</div>

</div>
</div><p>
<a class="anchor" name="55f817b690c4e858d2b02607b382ce6b"></a><!-- doxytag: member="btConvexConvexAlgorithm::calculateTimeOfImpact" ref="55f817b690c4e858d2b02607b382ce6b" args="(btCollisionObject *body0, btCollisionObject *body1, const btDispatcherInfo &amp;dispatchInfo, btManifoldResult *resultOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btScalar btConvexConvexAlgorithm::calculateTimeOfImpact           </td>
          <td>(</td>
          <td class="paramtype">btCollisionObject *&nbsp;</td>
          <td class="paramname"> <em>body0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btCollisionObject *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btDispatcherInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatchInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *&nbsp;</td>
          <td class="paramname"> <em>resultOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold<p>
Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold col0-&gt;m_worldTransform,<p>
Convex0 against sphere for Convex1<p>
Simplification, one object is simplified as a sphere<p>
Sphere (for convex0) against Convex1<p>
Simplification, one object is simplified as a sphere 
<p>Implements <a class="el" href="classbt_collision_algorithm.html">btCollisionAlgorithm</a>.</p>

<p>Definition at line <a class="el" href="bt_convex_convex_algorithm_8cpp-source.html#l00734">734</a> of file <a class="el" href="bt_convex_convex_algorithm_8cpp-source.html">btConvexConvexAlgorithm.cpp</a>.</p>

<p>References <a class="el" href="bt_gjk_convex_cast_8cpp-source.html#l00037">btGjkConvexCast::calcTimeOfImpact()</a>, and <a class="el" href="_g_l_m_2include_2_g_l_m_2gtx_2quaternion_8inl-source.html#l00164">glm::length2()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00735"></a>00735 {
<a name="l00736"></a>00736         (void)resultOut;
<a name="l00737"></a>00737         (void)dispatchInfo;
<a name="l00739"></a>00739     
<a name="l00742"></a>00742         btScalar resultFraction = btScalar(1.);
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         btScalar squareMot0 = (col0-&gt;getInterpolationWorldTransform().getOrigin() - col0-&gt;getWorldTransform().getOrigin()).<a class="code" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d">length2</a>();
<a name="l00746"></a>00746         btScalar squareMot1 = (col1-&gt;getInterpolationWorldTransform().getOrigin() - col1-&gt;getWorldTransform().getOrigin()).<a class="code" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d">length2</a>();
<a name="l00747"></a>00747     
<a name="l00748"></a>00748         <span class="keywordflow">if</span> (squareMot0 &lt; col0-&gt;getCcdSquareMotionThreshold() &amp;&amp;
<a name="l00749"></a>00749                 squareMot1 &lt; col1-&gt;getCcdSquareMotionThreshold())
<a name="l00750"></a>00750                 <span class="keywordflow">return</span> resultFraction;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (disableCcd)
<a name="l00753"></a>00753                 <span class="keywordflow">return</span> btScalar(1.);
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         <span class="comment">//An adhoc way of testing the Continuous Collision Detection algorithms</span>
<a name="l00757"></a>00757         <span class="comment">//One object is approximated as a sphere, to simplify things</span>
<a name="l00758"></a>00758         <span class="comment">//Starting in penetration should report no time of impact</span>
<a name="l00759"></a>00759         <span class="comment">//For proper CCD, better accuracy and handling of 'allowed' penetration should be added</span>
<a name="l00760"></a>00760         <span class="comment">//also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)</span>
<a name="l00761"></a>00761 
<a name="l00762"></a>00762                 
<a name="l00764"></a>00764         {
<a name="l00765"></a>00765                 btConvexShape* convex0 = <span class="keyword">static_cast&lt;</span>btConvexShape*<span class="keyword">&gt;</span>(col0-&gt;getCollisionShape());
<a name="l00766"></a>00766 
<a name="l00767"></a>00767                 btSphereShape   sphere1(col1-&gt;getCcdSweptSphereRadius()); <span class="comment">//todo: allow non-zero sphere sizes, for better approximation</span>
<a name="l00768"></a>00768                 <a class="code" href="structbt_convex_cast_1_1_cast_result.html">btConvexCast::CastResult</a> result;
<a name="l00769"></a>00769                 btVoronoiSimplexSolver voronoiSimplex;
<a name="l00770"></a>00770                 <span class="comment">//SubsimplexConvexCast ccd0(&amp;sphere,min0,&amp;voronoiSimplex);</span>
<a name="l00772"></a>00772 <span class="comment"></span>                <a class="code" href="classbt_gjk_convex_cast.html" title="GjkConvexCast performs a raycast on a convex object using support mapping.">btGjkConvexCast</a> ccd1( convex0 ,&amp;sphere1,&amp;voronoiSimplex);
<a name="l00773"></a>00773                 <span class="comment">//ContinuousConvexCollision ccd(min0,min1,&amp;voronoiSimplex,0);</span>
<a name="l00774"></a>00774                 <span class="keywordflow">if</span> (ccd1.calcTimeOfImpact(col0-&gt;getWorldTransform(),col0-&gt;getInterpolationWorldTransform(),
<a name="l00775"></a>00775                         col1-&gt;getWorldTransform(),col1-&gt;getInterpolationWorldTransform(),result))
<a name="l00776"></a>00776                 {
<a name="l00777"></a>00777                 
<a name="l00778"></a>00778                         <span class="comment">//store result.m_fraction in both bodies</span>
<a name="l00779"></a>00779                 
<a name="l00780"></a>00780                         <span class="keywordflow">if</span> (col0-&gt;getHitFraction()&gt; result.m_fraction)
<a name="l00781"></a>00781                                 col0-&gt;setHitFraction( result.m_fraction );
<a name="l00782"></a>00782 
<a name="l00783"></a>00783                         <span class="keywordflow">if</span> (col1-&gt;getHitFraction() &gt; result.m_fraction)
<a name="l00784"></a>00784                                 col1-&gt;setHitFraction( result.m_fraction);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786                         <span class="keywordflow">if</span> (resultFraction &gt; result.m_fraction)
<a name="l00787"></a>00787                                 resultFraction = result.m_fraction;
<a name="l00788"></a>00788 
<a name="l00789"></a>00789                 }
<a name="l00790"></a>00790                 
<a name="l00791"></a>00791                 
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 
<a name="l00794"></a>00794         }
<a name="l00795"></a>00795 
<a name="l00797"></a>00797         {
<a name="l00798"></a>00798                 btConvexShape* convex1 = <span class="keyword">static_cast&lt;</span>btConvexShape*<span class="keyword">&gt;</span>(col1-&gt;getCollisionShape());
<a name="l00799"></a>00799 
<a name="l00800"></a>00800                 btSphereShape   sphere0(col0-&gt;getCcdSweptSphereRadius()); <span class="comment">//todo: allow non-zero sphere sizes, for better approximation</span>
<a name="l00801"></a>00801                 <a class="code" href="structbt_convex_cast_1_1_cast_result.html">btConvexCast::CastResult</a> result;
<a name="l00802"></a>00802                 btVoronoiSimplexSolver voronoiSimplex;
<a name="l00803"></a>00803                 <span class="comment">//SubsimplexConvexCast ccd0(&amp;sphere,min0,&amp;voronoiSimplex);</span>
<a name="l00805"></a>00805 <span class="comment"></span>                <a class="code" href="classbt_gjk_convex_cast.html" title="GjkConvexCast performs a raycast on a convex object using support mapping.">btGjkConvexCast</a> ccd1(&amp;sphere0,convex1,&amp;voronoiSimplex);
<a name="l00806"></a>00806                 <span class="comment">//ContinuousConvexCollision ccd(min0,min1,&amp;voronoiSimplex,0);</span>
<a name="l00807"></a>00807                 <span class="keywordflow">if</span> (ccd1.calcTimeOfImpact(col0-&gt;getWorldTransform(),col0-&gt;getInterpolationWorldTransform(),
<a name="l00808"></a>00808                         col1-&gt;getWorldTransform(),col1-&gt;getInterpolationWorldTransform(),result))
<a name="l00809"></a>00809                 {
<a name="l00810"></a>00810                 
<a name="l00811"></a>00811                         <span class="comment">//store result.m_fraction in both bodies</span>
<a name="l00812"></a>00812                 
<a name="l00813"></a>00813                         <span class="keywordflow">if</span> (col0-&gt;getHitFraction()      &gt; result.m_fraction)
<a name="l00814"></a>00814                                 col0-&gt;setHitFraction( result.m_fraction);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816                         <span class="keywordflow">if</span> (col1-&gt;getHitFraction() &gt; result.m_fraction)
<a name="l00817"></a>00817                                 col1-&gt;setHitFraction( result.m_fraction);
<a name="l00818"></a>00818 
<a name="l00819"></a>00819                         <span class="keywordflow">if</span> (resultFraction &gt; result.m_fraction)
<a name="l00820"></a>00820                                 resultFraction = result.m_fraction;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822                 }
<a name="l00823"></a>00823         }
<a name="l00824"></a>00824         
<a name="l00825"></a>00825         <span class="keywordflow">return</span> resultFraction;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_convex_convex_algorithm_55f817b690c4e858d2b02607b382ce6b_cgraph.png" border="0" usemap="#classbt_convex_convex_algorithm_55f817b690c4e858d2b02607b382ce6b_cgraph_map" alt=""></center>
<map name="classbt_convex_convex_algorithm_55f817b690c4e858d2b02607b382ce6b_cgraph_map">
<area shape="rect" href="classbt_gjk_convex_cast.html#814009e1ebc582495689f365a42ce2c1" title="cast a convex against another convex object" alt="" coords="367,31,599,57"><area shape="rect" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d" title="glm::length2" alt="" coords="437,81,528,108"><area shape="rect" href="structbt_convex_cast_1_1_cast_result.html#febcf038c88ef123c0570d5ab79cb3c6" title="btConvexCast::CastResult::DebugDraw" alt="" coords="648,5,896,32"><area shape="rect" href="classbt_gjk_pair_detector.html#42505a0ccc728c82595febe9af3a3bc8" title="btGjkPairDetector::getClosestPoints" alt="" coords="656,56,888,83"></map>
</div>

</div>
</div><p>
<a class="anchor" name="a2a195cdd3b45c169c15ea2de85c4038"></a><!-- doxytag: member="btConvexConvexAlgorithm::getAllContactManifolds" ref="a2a195cdd3b45c169c15ea2de85c4038" args="(btManifoldArray &amp;manifoldArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btConvexConvexAlgorithm::getAllContactManifolds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbt_aligned_object_array.html">btManifoldArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>manifoldArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
should we use m_ownManifold to avoid adding duplicates? 
<p>Implements <a class="el" href="classbt_collision_algorithm.html">btCollisionAlgorithm</a>.</p>

<p>Definition at line <a class="el" href="bt_convex_convex_algorithm_8h-source.html#l00072">72</a> of file <a class="el" href="bt_convex_convex_algorithm_8h-source.html">btConvexConvexAlgorithm.h</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00073"></a>00073         {
<a name="l00075"></a>00075                 <span class="keywordflow">if</span> (m_manifoldPtr &amp;&amp; m_ownManifold)
<a name="l00076"></a>00076                         manifoldArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(m_manifoldPtr);
<a name="l00077"></a>00077         }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_convex_convex_algorithm_a2a195cdd3b45c169c15ea2de85c4038_cgraph.png" border="0" usemap="#classbt_convex_convex_algorithm_a2a195cdd3b45c169c15ea2de85c4038_cgraph_map" alt=""></center>
<map name="classbt_convex_convex_algorithm_a2a195cdd3b45c169c15ea2de85c4038_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="365,5,581,32"></map>
</div>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/<a class="el" href="bt_convex_convex_algorithm_8h-source.html">btConvexConvexAlgorithm.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/<a class="el" href="bt_convex_convex_algorithm_8cpp-source.html">btConvexConvexAlgorithm.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:00:57 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
