<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btGjkPairDetector Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btGjkPairDetector Class Reference</h1><!-- doxytag: class="btGjkPairDetector" --><!-- doxytag: inherits="btDiscreteCollisionDetectorInterface" --><a class="el" href="classbt_gjk_pair_detector.html" title="btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface">btGjkPairDetector</a> uses GJK to implement the <a class="el" href="structbt_discrete_collision_detector_interface.html">btDiscreteCollisionDetectorInterface</a>  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="bt_gjk_pair_detector_8h-source.html">btGjkPairDetector.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for btGjkPairDetector:</div>
<div class="dynsection">
<p><center><img src="classbt_gjk_pair_detector__inherit__graph.png" border="0" usemap="#bt_gjk_pair_detector__inherit__map" alt="Inheritance graph"></center>
<map name="bt_gjk_pair_detector__inherit__map">
<area shape="rect" href="structbt_discrete_collision_detector_interface.html" title="btDiscreteCollisionDetectorInterface" alt="" coords="5,5,232,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for btGjkPairDetector:</div>
<div class="dynsection">
<p><center><img src="classbt_gjk_pair_detector__coll__graph.png" border="0" usemap="#bt_gjk_pair_detector__coll__map" alt="Collaboration graph"></center>
<map name="bt_gjk_pair_detector__coll__map">
<area shape="rect" href="structbt_discrete_collision_detector_interface.html" title="btDiscreteCollisionDetectorInterface" alt="" coords="5,5,232,32"><area shape="rect" href="classbt_convex_penetration_depth_solver.html" title="ConvexPenetrationDepthSolver provides an interface for penetration depth calculation..." alt="" coords="256,5,464,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_gjk_pair_detector-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_gjk_pair_detector.html#bc29953dd7aee59e9ca887963c26c8c2">getClosestPointsNonVirtual</a> (const ClosestPointInput &amp;input, Result &amp;output, class <a class="el" href="classbt_i_debug_draw.html">btIDebugDraw</a> *debugDraw)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93e9752920c57c39faca247fc005750e"></a><!-- doxytag: member="btGjkPairDetector::setIgnoreMargin" ref="93e9752920c57c39faca247fc005750e" args="(bool ignoreMargin)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_gjk_pair_detector.html#93e9752920c57c39faca247fc005750e">setIgnoreMargin</a> (bool ignoreMargin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">don't use setIgnoreMargin, it's for Bullet's internal use <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classbt_gjk_pair_detector.html" title="btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface">btGjkPairDetector</a> uses GJK to implement the <a class="el" href="structbt_discrete_collision_detector_interface.html">btDiscreteCollisionDetectorInterface</a> 
<p>Definition at line <a class="el" href="bt_gjk_pair_detector_8h-source.html#l00030">30</a> of file <a class="el" href="bt_gjk_pair_detector_8h-source.html">btGjkPairDetector.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="bc29953dd7aee59e9ca887963c26c8c2"></a><!-- doxytag: member="btGjkPairDetector::getClosestPointsNonVirtual" ref="bc29953dd7aee59e9ca887963c26c8c2" args="(const ClosestPointInput &amp;input, Result &amp;output, class btIDebugDraw *debugDraw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btGjkPairDetector::getClosestPointsNonVirtual           </td>
          <td>(</td>
          <td class="paramtype">const ClosestPointInput &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classbt_i_debug_draw.html">btIDebugDraw</a> *&nbsp;</td>
          <td class="paramname"> <em>debugDraw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
this is another degenerate case, where the initial GJK calculation reports a degenerate case EPA reports no penetration, and the second GJK (using the supporting vector without margin) reports a valid positive distance. Use the results of the second GJK instead of failing. thanks to Jacob.Langford for the reproduction case <a href="http://code.google.com/p/bullet/issues/detail?id=250">http://code.google.com/p/bullet/issues/detail?id=250</a><p>
todo: need to track down this EPA penetration solver degeneracy the penetration solver reports penetration but the contact normal connecting the contact points is pointing in the opposite direction until then, detect the issue and revert the normal 
<p>Definition at line <a class="el" href="bt_gjk_pair_detector_8cpp-source.html#l00089">89</a> of file <a class="el" href="bt_gjk_pair_detector_8cpp-source.html">btGjkPairDetector.cpp</a>.</p>

<p>References btConvexPenetrationDepthSolver::calcPenDepth(), <a class="el" href="func__geometric_8inl-source.html#l00128">glm::distance()</a>, <a class="el" href="group__gtx__norm.html#g205e08f24b9e35f9f892b563f2b8dd94">glm::distance2()</a>, <a class="el" href="group__gtc__quaternion.html#g4ce8bce2b7dc8206a31cfb8e7b779b76">glm::dot()</a>, and <a class="el" href="_g_l_m_2include_2_g_l_m_2gtc_2quaternion_8inl-source.html#l00402">glm::length()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00091"></a>00091 {
<a name="l00092"></a>00092         m_cachedSeparatingDistance = 0.f;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         btScalar <a class="code" href="group__core__func__geometric.html#gd21e00cab9f8b4eb6d1214a16dee06c7">distance</a>=btScalar(0.);
<a name="l00095"></a>00095         btVector3       normalInB(btScalar(0.),btScalar(0.),btScalar(0.));
<a name="l00096"></a>00096 
<a name="l00097"></a>00097         btVector3 pointOnA,pointOnB;
<a name="l00098"></a>00098         btTransform     localTransA = input.m_transformA;
<a name="l00099"></a>00099         btTransform localTransB = input.m_transformB;
<a name="l00100"></a>00100         btVector3 positionOffset=(localTransA.getOrigin() + localTransB.getOrigin()) * btScalar(0.5);
<a name="l00101"></a>00101         localTransA.getOrigin() -= positionOffset;
<a name="l00102"></a>00102         localTransB.getOrigin() -= positionOffset;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="keywordtype">bool</span> check2d = m_minkowskiA-&gt;isConvex2d() &amp;&amp; m_minkowskiB-&gt;isConvex2d();
<a name="l00105"></a>00105 
<a name="l00106"></a>00106         btScalar marginA = m_marginA;
<a name="l00107"></a>00107         btScalar marginB = m_marginB;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         gNumGjkChecks++;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111         <span class="comment">//for CCD we don't use margins</span>
<a name="l00112"></a>00112         <span class="keywordflow">if</span> (m_ignoreMargin)
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114                 marginA = btScalar(0.);
<a name="l00115"></a>00115                 marginB = btScalar(0.);
<a name="l00116"></a>00116         }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         m_curIter = 0;
<a name="l00119"></a>00119         <span class="keywordtype">int</span> gGjkMaxIter = 1000;<span class="comment">//this is to catch invalid input, perhaps check for #NaN?</span>
<a name="l00120"></a>00120         m_cachedSeparatingAxis.setValue(0,1,0);
<a name="l00121"></a>00121 
<a name="l00122"></a>00122         <span class="keywordtype">bool</span> isValid = <span class="keyword">false</span>;
<a name="l00123"></a>00123         <span class="keywordtype">bool</span> checkSimplex = <span class="keyword">false</span>;
<a name="l00124"></a>00124         <span class="keywordtype">bool</span> checkPenetration = <span class="keyword">true</span>;
<a name="l00125"></a>00125         m_degenerateSimplex = 0;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         m_lastUsedMethod = -1;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129         {
<a name="l00130"></a>00130                 btScalar squaredDistance = BT_LARGE_FLOAT;
<a name="l00131"></a>00131                 btScalar delta = btScalar(0.);
<a name="l00132"></a>00132                 
<a name="l00133"></a>00133                 btScalar margin = marginA + marginB;
<a name="l00134"></a>00134                 
<a name="l00135"></a>00135                 
<a name="l00136"></a>00136 
<a name="l00137"></a>00137                 m_simplexSolver-&gt;reset();
<a name="l00138"></a>00138                 
<a name="l00139"></a>00139                 <span class="keywordflow">for</span> ( ; ; )
<a name="l00140"></a>00140                 <span class="comment">//while (true)</span>
<a name="l00141"></a>00141                 {
<a name="l00142"></a>00142 
<a name="l00143"></a>00143                         btVector3 seperatingAxisInA = (-m_cachedSeparatingAxis)* input.m_transformA.getBasis();
<a name="l00144"></a>00144                         btVector3 seperatingAxisInB = m_cachedSeparatingAxis* input.m_transformB.getBasis();
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147                         btVector3 pInA = m_minkowskiA-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
<a name="l00148"></a>00148                         btVector3 qInB = m_minkowskiB-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150                         btVector3  pWorld = localTransA(pInA);  
<a name="l00151"></a>00151                         btVector3  qWorld = localTransB(qInB);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 
<a name="l00154"></a>00154                         <span class="keywordflow">if</span> (check2d)
<a name="l00155"></a>00155                         {
<a name="l00156"></a>00156                                 pWorld[2] = 0.f;
<a name="l00157"></a>00157                                 qWorld[2] = 0.f;
<a name="l00158"></a>00158                         }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160                         btVector3 w     = pWorld - qWorld;
<a name="l00161"></a>00161                         delta = m_cachedSeparatingAxis.dot(w);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163                         <span class="comment">// potential exit, they don't overlap</span>
<a name="l00164"></a>00164                         <span class="keywordflow">if</span> ((delta &gt; btScalar(0.0)) &amp;&amp; (delta * delta &gt; squaredDistance * input.m_maximumDistanceSquared)) 
<a name="l00165"></a>00165                         {
<a name="l00166"></a>00166                                 m_degenerateSimplex = 10;
<a name="l00167"></a>00167                                 checkSimplex=<span class="keyword">true</span>;
<a name="l00168"></a>00168                                 <span class="comment">//checkPenetration = false;</span>
<a name="l00169"></a>00169                                 <span class="keywordflow">break</span>;
<a name="l00170"></a>00170                         }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172                         <span class="comment">//exit 0: the new point is already in the simplex, or we didn't come any closer</span>
<a name="l00173"></a>00173                         <span class="keywordflow">if</span> (m_simplexSolver-&gt;inSimplex(w))
<a name="l00174"></a>00174                         {
<a name="l00175"></a>00175                                 m_degenerateSimplex = 1;
<a name="l00176"></a>00176                                 checkSimplex = <span class="keyword">true</span>;
<a name="l00177"></a>00177                                 <span class="keywordflow">break</span>;
<a name="l00178"></a>00178                         }
<a name="l00179"></a>00179                         <span class="comment">// are we getting any closer ?</span>
<a name="l00180"></a>00180                         btScalar f0 = squaredDistance - delta;
<a name="l00181"></a>00181                         btScalar f1 = squaredDistance * REL_ERROR2;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183                         <span class="keywordflow">if</span> (f0 &lt;= f1)
<a name="l00184"></a>00184                         {
<a name="l00185"></a>00185                                 <span class="keywordflow">if</span> (f0 &lt;= btScalar(0.))
<a name="l00186"></a>00186                                 {
<a name="l00187"></a>00187                                         m_degenerateSimplex = 2;
<a name="l00188"></a>00188                                 } <span class="keywordflow">else</span>
<a name="l00189"></a>00189                                 {
<a name="l00190"></a>00190                                         m_degenerateSimplex = 11;
<a name="l00191"></a>00191                                 }
<a name="l00192"></a>00192                                 checkSimplex = <span class="keyword">true</span>;
<a name="l00193"></a>00193                                 <span class="keywordflow">break</span>;
<a name="l00194"></a>00194                         }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196                         <span class="comment">//add current vertex to simplex</span>
<a name="l00197"></a>00197                         m_simplexSolver-&gt;addVertex(w, pWorld, qWorld);
<a name="l00198"></a>00198                         btVector3 newCachedSeparatingAxis;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200                         <span class="comment">//calculate the closest point to the origin (update vector v)</span>
<a name="l00201"></a>00201                         <span class="keywordflow">if</span> (!m_simplexSolver-&gt;closest(newCachedSeparatingAxis))
<a name="l00202"></a>00202                         {
<a name="l00203"></a>00203                                 m_degenerateSimplex = 3;
<a name="l00204"></a>00204                                 checkSimplex = <span class="keyword">true</span>;
<a name="l00205"></a>00205                                 <span class="keywordflow">break</span>;
<a name="l00206"></a>00206                         }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208                         <span class="keywordflow">if</span>(newCachedSeparatingAxis.length2()&lt;REL_ERROR2)
<a name="l00209"></a>00209             {
<a name="l00210"></a>00210                                 m_cachedSeparatingAxis = newCachedSeparatingAxis;
<a name="l00211"></a>00211                 m_degenerateSimplex = 6;
<a name="l00212"></a>00212                 checkSimplex = <span class="keyword">true</span>;
<a name="l00213"></a>00213                 <span class="keywordflow">break</span>;
<a name="l00214"></a>00214             }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216                         btScalar previousSquaredDistance = squaredDistance;
<a name="l00217"></a>00217                         squaredDistance = newCachedSeparatingAxis.length2();
<a name="l00218"></a>00218 <span class="preprocessor">#if 0</span>
<a name="l00220"></a>00220 <span class="preprocessor">                        if (squaredDistance&gt;previousSquaredDistance)</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>                        {
<a name="l00222"></a>00222                                 m_degenerateSimplex = 7;
<a name="l00223"></a>00223                                 squaredDistance = previousSquaredDistance;
<a name="l00224"></a>00224                 checkSimplex = <span class="keyword">false</span>;
<a name="l00225"></a>00225                 <span class="keywordflow">break</span>;
<a name="l00226"></a>00226                         }
<a name="l00227"></a>00227 <span class="preprocessor">#endif //</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span>                        
<a name="l00229"></a>00229 
<a name="l00230"></a>00230                         <span class="comment">//redundant m_simplexSolver-&gt;compute_points(pointOnA, pointOnB);</span>
<a name="l00231"></a>00231 
<a name="l00232"></a>00232                         <span class="comment">//are we getting any closer ?</span>
<a name="l00233"></a>00233                         <span class="keywordflow">if</span> (previousSquaredDistance - squaredDistance &lt;= SIMD_EPSILON * previousSquaredDistance) 
<a name="l00234"></a>00234                         { 
<a name="l00235"></a>00235 <span class="comment">//                              m_simplexSolver-&gt;backup_closest(m_cachedSeparatingAxis);</span>
<a name="l00236"></a>00236                                 checkSimplex = <span class="keyword">true</span>;
<a name="l00237"></a>00237                                 m_degenerateSimplex = 12;
<a name="l00238"></a>00238                                 
<a name="l00239"></a>00239                                 <span class="keywordflow">break</span>;
<a name="l00240"></a>00240                         }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242                         m_cachedSeparatingAxis = newCachedSeparatingAxis;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244                           <span class="comment">//degeneracy, this is typically due to invalid/uninitialized worldtransforms for a btCollisionObject   </span>
<a name="l00245"></a>00245               <span class="keywordflow">if</span> (m_curIter++ &gt; gGjkMaxIter)   
<a name="l00246"></a>00246               {   
<a name="l00247"></a>00247 <span class="preprocessor">                      #if defined(DEBUG) || defined (_DEBUG)</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span>
<a name="l00249"></a>00249                               printf(<span class="stringliteral">"btGjkPairDetector maxIter exceeded:%i\n"</span>,m_curIter);   
<a name="l00250"></a>00250                               printf(<span class="stringliteral">"sepAxis=(%f,%f,%f), squaredDistance = %f, shapeTypeA=%i,shapeTypeB=%i\n"</span>,   
<a name="l00251"></a>00251                               m_cachedSeparatingAxis.getX(),   
<a name="l00252"></a>00252                               m_cachedSeparatingAxis.getY(),   
<a name="l00253"></a>00253                               m_cachedSeparatingAxis.getZ(),   
<a name="l00254"></a>00254                               squaredDistance,   
<a name="l00255"></a>00255                               m_minkowskiA-&gt;getShapeType(),   
<a name="l00256"></a>00256                               m_minkowskiB-&gt;getShapeType());   
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="preprocessor">                      #endif   </span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>                      <span class="keywordflow">break</span>;   
<a name="l00260"></a>00260 
<a name="l00261"></a>00261               } 
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 
<a name="l00264"></a>00264                         <span class="keywordtype">bool</span> check = (!m_simplexSolver-&gt;fullSimplex());
<a name="l00265"></a>00265                         <span class="comment">//bool check = (!m_simplexSolver-&gt;fullSimplex() &amp;&amp; squaredDistance &gt; SIMD_EPSILON * m_simplexSolver-&gt;maxVertex());</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267                         <span class="keywordflow">if</span> (!check)
<a name="l00268"></a>00268                         {
<a name="l00269"></a>00269                                 <span class="comment">//do we need this backup_closest here ?</span>
<a name="l00270"></a>00270 <span class="comment">//                              m_simplexSolver-&gt;backup_closest(m_cachedSeparatingAxis);</span>
<a name="l00271"></a>00271                                 m_degenerateSimplex = 13;
<a name="l00272"></a>00272                                 <span class="keywordflow">break</span>;
<a name="l00273"></a>00273                         }
<a name="l00274"></a>00274                 }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276                 <span class="keywordflow">if</span> (checkSimplex)
<a name="l00277"></a>00277                 {
<a name="l00278"></a>00278                         m_simplexSolver-&gt;compute_points(pointOnA, pointOnB);
<a name="l00279"></a>00279                         normalInB = m_cachedSeparatingAxis;
<a name="l00280"></a>00280 
<a name="l00281"></a>00281                         btScalar lenSqr =m_cachedSeparatingAxis.length2();
<a name="l00282"></a>00282                         
<a name="l00283"></a>00283                         <span class="comment">//valid normal</span>
<a name="l00284"></a>00284                         <span class="keywordflow">if</span> (lenSqr &lt; REL_ERROR2)
<a name="l00285"></a>00285                         {
<a name="l00286"></a>00286                                 m_degenerateSimplex = 5;
<a name="l00287"></a>00287                         } 
<a name="l00288"></a>00288                         <span class="keywordflow">if</span> (lenSqr &gt; SIMD_EPSILON*SIMD_EPSILON)
<a name="l00289"></a>00289                         {
<a name="l00290"></a>00290                                 btScalar rlen = btScalar(1.) / btSqrt(lenSqr );
<a name="l00291"></a>00291                                 normalInB *= rlen; <span class="comment">//normalize</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293                                 btScalar s = btSqrt(squaredDistance);
<a name="l00294"></a>00294                         
<a name="l00295"></a>00295                                 btAssert(s &gt; btScalar(0.0));
<a name="l00296"></a>00296                                 pointOnA -= m_cachedSeparatingAxis * (marginA / s);
<a name="l00297"></a>00297                                 pointOnB += m_cachedSeparatingAxis * (marginB / s);
<a name="l00298"></a>00298                                 distance = ((btScalar(1.)/rlen) - margin);
<a name="l00299"></a>00299                                 isValid = <span class="keyword">true</span>;
<a name="l00300"></a>00300                                 
<a name="l00301"></a>00301                                 m_lastUsedMethod = 1;
<a name="l00302"></a>00302                         } <span class="keywordflow">else</span>
<a name="l00303"></a>00303                         {
<a name="l00304"></a>00304                                 m_lastUsedMethod = 2;
<a name="l00305"></a>00305                         }
<a name="l00306"></a>00306                 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308                 <span class="keywordtype">bool</span> catchDegeneratePenetrationCase = 
<a name="l00309"></a>00309                         (m_catchDegeneracies &amp;&amp; m_penetrationDepthSolver &amp;&amp; m_degenerateSimplex &amp;&amp; ((distance+margin) &lt; gGjkEpaPenetrationTolerance));
<a name="l00310"></a>00310 
<a name="l00311"></a>00311                 <span class="comment">//if (checkPenetration &amp;&amp; !isValid)</span>
<a name="l00312"></a>00312                 <span class="keywordflow">if</span> (checkPenetration &amp;&amp; (!isValid || catchDegeneratePenetrationCase ))
<a name="l00313"></a>00313                 {
<a name="l00314"></a>00314                         <span class="comment">//penetration case</span>
<a name="l00315"></a>00315 
<a name="l00316"></a>00316                         <span class="comment">//if there is no way to handle penetrations, bail out</span>
<a name="l00317"></a>00317                         <span class="keywordflow">if</span> (m_penetrationDepthSolver)
<a name="l00318"></a>00318                         {
<a name="l00319"></a>00319                                 <span class="comment">// Penetration depth case.</span>
<a name="l00320"></a>00320                                 btVector3 tmpPointOnA,tmpPointOnB;
<a name="l00321"></a>00321                                 
<a name="l00322"></a>00322                                 gNumDeepPenetrationChecks++;
<a name="l00323"></a>00323                                 m_cachedSeparatingAxis.setZero();
<a name="l00324"></a>00324 
<a name="l00325"></a>00325                                 <span class="keywordtype">bool</span> isValid2 = m_penetrationDepthSolver-&gt;<a class="code" href="classbt_convex_penetration_depth_solver.html#6330f083a2847efc4444e94160f0c622">calcPenDepth</a>( 
<a name="l00326"></a>00326                                         *m_simplexSolver, 
<a name="l00327"></a>00327                                         m_minkowskiA,m_minkowskiB,
<a name="l00328"></a>00328                                         localTransA,localTransB,
<a name="l00329"></a>00329                                         m_cachedSeparatingAxis, tmpPointOnA, tmpPointOnB,
<a name="l00330"></a>00330                                         debugDraw
<a name="l00331"></a>00331                                         );
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 
<a name="l00334"></a>00334                                 <span class="keywordflow">if</span> (isValid2)
<a name="l00335"></a>00335                                 {
<a name="l00336"></a>00336                                         btVector3 tmpNormalInB = tmpPointOnB-tmpPointOnA;
<a name="l00337"></a>00337                                         btScalar lenSqr = tmpNormalInB.length2();
<a name="l00338"></a>00338                                         <span class="keywordflow">if</span> (lenSqr &lt;= (SIMD_EPSILON*SIMD_EPSILON))
<a name="l00339"></a>00339                                         {
<a name="l00340"></a>00340                                                 tmpNormalInB = m_cachedSeparatingAxis;
<a name="l00341"></a>00341                                                 lenSqr = m_cachedSeparatingAxis.length2();
<a name="l00342"></a>00342                                         }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344                                         <span class="keywordflow">if</span> (lenSqr &gt; (SIMD_EPSILON*SIMD_EPSILON))
<a name="l00345"></a>00345                                         {
<a name="l00346"></a>00346                                                 tmpNormalInB /= btSqrt(lenSqr);
<a name="l00347"></a>00347                                                 btScalar <a class="code" href="group__gtx__norm.html#g205e08f24b9e35f9f892b563f2b8dd94">distance2</a> = -(tmpPointOnA-tmpPointOnB).<a class="code" href="group__gtc__quaternion.html#g286560b01bedb4e046ffb71de22464f4">length</a>();
<a name="l00348"></a>00348                                                 m_lastUsedMethod = 3;
<a name="l00349"></a>00349                                                 <span class="comment">//only replace valid penetrations when the result is deeper (check)</span>
<a name="l00350"></a>00350                                                 <span class="keywordflow">if</span> (!isValid || (distance2 &lt; distance))
<a name="l00351"></a>00351                                                 {
<a name="l00352"></a>00352                                                         distance = distance2;
<a name="l00353"></a>00353                                                         pointOnA = tmpPointOnA;
<a name="l00354"></a>00354                                                         pointOnB = tmpPointOnB;
<a name="l00355"></a>00355                                                         normalInB = tmpNormalInB;
<a name="l00356"></a>00356                                                         
<a name="l00357"></a>00357                                                         isValid = <span class="keyword">true</span>;
<a name="l00358"></a>00358                                                         
<a name="l00359"></a>00359                                                 } <span class="keywordflow">else</span>
<a name="l00360"></a>00360                                                 {
<a name="l00361"></a>00361                                                         m_lastUsedMethod = 8;
<a name="l00362"></a>00362                                                 }
<a name="l00363"></a>00363                                         } <span class="keywordflow">else</span>
<a name="l00364"></a>00364                                         {
<a name="l00365"></a>00365                                                 m_lastUsedMethod = 9;
<a name="l00366"></a>00366                                         }
<a name="l00367"></a>00367                                 } <span class="keywordflow">else</span>
<a name="l00368"></a>00368 
<a name="l00369"></a>00369                                 {
<a name="l00375"></a>00375 
<a name="l00376"></a>00376                                 
<a name="l00377"></a>00377                                         <span class="keywordflow">if</span> (m_cachedSeparatingAxis.length2() &gt; btScalar(0.))
<a name="l00378"></a>00378                                         {
<a name="l00379"></a>00379                                                 btScalar distance2 = (tmpPointOnA-tmpPointOnB).<a class="code" href="group__gtc__quaternion.html#g286560b01bedb4e046ffb71de22464f4">length</a>()-margin;
<a name="l00380"></a>00380                                                 <span class="comment">//only replace valid distances when the distance is less</span>
<a name="l00381"></a>00381                                                 <span class="keywordflow">if</span> (!isValid || (distance2 &lt; distance))
<a name="l00382"></a>00382                                                 {
<a name="l00383"></a>00383                                                         distance = distance2;
<a name="l00384"></a>00384                                                         pointOnA = tmpPointOnA;
<a name="l00385"></a>00385                                                         pointOnB = tmpPointOnB;
<a name="l00386"></a>00386                                                         pointOnA -= m_cachedSeparatingAxis * marginA ;
<a name="l00387"></a>00387                                                         pointOnB += m_cachedSeparatingAxis * marginB ;
<a name="l00388"></a>00388                                                         normalInB = m_cachedSeparatingAxis;
<a name="l00389"></a>00389                                                         normalInB.normalize();
<a name="l00390"></a>00390 
<a name="l00391"></a>00391                                                         isValid = <span class="keyword">true</span>;
<a name="l00392"></a>00392                                                         m_lastUsedMethod = 6;
<a name="l00393"></a>00393                                                 } <span class="keywordflow">else</span>
<a name="l00394"></a>00394                                                 {
<a name="l00395"></a>00395                                                         m_lastUsedMethod = 5;
<a name="l00396"></a>00396                                                 }
<a name="l00397"></a>00397                                         }
<a name="l00398"></a>00398                                 }
<a name="l00399"></a>00399                                 
<a name="l00400"></a>00400                         }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402                 }
<a name="l00403"></a>00403         }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405         
<a name="l00406"></a>00406 
<a name="l00407"></a>00407         <span class="keywordflow">if</span> (isValid &amp;&amp; ((distance &lt; 0) || (distance*distance &lt; input.m_maximumDistanceSquared)))
<a name="l00408"></a>00408         {
<a name="l00409"></a>00409 
<a name="l00410"></a>00410                 m_cachedSeparatingAxis = normalInB;
<a name="l00411"></a>00411                 m_cachedSeparatingDistance = distance;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413                 {
<a name="l00418"></a>00418 
<a name="l00419"></a>00419                         btScalar d1=0;
<a name="l00420"></a>00420                         {
<a name="l00421"></a>00421                                 btVector3 seperatingAxisInA = (normalInB)* input.m_transformA.getBasis();
<a name="l00422"></a>00422                                 btVector3 seperatingAxisInB = -normalInB* input.m_transformB.getBasis();
<a name="l00423"></a>00423                         
<a name="l00424"></a>00424 
<a name="l00425"></a>00425                                 btVector3 pInA = m_minkowskiA-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
<a name="l00426"></a>00426                                 btVector3 qInB = m_minkowskiB-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);
<a name="l00427"></a>00427 
<a name="l00428"></a>00428                                 btVector3  pWorld = localTransA(pInA);  
<a name="l00429"></a>00429                                 btVector3  qWorld = localTransB(qInB);
<a name="l00430"></a>00430                                 btVector3 w     = pWorld - qWorld;
<a name="l00431"></a>00431                                 d1 = (-normalInB).<a class="code" href="group__gtc__quaternion.html#g4ce8bce2b7dc8206a31cfb8e7b779b76">dot</a>(w);
<a name="l00432"></a>00432                         }
<a name="l00433"></a>00433                         btScalar d0 = 0.f;
<a name="l00434"></a>00434                         {
<a name="l00435"></a>00435                                 btVector3 seperatingAxisInA = (-normalInB)* input.m_transformA.getBasis();
<a name="l00436"></a>00436                                 btVector3 seperatingAxisInB = normalInB* input.m_transformB.getBasis();
<a name="l00437"></a>00437                         
<a name="l00438"></a>00438 
<a name="l00439"></a>00439                                 btVector3 pInA = m_minkowskiA-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInA);
<a name="l00440"></a>00440                                 btVector3 qInB = m_minkowskiB-&gt;localGetSupportVertexWithoutMarginNonVirtual(seperatingAxisInB);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442                                 btVector3  pWorld = localTransA(pInA);  
<a name="l00443"></a>00443                                 btVector3  qWorld = localTransB(qInB);
<a name="l00444"></a>00444                                 btVector3 w     = pWorld - qWorld;
<a name="l00445"></a>00445                                 d0 = normalInB.dot(w);
<a name="l00446"></a>00446                         }
<a name="l00447"></a>00447                         <span class="keywordflow">if</span> (d1&gt;d0)
<a name="l00448"></a>00448                         {
<a name="l00449"></a>00449                                 m_lastUsedMethod = 10;
<a name="l00450"></a>00450                                 normalInB*=-1;
<a name="l00451"></a>00451                         } 
<a name="l00452"></a>00452 
<a name="l00453"></a>00453                 }
<a name="l00454"></a>00454                 output.addContactPoint(
<a name="l00455"></a>00455                         normalInB,
<a name="l00456"></a>00456                         pointOnB+positionOffset,
<a name="l00457"></a>00457                         distance);
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_gjk_pair_detector_bc29953dd7aee59e9ca887963c26c8c2_cgraph.png" border="0" usemap="#classbt_gjk_pair_detector_bc29953dd7aee59e9ca887963c26c8c2_cgraph_map" alt=""></center>
<map name="classbt_gjk_pair_detector_bc29953dd7aee59e9ca887963c26c8c2_cgraph_map">
<area shape="rect" href="classbt_convex_penetration_depth_solver.html#6330f083a2847efc4444e94160f0c622" title="btConvexPenetrationDepthSolver::calcPenDepth" alt="" coords="347,5,645,32"><area shape="rect" href="group__core__func__geometric.html#gd21e00cab9f8b4eb6d1214a16dee06c7" title="glm::distance" alt="" coords="447,56,545,83"><area shape="rect" href="group__gtx__norm.html#g205e08f24b9e35f9f892b563f2b8dd94" title="glm::distance2" alt="" coords="443,107,549,133"><area shape="rect" href="group__gtc__quaternion.html#g4ce8bce2b7dc8206a31cfb8e7b779b76" title="glm::dot" alt="" coords="703,157,769,184"><area shape="rect" href="group__gtc__quaternion.html#g286560b01bedb4e046ffb71de22464f4" title="glm::length" alt="" coords="453,208,539,235"><area shape="rect" href="group__core__func__geometric.html#gd73a94d9c967e619e670156356e93b7e" title="glm::length" alt="" coords="693,56,779,83"><area shape="rect" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1" title="glm::abs" alt="" coords="827,56,899,83"><area shape="rect" href="group__core__func__exponential.html#gfe49b7b63045b6ab94bffbcd7e7a7bc8" title="glm::sqrt" alt="" coords="700,208,772,235"></map>
</div>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/NarrowPhaseCollision/<a class="el" href="bt_gjk_pair_detector_8h-source.html">btGjkPairDetector.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/NarrowPhaseCollision/<a class="el" href="bt_gjk_pair_detector_8cpp-source.html">btGjkPairDetector.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:01:25 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
