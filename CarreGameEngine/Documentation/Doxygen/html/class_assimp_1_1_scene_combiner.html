<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: Assimp::SceneCombiner Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_assimp.html">Assimp</a>::<a class="el" href="class_assimp_1_1_scene_combiner.html">SceneCombiner</a>
  </div>
</div>
<div class="contents">
<h1>Assimp::SceneCombiner Class Reference</h1><!-- doxytag: class="Assimp::SceneCombiner" -->Static helper class providing various utilities to merge two scenes. It is intended as internal utility and NOT for use by applications.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_scene_combiner_8h-source.html">SceneCombiner.h</a>&gt;</code>
<p>

<p>
<a href="class_assimp_1_1_scene_combiner-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#b399fdea5846bc969a021a39f5a11276">MergeScenes</a> (<a class="el" href="structai_scene.html">aiScene</a> **dest, std::vector&lt; <a class="el" href="structai_scene.html">aiScene</a> * &gt; &amp;src, unsigned int flags=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#49af3c46e42d4da59bb1a488e517618c">MergeScenes</a> (<a class="el" href="structai_scene.html">aiScene</a> **dest, <a class="el" href="structai_scene.html">aiScene</a> *master, std::vector&lt; <a class="el" href="struct_assimp_1_1_attachment_info.html">AttachmentInfo</a> &gt; &amp;src, unsigned int flags=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#3486044d9e2213bb8c408d8e8ef906f4">MergeMeshes</a> (<a class="el" href="structai_mesh.html">aiMesh</a> **dest, unsigned int flags, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator begin, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#a42d5370510db89cbdd739617a617d4e">MergeBones</a> (<a class="el" href="structai_mesh.html">aiMesh</a> *out, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator it, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#9ebdb2b454f84032f2cfb51ebd7d5716">MergeMaterials</a> (<a class="el" href="structai_material.html">aiMaterial</a> **dest, std::vector&lt; <a class="el" href="structai_material.html">aiMaterial</a> * &gt;::const_iterator begin, std::vector&lt; <a class="el" href="structai_material.html">aiMaterial</a> * &gt;::const_iterator end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#9bfbbbab2ece2925fc3628c587ea9dcc">BuildUniqueBoneList</a> (std::list&lt; <a class="el" href="struct_assimp_1_1_bone_with_hash.html">BoneWithHash</a> &gt; &amp;asBones, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator it, std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#5e4ec755bb270b894e37d20938a4a88b">AddNodePrefixes</a> (<a class="el" href="structai_node.html">aiNode</a> *node, const char *prefix, unsigned int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#0c52e873dfdd0c71f7f2bae06bcbb865">OffsetNodeMeshIndices</a> (<a class="el" href="structai_node.html">aiNode</a> *node, unsigned int offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#1672dc80009a8183edbabc4ef262b5c5">AttachToGraph</a> (<a class="el" href="structai_scene.html">aiScene</a> *master, std::vector&lt; NodeAttachmentInfo &gt; &amp;srcList)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#855a472e4848d737ef1ff091363f3a7c">CopyScene</a> (<a class="el" href="structai_scene.html">aiScene</a> **dest, const <a class="el" href="structai_scene.html">aiScene</a> *source, bool allocate=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#fd836d513bc02da4c40d1432bf687f3e">CopySceneFlat</a> (<a class="el" href="structai_scene.html">aiScene</a> **dest, const <a class="el" href="structai_scene.html">aiScene</a> *source)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assimp_1_1_scene_combiner.html#abed196fdfb16f82873ec811c6a64bfc">Copy</a> (<a class="el" href="structai_mesh.html">aiMesh</a> **dest, const <a class="el" href="structai_mesh.html">aiMesh</a> *src)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Static helper class providing various utilities to merge two scenes. It is intended as internal utility and NOT for use by applications. 
<p>
The class is currently being used by various postprocessing steps and loaders (ie. LWS). 
<p>Definition at line <a class="el" href="_scene_combiner_8h-source.html#l00200">200</a> of file <a class="el" href="_scene_combiner_8h-source.html">SceneCombiner.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b399fdea5846bc969a021a39f5a11276"></a><!-- doxytag: member="Assimp::SceneCombiner::MergeScenes" ref="b399fdea5846bc969a021a39f5a11276" args="(aiScene **dest, std::vector&lt; aiScene * &gt; &amp;src, unsigned int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeScenes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_scene.html">aiScene</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two or more scenes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Receives a pointer to the destination scene. If the pointer doesn't point to NULL when the function is called, the existing scene is cleared and refilled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Non-empty list of scenes to be merged. The function deletes the input scenes afterwards. There may be duplicate scenes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Combination of the AI_INT_MERGE_SCENE flags defined above </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="49af3c46e42d4da59bb1a488e517618c"></a><!-- doxytag: member="Assimp::SceneCombiner::MergeScenes" ref="49af3c46e42d4da59bb1a488e517618c" args="(aiScene **dest, aiScene *master, std::vector&lt; AttachmentInfo &gt; &amp;src, unsigned int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeScenes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> *&nbsp;</td>
          <td class="paramname"> <em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_assimp_1_1_attachment_info.html">AttachmentInfo</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two or more scenes and attaches all scenes to a specific position in the node graph of the master scene.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Receives a pointer to the destination scene. If the pointer doesn't point to NULL when the function is called, the existing scene is cleared and refilled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>master</em>&nbsp;</td><td>Master scene. It will be deleted afterwards. All other scenes will be inserted in its node graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Non-empty list of scenes to be merged along with their corresponding attachment points in the master scene. The function deletes the input scenes afterwards. There may be duplicate scenes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Combination of the AI_INT_MERGE_SCENE flags defined above </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3486044d9e2213bb8c408d8e8ef906f4"></a><!-- doxytag: member="Assimp::SceneCombiner::MergeMeshes" ref="3486044d9e2213bb8c408d8e8ef906f4" args="(aiMesh **dest, unsigned int flags, std::vector&lt; aiMesh * &gt;::const_iterator begin, std::vector&lt; aiMesh * &gt;::const_iterator end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeMeshes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_mesh.html">aiMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two or more meshes<p>
The meshes should have equal vertex formats. Only components that are provided by ALL meshes will be present in the output mesh. An exception is made for VColors - they are set to black. The meshes should have the same material indices, too. The output material index is always the material index of the first mesh.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Destination mesh. Must be empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Currently no parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>First mesh to be processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Points to the mesh after the last mesh to be processed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a42d5370510db89cbdd739617a617d4e"></a><!-- doxytag: member="Assimp::SceneCombiner::MergeBones" ref="a42d5370510db89cbdd739617a617d4e" args="(aiMesh *out, std::vector&lt; aiMesh * &gt;::const_iterator it, std::vector&lt; aiMesh * &gt;::const_iterator end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeBones           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_mesh.html">aiMesh</a> *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two or more bones<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td><a class="el" href="class_mesh.html" title="Used to store mesh data.">Mesh</a> to receive the output bone list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Currently no parameters </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>First mesh to be processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Points to the mesh after the last mesh to be processed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ebdb2b454f84032f2cfb51ebd7d5716"></a><!-- doxytag: member="Assimp::SceneCombiner::MergeMaterials" ref="9ebdb2b454f84032f2cfb51ebd7d5716" args="(aiMaterial **dest, std::vector&lt; aiMaterial * &gt;::const_iterator begin, std::vector&lt; aiMaterial * &gt;::const_iterator end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::MergeMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_material.html">aiMaterial</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_material.html">aiMaterial</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_material.html">aiMaterial</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Merges two or more materials<p>
The materials should be complementary as much as possible. In case of a property present in different materials, the first occurrence is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Destination material. Must be empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>First material to be processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Points to the material after the last material to be processed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9bfbbbab2ece2925fc3628c587ea9dcc"></a><!-- doxytag: member="Assimp::SceneCombiner::BuildUniqueBoneList" ref="9bfbbbab2ece2925fc3628c587ea9dcc" args="(std::list&lt; BoneWithHash &gt; &amp;asBones, std::vector&lt; aiMesh * &gt;::const_iterator it, std::vector&lt; aiMesh * &gt;::const_iterator end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::BuildUniqueBoneList           </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_assimp_1_1_bone_with_hash.html">BoneWithHash</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>asBones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structai_mesh.html">aiMesh</a> * &gt;::const_iterator&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a list of uniquely named bones in a mesh list<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asBones</em>&nbsp;</td><td>Receives the output list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>First mesh to be processed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Last mesh to be processed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5e4ec755bb270b894e37d20938a4a88b"></a><!-- doxytag: member="Assimp::SceneCombiner::AddNodePrefixes" ref="5e4ec755bb270b894e37d20938a4a88b" args="(aiNode *node, const char *prefix, unsigned int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::AddNodePrefixes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a name prefix to all nodes in a scene.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Current</em>&nbsp;</td><td>node. This function is called recursively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>Prefix to be added to all nodes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>STring length </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c52e873dfdd0c71f7f2bae06bcbb865"></a><!-- doxytag: member="Assimp::SceneCombiner::OffsetNodeMeshIndices" ref="0c52e873dfdd0c71f7f2bae06bcbb865" args="(aiNode *node, unsigned int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::OffsetNodeMeshIndices           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_node.html">aiNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an offset to all mesh indices in a node graph<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Current</em>&nbsp;</td><td>node. This function is called recursively. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>Offset to be added to all mesh indices </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1672dc80009a8183edbabc4ef262b5c5"></a><!-- doxytag: member="Assimp::SceneCombiner::AttachToGraph" ref="1672dc80009a8183edbabc4ef262b5c5" args="(aiScene *master, std::vector&lt; NodeAttachmentInfo &gt; &amp;srcList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::AttachToGraph           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> *&nbsp;</td>
          <td class="paramname"> <em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NodeAttachmentInfo &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attach a list of node graphs to well-defined nodes in a master graph. This is a helper for <a class="el" href="class_assimp_1_1_scene_combiner.html#b399fdea5846bc969a021a39f5a11276">MergeScenes()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>master</em>&nbsp;</td><td>Master scene </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcList</em>&nbsp;</td><td>List of source scenes along with their attachment points. If an attachment point is NULL (or does not exist in the master graph), a scene is attached to the root of the master graph (as an additional child node)  List of duplicates. If elem[n] == n the scene is not a duplicate. Otherwise elem[n] links scene n to its first occurrence. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="855a472e4848d737ef1ff091363f3a7c"></a><!-- doxytag: member="Assimp::SceneCombiner::CopyScene" ref="855a472e4848d737ef1ff091363f3a7c" args="(aiScene **dest, const aiScene *source, bool allocate=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::CopyScene           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structai_scene.html">aiScene</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allocate</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a deep copy of a scene<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Receives a pointer to the destination scene </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source scene - remains unmodified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd836d513bc02da4c40d1432bf687f3e"></a><!-- doxytag: member="Assimp::SceneCombiner::CopySceneFlat" ref="fd836d513bc02da4c40d1432bf687f3e" args="(aiScene **dest, const aiScene *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::CopySceneFlat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_scene.html">aiScene</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structai_scene.html">aiScene</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a flat copy of a scene<p>
Only the first hierarchy layer is copied. All pointer members of <a class="el" href="structai_scene.html">aiScene</a> are shared by source and destination scene. If the pointer doesn't point to NULL when the function is called, the existing scene is cleared and refilled. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Receives a pointer to the destination scene </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source scene - remains unmodified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="abed196fdfb16f82873ec811c6a64bfc"></a><!-- doxytag: member="Assimp::SceneCombiner::Copy" ref="abed196fdfb16f82873ec811c6a64bfc" args="(aiMesh **dest, const aiMesh *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Assimp::SceneCombiner::Copy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structai_mesh.html">aiMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structai_mesh.html">aiMesh</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a deep copy of a mesh<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Receives a pointer to the destination mesh </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source mesh - remains unmodified. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/assimp-4.1.0/include/assimp/<a class="el" href="_scene_combiner_8h-source.html">SceneCombiner.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:04:00 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
