<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btSoftBody Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btSoftBody Class Reference</h1><!-- doxytag: class="btSoftBody" --><code>#include &lt;<a class="el" href="bt_soft_body_8h-source.html">btSoftBody.h</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for btSoftBody:</div>
<div class="dynsection">
<p><center><img src="classbt_soft_body__coll__graph.png" border="0" usemap="#bt_soft_body__coll__map" alt="Collaboration graph"></center>
<map name="bt_soft_body__coll__map">
<area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; int \&gt;" alt="" coords="1629,52,1811,79"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; int, 16 \&gt;" alt="" coords="883,5,1069,32"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, Alignment \&gt;" alt="" coords="5,165,229,192"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, 16 \&gt;" alt="" coords="588,165,767,192"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; bool, 16 \&gt;" alt="" coords="879,75,1073,101"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; Link, 16 \&gt;" alt="" coords="1100,256,1295,283"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; const class btCollisionObject *, 16 \&gt;" alt="" coords="503,313,852,340"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; T \&gt;" alt="" coords="1109,165,1285,192"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; bool \&gt;" alt="" coords="1624,103,1816,129"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; Link \&gt;" alt="" coords="1624,229,1816,256"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; const class btCollisionObject * \&gt;" alt="" coords="1547,280,1893,307"><area shape="rect" href="structbt_dbvt.html" title="btDbvt" alt="" coords="1692,179,1748,205"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_soft_body-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="842480e0f75b82a50f0e5e606e2ac40b"></a><!-- doxytag: member="btSoftBody::btSoftBody" ref="842480e0f75b82a50f0e5e606e2ac40b" args="(btSoftBodyWorldInfo *worldInfo, int node_count, const btVector3 *x, const btScalar *m)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#842480e0f75b82a50f0e5e606e2ac40b">btSoftBody</a> (btSoftBodyWorldInfo *worldInfo, int node_count, const btVector3 *x, const btScalar *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classbt_soft_body.html">btSoftBody</a> implementation by Nathanael Presson <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#e07c09d9c2937897c3690c1a3970bf61">initDefaults</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#ced0f5421eeb1491a3fd77bb91e2e5af">setCollisionShape</a> (btCollisionShape *collisionShape)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#f31b03f0ff5eecec1ec9eee5a7582d20">generateBendingConstraints</a> (int distance, Material *mat=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#9915ca0d99dbeb9f39221dab218d5208">generateClusters</a> (int k, int maxiterations=8192)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3133d790dcff71b8e8a43eb966097485"></a><!-- doxytag: member="btSoftBody::rayTest" ref="3133d790dcff71b8e8a43eb966097485" args="(const btVector3 &amp;rayFrom, const btVector3 &amp;rayTo, sRayCast &amp;results)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#3133d790dcff71b8e8a43eb966097485">rayTest</a> (const btVector3 &amp;rayFrom, const btVector3 &amp;rayTo, sRayCast &amp;results)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ray casting using rayFrom and rayTo in worldspace, (not direction!). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#ee9ac69662731fa96ae2357522972ef9">setWindVelocity</a> (const btVector3 &amp;velocity)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const btVector3 &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#71de05c3c56952a4d76e09ca9ca9cce0">getWindVelocity</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c24b1fbdcc3ed3d26b3dae6380303c77"></a><!-- doxytag: member="btSoftBody::serialize" ref="c24b1fbdcc3ed3d26b3dae6380303c77" args="(void *dataBuffer, class btSerializer *serializer) const " -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#c24b1fbdcc3ed3d26b3dae6380303c77">serialize</a> (void *dataBuffer, class btSerializer *serializer) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fills the dataBuffer and returns the struct name (and 0 on failure) <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_soft_body.html#e8a2fc459b2afc985fbb03c1b0203bec">solveCommonConstraints</a> (<a class="el" href="classbt_soft_body.html">btSoftBody</a> **bodies, int count, int iterations)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1e_aero_model.html">eAeroModel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1e_aero_model.html" title="eAeroModel">eAeroModel</a>  <a href="structbt_soft_body_1_1e_aero_model.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1e_feature.html">eFeature</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1e_feature.html" title="eFeature">eFeature</a>  <a href="structbt_soft_body_1_1e_feature.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1e_p_solver.html">ePSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1e_p_solver.html" title="ePSolver : positions solvers">ePSolver</a> : positions solvers  <a href="structbt_soft_body_1_1e_p_solver.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1e_solver_presets.html">eSolverPresets</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1e_solver_presets.html" title="eSolverPresets">eSolverPresets</a>  <a href="structbt_soft_body_1_1e_solver_presets.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1e_v_solver.html">eVSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1e_v_solver.html" title="eVSolver : velocities solvers">eVSolver</a> : velocities solvers  <a href="structbt_soft_body_1_1e_v_solver.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1f_collision.html">fCollision</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1f_collision.html" title="fCollision">fCollision</a>  <a href="structbt_soft_body_1_1f_collision.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1f_material.html">fMaterial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1f_material.html" title="fMaterial">fMaterial</a>  <a href="structbt_soft_body_1_1f_material.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbt_soft_body_1_1_ray_from_to_caster.html">RayFromToCaster</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structbt_soft_body_1_1_ray_from_to_caster.html" title="RayFromToCaster takes a ray from, ray to (instead of direction!).">RayFromToCaster</a> takes a ray from, ray to (instead of direction!).  <a href="structbt_soft_body_1_1_ray_from_to_caster.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classbt_soft_body.html">btSoftBody</a> is an class to simulate cloth and volumetric soft bodies. There is two-way interaction between <a class="el" href="classbt_soft_body.html">btSoftBody</a> and btRigidBody/btCollisionObject. 
<p>Definition at line <a class="el" href="bt_soft_body_8h-source.html#l00071">71</a> of file <a class="el" href="bt_soft_body_8h-source.html">btSoftBody.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e07c09d9c2937897c3690c1a3970bf61"></a><!-- doxytag: member="btSoftBody::initDefaults" ref="e07c09d9c2937897c3690c1a3970bf61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btSoftBody::initDefaults           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
for now, create a collision shape internally 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l00064">64</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>

<p>References <a class="el" href="bt_soft_body_8h-source.html#l00146">btSoftBody::fCollision::Default</a>.</p>

<p>Referenced by <a class="el" href="bt_soft_body_8cpp-source.html#l00026">btSoftBody()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00065"></a>00065 {
<a name="l00066"></a>00066         m_internalType          =       CO_SOFT_BODY;
<a name="l00067"></a>00067         m_cfg.aeromodel         =       eAeroModel::V_Point;
<a name="l00068"></a>00068         m_cfg.kVCF                      =       1;
<a name="l00069"></a>00069         m_cfg.kDG                       =       0;
<a name="l00070"></a>00070         m_cfg.kLF                       =       0;
<a name="l00071"></a>00071         m_cfg.kDP                       =       0;
<a name="l00072"></a>00072         m_cfg.kPR                       =       0;
<a name="l00073"></a>00073         m_cfg.kVC                       =       0;
<a name="l00074"></a>00074         m_cfg.kDF                       =       (btScalar)0.2;
<a name="l00075"></a>00075         m_cfg.kMT                       =       0;
<a name="l00076"></a>00076         m_cfg.kCHR                      =       (btScalar)1.0;
<a name="l00077"></a>00077         m_cfg.kKHR                      =       (btScalar)0.1;
<a name="l00078"></a>00078         m_cfg.kSHR                      =       (btScalar)1.0;
<a name="l00079"></a>00079         m_cfg.kAHR                      =       (btScalar)0.7;
<a name="l00080"></a>00080         m_cfg.kSRHR_CL          =       (btScalar)0.1;
<a name="l00081"></a>00081         m_cfg.kSKHR_CL          =       (btScalar)1;
<a name="l00082"></a>00082         m_cfg.kSSHR_CL          =       (btScalar)0.5;
<a name="l00083"></a>00083         m_cfg.kSR_SPLT_CL       =       (btScalar)0.5;
<a name="l00084"></a>00084         m_cfg.kSK_SPLT_CL       =       (btScalar)0.5;
<a name="l00085"></a>00085         m_cfg.kSS_SPLT_CL       =       (btScalar)0.5;
<a name="l00086"></a>00086         m_cfg.maxvolume         =       (btScalar)1;
<a name="l00087"></a>00087         m_cfg.timescale         =       1;
<a name="l00088"></a>00088         m_cfg.viterations       =       0;
<a name="l00089"></a>00089         m_cfg.piterations       =       1;      
<a name="l00090"></a>00090         m_cfg.diterations       =       0;
<a name="l00091"></a>00091         m_cfg.citerations       =       4;
<a name="l00092"></a>00092         m_cfg.collisions        =       <a class="code" href="structbt_soft_body_1_1f_collision.html#feb40bef0380b8db7e9e5628cc5f08d51c6fb7a4f36642982c053815889133e5" title="Cluster soft body self collision.">fCollision::Default</a>;
<a name="l00093"></a>00093         m_pose.m_bvolume        =       <span class="keyword">false</span>;
<a name="l00094"></a>00094         m_pose.m_bframe         =       <span class="keyword">false</span>;
<a name="l00095"></a>00095         m_pose.m_volume         =       0;
<a name="l00096"></a>00096         m_pose.m_com            =       btVector3(0,0,0);
<a name="l00097"></a>00097         m_pose.m_rot.setIdentity();
<a name="l00098"></a>00098         m_pose.m_scl.setIdentity();
<a name="l00099"></a>00099         m_tag                           =       0;
<a name="l00100"></a>00100         m_timeacc                       =       0;
<a name="l00101"></a>00101         m_bUpdateRtCst          =       <span class="keyword">true</span>;
<a name="l00102"></a>00102         m_bounds[0]                     =       btVector3(0,0,0);
<a name="l00103"></a>00103         m_bounds[1]                     =       btVector3(0,0,0);
<a name="l00104"></a>00104         m_worldTransform.setIdentity();
<a name="l00105"></a>00105         setSolver(eSolverPresets::Positions);
<a name="l00106"></a>00106         
<a name="l00107"></a>00107         <span class="comment">/* Collision shape      */</span> 
<a name="l00109"></a>00109         m_collisionShape = <span class="keyword">new</span> btSoftBodyCollisionShape(<span class="keyword">this</span>);
<a name="l00110"></a>00110         m_collisionShape-&gt;setMargin(0.25f);
<a name="l00111"></a>00111         
<a name="l00112"></a>00112         m_initialWorldTransform.setIdentity();
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         m_windVelocity = btVector3(0,0,0);
<a name="l00115"></a>00115         m_restLengthScale = btScalar(1.0);
<a name="l00116"></a>00116 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_soft_body_e07c09d9c2937897c3690c1a3970bf61_icgraph.png" border="0" usemap="#classbt_soft_body_e07c09d9c2937897c3690c1a3970bf61_icgraph_map" alt=""></center>
<map name="classbt_soft_body_e07c09d9c2937897c3690c1a3970bf61_icgraph_map">
<area shape="rect" href="classbt_soft_body.html#842480e0f75b82a50f0e5e606e2ac40b" title="btSoftBody implementation by Nathanael Presson" alt="" coords="211,5,368,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="ced0f5421eeb1491a3fd77bb91e2e5af"></a><!-- doxytag: member="btSoftBody::setCollisionShape" ref="ced0f5421eeb1491a3fd77bb91e2e5af" args="(btCollisionShape *collisionShape)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btSoftBody::setCollisionShape           </td>
          <td>(</td>
          <td class="paramtype">btCollisionShape *&nbsp;</td>
          <td class="paramname"> <em>collisionShape</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>: avoid internal softbody shape hack and move collision code to collision library </dd></dl>

<p>Definition at line <a class="el" href="bt_soft_body_8h-source.html#l00708">708</a> of file <a class="el" href="bt_soft_body_8h-source.html">btSoftBody.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00709"></a>00709         {
<a name="l00710"></a>00710                 
<a name="l00711"></a>00711         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f31b03f0ff5eecec1ec9eee5a7582d20"></a><!-- doxytag: member="btSoftBody::generateBendingConstraints" ref="f31b03f0ff5eecec1ec9eee5a7582d20" args="(int distance, Material *mat=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btSoftBody::generateBendingConstraints           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Material *&nbsp;</td>
          <td class="paramname"> <em>mat</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
generic Floyd's algorithm 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l01040">1040</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00463">btAlignedObjectArray&lt; T &gt;::findLinearSearch()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01041"></a>01041 {
<a name="l01042"></a>01042         <span class="keywordtype">int</span> i,j;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044         <span class="keywordflow">if</span>(<a class="code" href="group__core__func__geometric.html#gd21e00cab9f8b4eb6d1214a16dee06c7">distance</a>&gt;1)
<a name="l01045"></a>01045         {
<a name="l01046"></a>01046                 <span class="comment">/* Build graph  */</span> 
<a name="l01047"></a>01047                 <span class="keyword">const</span> <span class="keywordtype">int</span>               n=m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l01048"></a>01048                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span>  inf=(~(unsigned)0)&gt;&gt;1;
<a name="l01049"></a>01049                 <span class="keywordtype">unsigned</span>*               adj=<span class="keyword">new</span> <span class="keywordtype">unsigned</span>[n*n];
<a name="l01050"></a>01050                 
<a name="l01051"></a>01051 
<a name="l01052"></a>01052 <span class="preprocessor">#define IDX(_x_,_y_)    ((_y_)*n+(_x_))</span>
<a name="l01053"></a>01053 <span class="preprocessor"></span>                <span class="keywordflow">for</span>(j=0;j&lt;n;++j)
<a name="l01054"></a>01054                 {
<a name="l01055"></a>01055                         <span class="keywordflow">for</span>(i=0;i&lt;n;++i)
<a name="l01056"></a>01056                         {
<a name="l01057"></a>01057                                 <span class="keywordflow">if</span>(i!=j)
<a name="l01058"></a>01058                                 {
<a name="l01059"></a>01059                                         adj[IDX(i,j)]=adj[IDX(j,i)]=inf;
<a name="l01060"></a>01060                                 }
<a name="l01061"></a>01061                                 <span class="keywordflow">else</span>
<a name="l01062"></a>01062                                 {
<a name="l01063"></a>01063                                         adj[IDX(i,j)]=adj[IDX(j,i)]=0;
<a name="l01064"></a>01064                                 }
<a name="l01065"></a>01065                         }
<a name="l01066"></a>01066                 }
<a name="l01067"></a>01067                 <span class="keywordflow">for</span>( i=0;i&lt;m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01068"></a>01068                 {
<a name="l01069"></a>01069                         <span class="keyword">const</span> <span class="keywordtype">int</span>       ia=(int)(m_links[i].m_n[0]-&amp;m_nodes[0]);
<a name="l01070"></a>01070                         <span class="keyword">const</span> <span class="keywordtype">int</span>       ib=(int)(m_links[i].m_n[1]-&amp;m_nodes[0]);
<a name="l01071"></a>01071                         adj[IDX(ia,ib)]=1;
<a name="l01072"></a>01072                         adj[IDX(ib,ia)]=1;
<a name="l01073"></a>01073                 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 
<a name="l01076"></a>01076                 <span class="comment">//special optimized case for distance == 2</span>
<a name="l01077"></a>01077                 <span class="keywordflow">if</span> (<a class="code" href="group__core__func__geometric.html#gd21e00cab9f8b4eb6d1214a16dee06c7">distance</a> == 2)
<a name="l01078"></a>01078                 {
<a name="l01079"></a>01079 
<a name="l01080"></a>01080                         <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;NodeLinks&gt;</a> nodeLinks;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 
<a name="l01083"></a>01083                         <span class="comment">/* Build node links */</span>
<a name="l01084"></a>01084                         nodeLinks.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01085"></a>01085 
<a name="l01086"></a>01086                         <span class="keywordflow">for</span>( i=0;i&lt;m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01087"></a>01087                         {
<a name="l01088"></a>01088                                 <span class="keyword">const</span> <span class="keywordtype">int</span>       ia=(int)(m_links[i].m_n[0]-&amp;m_nodes[0]);
<a name="l01089"></a>01089                                 <span class="keyword">const</span> <span class="keywordtype">int</span>       ib=(int)(m_links[i].m_n[1]-&amp;m_nodes[0]);
<a name="l01090"></a>01090                                 <span class="keywordflow">if</span> (nodeLinks[ia].m_links.<a class="code" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8">findLinearSearch</a>(ib)==nodeLinks[ia].m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01091"></a>01091                                         nodeLinks[ia].m_links.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(ib);
<a name="l01092"></a>01092 
<a name="l01093"></a>01093                                 <span class="keywordflow">if</span> (nodeLinks[ib].m_links.<a class="code" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8">findLinearSearch</a>(ia)==nodeLinks[ib].m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01094"></a>01094                                         nodeLinks[ib].m_links.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(ia);
<a name="l01095"></a>01095                         }
<a name="l01096"></a>01096                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii=0;ii&lt;nodeLinks.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();ii++)
<a name="l01097"></a>01097                         {
<a name="l01098"></a>01098                                 <span class="keywordtype">int</span> i=ii;
<a name="l01099"></a>01099 
<a name="l01100"></a>01100                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj=0;jj&lt;nodeLinks[ii].m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();jj++)
<a name="l01101"></a>01101                                 {
<a name="l01102"></a>01102                                         <span class="keywordtype">int</span> k = nodeLinks[ii].m_links[jj];
<a name="l01103"></a>01103                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0;kk&lt;nodeLinks[k].m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();kk++)
<a name="l01104"></a>01104                                         {
<a name="l01105"></a>01105                                                 <span class="keywordtype">int</span> j = nodeLinks[k].m_links[kk];
<a name="l01106"></a>01106                                                 <span class="keywordflow">if</span> (i!=j)
<a name="l01107"></a>01107                                                 {
<a name="l01108"></a>01108                                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span>  sum=adj[IDX(i,k)]+adj[IDX(k,j)];
<a name="l01109"></a>01109                                                         btAssert(sum==2);
<a name="l01110"></a>01110                                                         <span class="keywordflow">if</span>(adj[IDX(i,j)]&gt;sum)
<a name="l01111"></a>01111                                                         {
<a name="l01112"></a>01112                                                                 adj[IDX(i,j)]=adj[IDX(j,i)]=sum;
<a name="l01113"></a>01113                                                         }
<a name="l01114"></a>01114                                                 }
<a name="l01115"></a>01115 
<a name="l01116"></a>01116                                         }
<a name="l01117"></a>01117                                 }
<a name="l01118"></a>01118                         }
<a name="l01119"></a>01119                 } <span class="keywordflow">else</span>
<a name="l01120"></a>01120                 {
<a name="l01122"></a>01122                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0;k&lt;n;++k)
<a name="l01123"></a>01123                         {
<a name="l01124"></a>01124                                 <span class="keywordflow">for</span>(j=0;j&lt;n;++j)
<a name="l01125"></a>01125                                 {
<a name="l01126"></a>01126                                         <span class="keywordflow">for</span>(i=j+1;i&lt;n;++i)
<a name="l01127"></a>01127                                         {
<a name="l01128"></a>01128                                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span>  sum=adj[IDX(i,k)]+adj[IDX(k,j)];
<a name="l01129"></a>01129                                                 <span class="keywordflow">if</span>(adj[IDX(i,j)]&gt;sum)
<a name="l01130"></a>01130                                                 {
<a name="l01131"></a>01131                                                         adj[IDX(i,j)]=adj[IDX(j,i)]=sum;
<a name="l01132"></a>01132                                                 }
<a name="l01133"></a>01133                                         }
<a name="l01134"></a>01134                                 }
<a name="l01135"></a>01135                         }
<a name="l01136"></a>01136                 }
<a name="l01137"></a>01137 
<a name="l01138"></a>01138 
<a name="l01139"></a>01139                 <span class="comment">/* Build links  */</span> 
<a name="l01140"></a>01140                 <span class="keywordtype">int</span>     nlinks=0;
<a name="l01141"></a>01141                 <span class="keywordflow">for</span>(j=0;j&lt;n;++j)
<a name="l01142"></a>01142                 {
<a name="l01143"></a>01143                         <span class="keywordflow">for</span>(i=j+1;i&lt;n;++i)
<a name="l01144"></a>01144                         {
<a name="l01145"></a>01145                                 <span class="keywordflow">if</span>(adj[IDX(i,j)]==(<span class="keywordtype">unsigned</span>)<a class="code" href="group__core__func__geometric.html#gd21e00cab9f8b4eb6d1214a16dee06c7">distance</a>)
<a name="l01146"></a>01146                                 {
<a name="l01147"></a>01147                                         appendLink(i,j,mat);
<a name="l01148"></a>01148                                         m_links[m_links.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()-1].m_bbending=1;
<a name="l01149"></a>01149                                         ++nlinks;
<a name="l01150"></a>01150                                 }
<a name="l01151"></a>01151                         }
<a name="l01152"></a>01152                 }
<a name="l01153"></a>01153                 <span class="keyword">delete</span>[] adj;           
<a name="l01154"></a>01154                 <span class="keywordflow">return</span>(nlinks);
<a name="l01155"></a>01155         }
<a name="l01156"></a>01156         <span class="keywordflow">return</span>(0);
<a name="l01157"></a>01157 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_soft_body_f31b03f0ff5eecec1ec9eee5a7582d20_cgraph.png" border="0" usemap="#classbt_soft_body_f31b03f0ff5eecec1ec9eee5a7582d20_cgraph_map" alt=""></center>
<map name="classbt_soft_body_f31b03f0ff5eecec1ec9eee5a7582d20_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8" title="btAlignedObjectArray::findLinearSearch" alt="" coords="309,5,557,32"><area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="325,56,541,83"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="340,107,527,133"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="345,157,521,184"></map>
</div>

</div>
</div><p>
<a class="anchor" name="9915ca0d99dbeb9f39221dab218d5208"></a><!-- doxytag: member="btSoftBody::generateClusters" ref="9915ca0d99dbeb9f39221dab218d5208" args="(int k, int maxiterations=8192)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btSoftBody::generateClusters           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxiterations</em> = <code>8192</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
generateClusters with k=0 will create a convex cluster for each tetrahedron or triangle otherwise an approximation will be used (better performance) 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l01194">1194</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00463">btAlignedObjectArray&lt; T &gt;::findLinearSearch()</a>, <a class="el" href="_g_l_m_2include_2_g_l_m_2gtx_2quaternion_8inl-source.html#l00164">glm::length2()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01195"></a>01195 {
<a name="l01196"></a>01196         <span class="keywordtype">int</span> i;
<a name="l01197"></a>01197         releaseClusters();
<a name="l01198"></a>01198         m_clusters.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(btMin(k,m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()));
<a name="l01199"></a>01199         <span class="keywordflow">for</span>(i=0;i&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01200"></a>01200         {
<a name="l01201"></a>01201                 m_clusters[i]                   =       <span class="keyword">new</span>(btAlignedAlloc(<span class="keyword">sizeof</span>(Cluster),16)) Cluster();
<a name="l01202"></a>01202                 m_clusters[i]-&gt;m_collide=       <span class="keyword">true</span>;
<a name="l01203"></a>01203         }
<a name="l01204"></a>01204         k=m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l01205"></a>01205         <span class="keywordflow">if</span>(k&gt;0)
<a name="l01206"></a>01206         {
<a name="l01207"></a>01207                 <span class="comment">/* Initialize           */</span> 
<a name="l01208"></a>01208                 <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;btVector3&gt;</a> centers;
<a name="l01209"></a>01209                 btVector3                                               cog(0,0,0);
<a name="l01210"></a>01210                 <span class="keywordtype">int</span>                                                             i;
<a name="l01211"></a>01211                 <span class="keywordflow">for</span>(i=0;i&lt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01212"></a>01212                 {
<a name="l01213"></a>01213                         cog+=m_nodes[i].m_x;
<a name="l01214"></a>01214                         m_clusters[(i*29873)%m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_nodes[i]);
<a name="l01215"></a>01215                 }
<a name="l01216"></a>01216                 cog/=(btScalar)m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l01217"></a>01217                 centers.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(k,cog);
<a name="l01218"></a>01218                 <span class="comment">/* Iterate                      */</span> 
<a name="l01219"></a>01219                 <span class="keyword">const</span> btScalar  slope=16;
<a name="l01220"></a>01220                 <span class="keywordtype">bool</span>                    changed;
<a name="l01221"></a>01221                 <span class="keywordtype">int</span>                             iterations=0;
<a name="l01222"></a>01222                 <span class="keywordflow">do</span>      {
<a name="l01223"></a>01223                         <span class="keyword">const</span> btScalar  w=2-btMin&lt;btScalar&gt;(1,iterations/slope);
<a name="l01224"></a>01224                         changed=<span class="keyword">false</span>;
<a name="l01225"></a>01225                         iterations++;   
<a name="l01226"></a>01226                         <span class="keywordtype">int</span> i;
<a name="l01227"></a>01227 
<a name="l01228"></a>01228                         <span class="keywordflow">for</span>(i=0;i&lt;k;++i)
<a name="l01229"></a>01229                         {
<a name="l01230"></a>01230                                 btVector3       c(0,0,0);
<a name="l01231"></a>01231                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++j)
<a name="l01232"></a>01232                                 {
<a name="l01233"></a>01233                                         c+=m_clusters[i]-&gt;m_nodes[j]-&gt;m_x;
<a name="l01234"></a>01234                                 }
<a name="l01235"></a>01235                                 <span class="keywordflow">if</span>(m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01236"></a>01236                                 {
<a name="l01237"></a>01237                                         c                       /=      (btScalar)m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l01238"></a>01238                                         c                       =       centers[i]+(c-centers[i])*w;
<a name="l01239"></a>01239                                         changed         |=      ((c-centers[i]).<a class="code" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d">length2</a>()&gt;SIMD_EPSILON);
<a name="l01240"></a>01240                                         centers[i]      =       c;
<a name="l01241"></a>01241                                         m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(0);
<a name="l01242"></a>01242                                 }                       
<a name="l01243"></a>01243                         }
<a name="l01244"></a>01244                         <span class="keywordflow">for</span>(i=0;i&lt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01245"></a>01245                         {
<a name="l01246"></a>01246                                 <span class="keyword">const</span> btVector3 nx=m_nodes[i].m_x;
<a name="l01247"></a>01247                                 <span class="keywordtype">int</span>                             kbest=0;
<a name="l01248"></a>01248                                 btScalar                kdist=ClusterMetric(centers[0],nx);
<a name="l01249"></a>01249                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=1;j&lt;k;++j)
<a name="l01250"></a>01250                                 {
<a name="l01251"></a>01251                                         <span class="keyword">const</span> btScalar  d=ClusterMetric(centers[j],nx);
<a name="l01252"></a>01252                                         <span class="keywordflow">if</span>(d&lt;kdist)
<a name="l01253"></a>01253                                         {
<a name="l01254"></a>01254                                                 kbest=j;
<a name="l01255"></a>01255                                                 kdist=d;
<a name="l01256"></a>01256                                         }
<a name="l01257"></a>01257                                 }
<a name="l01258"></a>01258                                 m_clusters[kbest]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_nodes[i]);
<a name="l01259"></a>01259                         }               
<a name="l01260"></a>01260                 } <span class="keywordflow">while</span>(changed&amp;&amp;(iterations&lt;maxiterations));
<a name="l01261"></a>01261                 <span class="comment">/* Merge                */</span> 
<a name="l01262"></a>01262                 <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;int&gt;</a>       cids;
<a name="l01263"></a>01263                 cids.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>(),-1);
<a name="l01264"></a>01264                 <span class="keywordflow">for</span>(i=0;i&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01265"></a>01265                 {
<a name="l01266"></a>01266                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++j)
<a name="l01267"></a>01267                         {
<a name="l01268"></a>01268                                 cids[int(m_clusters[i]-&gt;m_nodes[j]-&amp;m_nodes[0])]=i;
<a name="l01269"></a>01269                         }
<a name="l01270"></a>01270                 }
<a name="l01271"></a>01271                 <span class="keywordflow">for</span>(i=0;i&lt;m_faces.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01272"></a>01272                 {
<a name="l01273"></a>01273                         <span class="keyword">const</span> <span class="keywordtype">int</span> idx[]={       int(m_faces[i].m_n[0]-&amp;m_nodes[0]),
<a name="l01274"></a>01274                                 int(m_faces[i].m_n[1]-&amp;m_nodes[0]),
<a name="l01275"></a>01275                                 int(m_faces[i].m_n[2]-&amp;m_nodes[0])};
<a name="l01276"></a>01276                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;3;++j)
<a name="l01277"></a>01277                         {
<a name="l01278"></a>01278                                 <span class="keyword">const</span> <span class="keywordtype">int</span> cid=cids[idx[j]];
<a name="l01279"></a>01279                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> q=1;q&lt;3;++q)
<a name="l01280"></a>01280                                 {
<a name="l01281"></a>01281                                         <span class="keyword">const</span> <span class="keywordtype">int</span> kid=idx[(j+q)%3];
<a name="l01282"></a>01282                                         <span class="keywordflow">if</span>(cids[kid]!=cid)
<a name="l01283"></a>01283                                         {
<a name="l01284"></a>01284                                                 <span class="keywordflow">if</span>(m_clusters[cid]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8">findLinearSearch</a>(&amp;m_nodes[kid])==m_clusters[cid]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01285"></a>01285                                                 {
<a name="l01286"></a>01286                                                         m_clusters[cid]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_nodes[kid]);
<a name="l01287"></a>01287                                                 }
<a name="l01288"></a>01288                                         }
<a name="l01289"></a>01289                                 }
<a name="l01290"></a>01290                         }
<a name="l01291"></a>01291                 }
<a name="l01292"></a>01292                 <span class="comment">/* Master               */</span> 
<a name="l01293"></a>01293                 <span class="keywordflow">if</span>(m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()&gt;1)
<a name="l01294"></a>01294                 {
<a name="l01295"></a>01295                         Cluster*        pmaster=<span class="keyword">new</span>(btAlignedAlloc(<span class="keyword">sizeof</span>(Cluster),16)) Cluster();
<a name="l01296"></a>01296                         pmaster-&gt;m_collide      =       <span class="keyword">false</span>;
<a name="l01297"></a>01297                         pmaster-&gt;m_nodes.reserve(m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01298"></a>01298                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i) pmaster-&gt;m_nodes.push_back(&amp;m_nodes[i]);
<a name="l01299"></a>01299                         m_clusters.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(pmaster);
<a name="l01300"></a>01300                         btSwap(m_clusters[0],m_clusters[m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()-1]);
<a name="l01301"></a>01301                 }
<a name="l01302"></a>01302                 <span class="comment">/* Terminate    */</span> 
<a name="l01303"></a>01303                 <span class="keywordflow">for</span>(i=0;i&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01304"></a>01304                 {
<a name="l01305"></a>01305                         <span class="keywordflow">if</span>(m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()==0)
<a name="l01306"></a>01306                         {
<a name="l01307"></a>01307                                 releaseCluster(i--);
<a name="l01308"></a>01308                         }
<a name="l01309"></a>01309                 }
<a name="l01310"></a>01310         } <span class="keywordflow">else</span>
<a name="l01311"></a>01311         {
<a name="l01312"></a>01312                 <span class="comment">//create a cluster for each tetrahedron (if tetrahedra exist) or each face</span>
<a name="l01313"></a>01313                 <span class="keywordflow">if</span> (m_tetras.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01314"></a>01314                 {
<a name="l01315"></a>01315                         m_clusters.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_tetras.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01316"></a>01316                         <span class="keywordflow">for</span>(i=0;i&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01317"></a>01317                         {
<a name="l01318"></a>01318                                 m_clusters[i]                   =       <span class="keyword">new</span>(btAlignedAlloc(<span class="keyword">sizeof</span>(Cluster),16)) Cluster();
<a name="l01319"></a>01319                                 m_clusters[i]-&gt;m_collide=       <span class="keyword">true</span>;
<a name="l01320"></a>01320                         }
<a name="l01321"></a>01321                         <span class="keywordflow">for</span> (i=0;i&lt;m_tetras.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l01322"></a>01322                         {
<a name="l01323"></a>01323                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;4;j++)
<a name="l01324"></a>01324                                 {
<a name="l01325"></a>01325                                         m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(m_tetras[i].m_n[j]);
<a name="l01326"></a>01326                                 }
<a name="l01327"></a>01327                         }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329                 } <span class="keywordflow">else</span>
<a name="l01330"></a>01330                 {
<a name="l01331"></a>01331                         m_clusters.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_faces.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01332"></a>01332                         <span class="keywordflow">for</span>(i=0;i&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01333"></a>01333                         {
<a name="l01334"></a>01334                                 m_clusters[i]                   =       <span class="keyword">new</span>(btAlignedAlloc(<span class="keyword">sizeof</span>(Cluster),16)) Cluster();
<a name="l01335"></a>01335                                 m_clusters[i]-&gt;m_collide=       <span class="keyword">true</span>;
<a name="l01336"></a>01336                         }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338                         <span class="keywordflow">for</span>(i=0;i&lt;m_faces.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();++i)
<a name="l01339"></a>01339                         {
<a name="l01340"></a>01340                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;3;++j)
<a name="l01341"></a>01341                                 {
<a name="l01342"></a>01342                                         m_clusters[i]-&gt;m_nodes.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(m_faces[i].m_n[j]);
<a name="l01343"></a>01343                                 }
<a name="l01344"></a>01344                         }
<a name="l01345"></a>01345                 }
<a name="l01346"></a>01346         }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348         <span class="keywordflow">if</span> (m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l01349"></a>01349         {
<a name="l01350"></a>01350                 initializeClusters();
<a name="l01351"></a>01351                 updateClusters();
<a name="l01352"></a>01352 
<a name="l01353"></a>01353 
<a name="l01354"></a>01354                 <span class="comment">//for self-collision</span>
<a name="l01355"></a>01355                 m_clusterConnectivity.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()*m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01356"></a>01356                 {
<a name="l01357"></a>01357                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c0=0;c0&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();c0++)
<a name="l01358"></a>01358                         {
<a name="l01359"></a>01359                                 m_clusters[c0]-&gt;m_clusterIndex=c0;
<a name="l01360"></a>01360                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c1=0;c1&lt;m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();c1++)
<a name="l01361"></a>01361                                 {
<a name="l01362"></a>01362                                         
<a name="l01363"></a>01363                                         <span class="keywordtype">bool</span> connected=<span class="keyword">false</span>;
<a name="l01364"></a>01364                                         Cluster* cla = m_clusters[c0];
<a name="l01365"></a>01365                                         Cluster* clb = m_clusters[c1];
<a name="l01366"></a>01366                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;!connected&amp;&amp;i&lt;cla-&gt;m_nodes.size();i++)
<a name="l01367"></a>01367                                         {
<a name="l01368"></a>01368                                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;clb-&gt;m_nodes.size();j++)
<a name="l01369"></a>01369                                                 {
<a name="l01370"></a>01370                                                         <span class="keywordflow">if</span> (cla-&gt;m_nodes[i] == clb-&gt;m_nodes[j])
<a name="l01371"></a>01371                                                         {
<a name="l01372"></a>01372                                                                 connected=<span class="keyword">true</span>;
<a name="l01373"></a>01373                                                                 <span class="keywordflow">break</span>;
<a name="l01374"></a>01374                                                         }
<a name="l01375"></a>01375                                                 }
<a name="l01376"></a>01376                                         }
<a name="l01377"></a>01377                                         m_clusterConnectivity[c0+c1*m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>()]=connected;
<a name="l01378"></a>01378                                 }
<a name="l01379"></a>01379                         }
<a name="l01380"></a>01380                 }
<a name="l01381"></a>01381         }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383         <span class="keywordflow">return</span>(m_clusters.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l01384"></a>01384 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_soft_body_9915ca0d99dbeb9f39221dab218d5208_cgraph.png" border="0" usemap="#classbt_soft_body_9915ca0d99dbeb9f39221dab218d5208_cgraph_map" alt=""></center>
<map name="classbt_soft_body_9915ca0d99dbeb9f39221dab218d5208_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#e7b14c469b51e0ea010d3b9d701bc1b8" title="btAlignedObjectArray::findLinearSearch" alt="" coords="245,5,493,32"><area shape="rect" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d" title="glm::length2" alt="" coords="324,56,415,83"><area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="261,107,477,133"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="276,157,463,184"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="281,208,457,235"></map>
</div>

</div>
</div><p>
<a class="anchor" name="e8a2fc459b2afc985fbb03c1b0203bec"></a><!-- doxytag: member="btSoftBody::solveCommonConstraints" ref="e8a2fc459b2afc985fbb03c1b0203bec" args="(btSoftBody **bodies, int count, int iterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btSoftBody::solveCommonConstraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbt_soft_body.html">btSoftBody</a> **&nbsp;</td>
          <td class="paramname"> <em>bodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iterations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
placeholder 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l01955">1955</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01956"></a>01956 {
<a name="l01958"></a>01958 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ee9ac69662731fa96ae2357522972ef9"></a><!-- doxytag: member="btSoftBody::setWindVelocity" ref="ee9ac69662731fa96ae2357522972ef9" args="(const btVector3 &amp;velocity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btSoftBody::setWindVelocity           </td>
          <td>(</td>
          <td class="paramtype">const btVector3 &amp;&nbsp;</td>
          <td class="paramname"> <em>velocity</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set a wind velocity for interaction with the air. 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l03296">3296</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l03297"></a>03297 {
<a name="l03298"></a>03298         m_windVelocity = velocity;
<a name="l03299"></a>03299 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="71de05c3c56952a4d76e09ca9ca9cce0"></a><!-- doxytag: member="btSoftBody::getWindVelocity" ref="71de05c3c56952a4d76e09ca9ca9cce0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const btVector3 &amp; btSoftBody::getWindVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the wind velocity for interaction with the air. 
<p>Definition at line <a class="el" href="bt_soft_body_8cpp-source.html#l03302">3302</a> of file <a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l03303"></a>03303 {
<a name="l03304"></a>03304         <span class="keywordflow">return</span> m_windVelocity;
<a name="l03305"></a>03305 }
</pre></div>
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletSoftBody/<a class="el" href="bt_soft_body_8h-source.html">btSoftBody.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletSoftBody/<a class="el" href="bt_soft_body_8cpp-source.html">btSoftBody.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:01:55 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
