<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btMLCPSolver Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btMLCPSolver Class Reference</h1><!-- doxytag: class="btMLCPSolver" -->original version written by Erwin Coumans, October 2013  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="bt_m_l_c_p_solver_8h-source.html">btMLCPSolver.h</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for btMLCPSolver:</div>
<div class="dynsection">
<p><center><img src="classbt_m_l_c_p_solver__coll__graph.png" border="0" usemap="#bt_m_l_c_p_solver__coll__map" alt="Collaboration graph"></center>
<map name="bt_m_l_c_p_solver__coll__map">
<area shape="rect" href="classbt_m_l_c_p_solver_interface.html" title="original version written by Erwin Coumans, October 2013" alt="" coords="1383,5,1535,32"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; btSolverConstraint * \&gt;" alt="" coords="1317,56,1600,83"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; btSolverConstraint *, 16 \&gt;" alt="" coords="644,29,929,56"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, Alignment \&gt;" alt="" coords="5,96,229,123"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; T, 16 \&gt;" alt="" coords="439,96,617,123"><area shape="rect" href="classbt_aligned_allocator.html" title="btAlignedAllocator\&lt; int, 16 \&gt;" alt="" coords="693,152,880,179"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; T \&gt;" alt="" coords="955,96,1131,123"><area shape="rect" href="classbt_aligned_object_array.html" title="btAlignedObjectArray\&lt; int \&gt;" alt="" coords="1368,116,1549,143"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_m_l_c_p_solver-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c699f0a59f0b730ac39658ee2903b042"></a><!-- doxytag: member="btMLCPSolver::btMLCPSolver" ref="c699f0a59f0b730ac39658ee2903b042" args="(btMLCPSolverInterface *solver)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_m_l_c_p_solver.html#c699f0a59f0b730ac39658ee2903b042">btMLCPSolver</a> (<a class="el" href="classbt_m_l_c_p_solver_interface.html">btMLCPSolverInterface</a> *solver)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">original version written by Erwin Coumans, October 2013 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual btScalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_m_l_c_p_solver.html#a465e167537eceb89f7125d3bb2d5321">solveGroupCacheFriendlySetup</a> (btCollisionObject **bodies, int numBodies, btPersistentManifold **manifoldPtr, int numManifolds, btTypedConstraint **constraints, int numConstraints, const btContactSolverInfo &amp;infoGlobal, <a class="el" href="classbt_i_debug_draw.html">btIDebugDraw</a> *debugDrawer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_m_l_c_p_solver.html#b36b9b3bf2bbbd1de7db27ba109e0a8a">createMLCPFast</a> (const btContactSolverInfo &amp;infoGlobal)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c1feb6855fa296c8ca582842f8e4fe3"></a><!-- doxytag: member="btMLCPSolver::m_bSplit" ref="9c1feb6855fa296c8ca582842f8e4fe3" args="" -->
btVectorXu&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_m_l_c_p_solver.html#9c1feb6855fa296c8ca582842f8e4fe3">m_bSplit</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">when using 'split impulse' we solve two separate (M)LCPs <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">btMatrixXu&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_m_l_c_p_solver.html#8430698267e9572498e04e8dba3cda3b">m_scratchJ3</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
original version written by Erwin Coumans, October 2013 
<p>Definition at line <a class="el" href="bt_m_l_c_p_solver_8h-source.html#l00024">24</a> of file <a class="el" href="bt_m_l_c_p_solver_8h-source.html">btMLCPSolver.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a465e167537eceb89f7125d3bb2d5321"></a><!-- doxytag: member="btMLCPSolver::solveGroupCacheFriendlySetup" ref="a465e167537eceb89f7125d3bb2d5321" args="(btCollisionObject **bodies, int numBodies, btPersistentManifold **manifoldPtr, int numManifolds, btTypedConstraint **constraints, int numConstraints, const btContactSolverInfo &amp;infoGlobal, btIDebugDraw *debugDrawer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btScalar btMLCPSolver::solveGroupCacheFriendlySetup           </td>
          <td>(</td>
          <td class="paramtype">btCollisionObject **&nbsp;</td>
          <td class="paramname"> <em>bodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btPersistentManifold **&nbsp;</td>
          <td class="paramname"> <em>manifoldPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numManifolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btTypedConstraint **&nbsp;</td>
          <td class="paramname"> <em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btContactSolverInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>infoGlobal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbt_i_debug_draw.html">btIDebugDraw</a> *&nbsp;</td>
          <td class="paramname"> <em>debugDrawer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
The btSequentialImpulseConstraintSolver moves all friction constraints at the very end, we can also interleave them instead 
<p>Definition at line <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html#l00036">36</a> of file <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html">btMLCPSolver.cpp</a>.</p>

<p>References <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html#l00154">createMLCPFast()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00037"></a>00037 {
<a name="l00038"></a>00038         btSequentialImpulseConstraintSolver::solveGroupCacheFriendlySetup( bodies, numBodiesUnUsed, manifoldPtr, numManifolds,constraints,numConstraints,infoGlobal,debugDrawer);
<a name="l00039"></a>00039 
<a name="l00040"></a>00040         {
<a name="l00041"></a>00041                 BT_PROFILE(<span class="stringliteral">"gather constraint data"</span>);
<a name="l00042"></a>00042 
<a name="l00043"></a>00043                 <span class="keywordtype">int</span> numFrictionPerContact = m_tmpSolverContactConstraintPool.size()==m_tmpSolverContactFrictionConstraintPool.size()? 1 : 2;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         <span class="comment">//      int numBodies = m_tmpSolverBodyPool.size();</span>
<a name="l00047"></a>00047                 m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(0);
<a name="l00048"></a>00048                 m_limitDependencies.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(m_tmpSolverNonContactConstraintPool.size()+m_tmpSolverContactConstraintPool.size()+m_tmpSolverContactFrictionConstraintPool.size());
<a name="l00049"></a>00049                 btAssert(m_limitDependencies.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>() == m_tmpSolverNonContactConstraintPool.size()+m_tmpSolverContactConstraintPool.size()+m_tmpSolverContactFrictionConstraintPool.size());
<a name="l00050"></a>00050         <span class="comment">//      printf("m_limitDependencies.size() = %d\n",m_limitDependencies.size());</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052                 <span class="keywordtype">int</span> dindex = 0;
<a name="l00053"></a>00053                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_tmpSolverNonContactConstraintPool.size();i++)
<a name="l00054"></a>00054                 {
<a name="l00055"></a>00055                         m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverNonContactConstraintPool[i]);
<a name="l00056"></a>00056                         m_limitDependencies[dindex++] = -1;
<a name="l00057"></a>00057                 }
<a name="l00058"></a>00058  
<a name="l00060"></a>00060                 
<a name="l00061"></a>00061                 <span class="keywordtype">int</span> firstContactConstraintOffset=dindex;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063                 <span class="keywordflow">if</span> (interleaveContactAndFriction)
<a name="l00064"></a>00064                 {
<a name="l00065"></a>00065                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_tmpSolverContactConstraintPool.size();i++)
<a name="l00066"></a>00066                         {
<a name="l00067"></a>00067                                 m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverContactConstraintPool[i]);
<a name="l00068"></a>00068                                 m_limitDependencies[dindex++] = -1;
<a name="l00069"></a>00069                                 m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact]);
<a name="l00070"></a>00070                                 <span class="keywordtype">int</span> findex = (m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact].m_frictionIndex*(1+numFrictionPerContact));
<a name="l00071"></a>00071                                 m_limitDependencies[dindex++] = findex +firstContactConstraintOffset;
<a name="l00072"></a>00072                                 <span class="keywordflow">if</span> (numFrictionPerContact==2)
<a name="l00073"></a>00073                                 {
<a name="l00074"></a>00074                                         m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverContactFrictionConstraintPool[i*numFrictionPerContact+1]);
<a name="l00075"></a>00075                                         m_limitDependencies[dindex++] = findex+firstContactConstraintOffset;
<a name="l00076"></a>00076                                 }
<a name="l00077"></a>00077                         }
<a name="l00078"></a>00078                 } <span class="keywordflow">else</span>
<a name="l00079"></a>00079                 {
<a name="l00080"></a>00080                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_tmpSolverContactConstraintPool.size();i++)
<a name="l00081"></a>00081                         {
<a name="l00082"></a>00082                                 m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverContactConstraintPool[i]);
<a name="l00083"></a>00083                                 m_limitDependencies[dindex++] = -1;
<a name="l00084"></a>00084                         }
<a name="l00085"></a>00085                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_tmpSolverContactFrictionConstraintPool.size();i++)
<a name="l00086"></a>00086                         {
<a name="l00087"></a>00087                                 m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(&amp;m_tmpSolverContactFrictionConstraintPool[i]);
<a name="l00088"></a>00088                                 m_limitDependencies[dindex++] = m_tmpSolverContactFrictionConstraintPool[i].m_frictionIndex+firstContactConstraintOffset;
<a name="l00089"></a>00089                         }
<a name="l00090"></a>00090                         
<a name="l00091"></a>00091                 }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 
<a name="l00094"></a>00094                 <span class="keywordflow">if</span> (!m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>())
<a name="l00095"></a>00095                 {
<a name="l00096"></a>00096                         m_A.resize(0,0);
<a name="l00097"></a>00097                         m_b.resize(0);
<a name="l00098"></a>00098                         m_x.resize(0);
<a name="l00099"></a>00099                         m_lo.resize(0);
<a name="l00100"></a>00100                         m_hi.resize(0);
<a name="l00101"></a>00101                         <span class="keywordflow">return</span> 0.f;
<a name="l00102"></a>00102                 }
<a name="l00103"></a>00103         }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (gUseMatrixMultiply)
<a name="l00107"></a>00107         {
<a name="l00108"></a>00108                 BT_PROFILE(<span class="stringliteral">"createMLCP"</span>);
<a name="l00109"></a>00109                 createMLCP(infoGlobal);
<a name="l00110"></a>00110         }
<a name="l00111"></a>00111         <span class="keywordflow">else</span>
<a name="l00112"></a>00112         {
<a name="l00113"></a>00113                 BT_PROFILE(<span class="stringliteral">"createMLCPFast"</span>);
<a name="l00114"></a>00114                 <a class="code" href="classbt_m_l_c_p_solver.html#b36b9b3bf2bbbd1de7db27ba109e0a8a">createMLCPFast</a>(infoGlobal);
<a name="l00115"></a>00115         }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keywordflow">return</span> 0.f;
<a name="l00118"></a>00118 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_m_l_c_p_solver_a465e167537eceb89f7125d3bb2d5321_cgraph.png" border="0" usemap="#classbt_m_l_c_p_solver_a465e167537eceb89f7125d3bb2d5321_cgraph_map" alt=""></center>
<map name="classbt_m_l_c_p_solver_a465e167537eceb89f7125d3bb2d5321_cgraph_map">
<area shape="rect" href="classbt_m_l_c_p_solver.html#b36b9b3bf2bbbd1de7db27ba109e0a8a" title="btMLCPSolver::createMLCPFast" alt="" coords="351,208,559,235"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="643,309,829,336"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="648,360,824,387"><area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="347,411,563,437"><area shape="rect" href="classbt_aligned_object_array.html#d64affb4ed3f9db81f832cbac6b62527" title="btAlignedObjectArray::expand" alt="" coords="639,5,833,32"><area shape="rect" href="classbt_rigid_body.html#ac3284d52f4dd4628a0e0ffbc6e05908" title="btRigidBody::getInvInertiaTensorWorld" alt="" coords="616,56,856,83"><area shape="rect" href="classbt_rigid_body.html#ff8193d59d882da6de7236b2410d7e52" title="btRigidBody::getInvMass" alt="" coords="655,107,817,133"><area shape="rect" href="classbt_aligned_object_array.html#0bcdc850355c6742c66d50b16b102d9d" title="btAlignedObjectArray::reserve" alt="" coords="640,157,832,184"><area shape="rect" href="classbt_aligned_object_array.html#2cc58c74534181a7a10e5c6ab8b21227" title="btAlignedObjectArray::resizeNoInitialize" alt="" coords="611,208,861,235"><area shape="rect" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44" title="glm::row" alt="" coords="701,259,771,285"><area shape="rect" href="group__core__func__geometric.html#gd73a94d9c967e619e670156356e93b7e" title="glm::length" alt="" coords="909,259,995,285"><area shape="rect" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1" title="glm::abs" alt="" coords="1043,259,1115,285"></map>
</div>

</div>
</div><p>
<a class="anchor" name="b36b9b3bf2bbbd1de7db27ba109e0a8a"></a><!-- doxytag: member="btMLCPSolver::createMLCPFast" ref="b36b9b3bf2bbbd1de7db27ba109e0a8a" args="(const btContactSolverInfo &amp;infoGlobal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btMLCPSolver::createMLCPFast           </td>
          <td>(</td>
          <td class="paramtype">const btContactSolverInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>infoGlobal</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
fill the upper triangle of the matrix, to make it symmetric 
<p>Definition at line <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html#l00154">154</a> of file <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html">btMLCPSolver.cpp</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00258">btAlignedObjectArray&lt; T &gt;::expand()</a>, <a class="el" href="bt_rigid_body_8h-source.html#l00274">btRigidBody::getInvInertiaTensorWorld()</a>, <a class="el" href="bt_rigid_body_8h-source.html#l00273">btRigidBody::getInvMass()</a>, <a class="el" href="bt_m_l_c_p_solver_8h-source.html#l00036">m_bSplit</a>, <a class="el" href="bt_m_l_c_p_solver_8h-source.html#l00049">m_scratchJ3</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00298">btAlignedObjectArray&lt; T &gt;::reserve()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00218">btAlignedObjectArray&lt; T &gt;::resize()</a>, <a class="el" href="bt_aligned_object_array_8h-source.html#l00209">btAlignedObjectArray&lt; T &gt;::resizeNoInitialize()</a>, <a class="el" href="matrix__access_8inl-source.html#l00033">glm::row()</a>, and <a class="el" href="bt_aligned_object_array_8h-source.html#l00155">btAlignedObjectArray&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html#l00036">solveGroupCacheFriendlySetup()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00155"></a>00155 {
<a name="l00156"></a>00156         <span class="keywordtype">int</span> numContactRows = interleaveContactAndFriction ? 3 : 1;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158         <span class="keywordtype">int</span> numConstraintRows = m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l00159"></a>00159         <span class="keywordtype">int</span> n = numConstraintRows;
<a name="l00160"></a>00160         {
<a name="l00161"></a>00161                 BT_PROFILE(<span class="stringliteral">"init b (rhs)"</span>);
<a name="l00162"></a>00162                 m_b.resize(numConstraintRows);
<a name="l00163"></a>00163                 <a class="code" href="classbt_m_l_c_p_solver.html#9c1feb6855fa296c8ca582842f8e4fe3" title="when using &amp;#39;split impulse&amp;#39; we solve two separate (M)LCPs">m_bSplit</a>.resize(numConstraintRows);
<a name="l00164"></a>00164                 m_b.setZero();
<a name="l00165"></a>00165                 <a class="code" href="classbt_m_l_c_p_solver.html#9c1feb6855fa296c8ca582842f8e4fe3" title="when using &amp;#39;split impulse&amp;#39; we solve two separate (M)LCPs">m_bSplit</a>.setZero();
<a name="l00166"></a>00166                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numConstraintRows ;i++)
<a name="l00167"></a>00167                 {
<a name="l00168"></a>00168                         btScalar jacDiag = m_allConstraintPtrArray[i]-&gt;m_jacDiagABInv;
<a name="l00169"></a>00169                         <span class="keywordflow">if</span> (!btFuzzyZero(jacDiag))
<a name="l00170"></a>00170                         {
<a name="l00171"></a>00171                                 btScalar rhs = m_allConstraintPtrArray[i]-&gt;m_rhs;
<a name="l00172"></a>00172                                 btScalar rhsPenetration = m_allConstraintPtrArray[i]-&gt;m_rhsPenetration;
<a name="l00173"></a>00173                                 m_b[i]=rhs/jacDiag;
<a name="l00174"></a>00174                                 <a class="code" href="classbt_m_l_c_p_solver.html#9c1feb6855fa296c8ca582842f8e4fe3" title="when using &amp;#39;split impulse&amp;#39; we solve two separate (M)LCPs">m_bSplit</a>[i] = rhsPenetration/jacDiag;
<a name="l00175"></a>00175                         }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177                 }
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">//      btScalar* w = 0;</span>
<a name="l00181"></a>00181 <span class="comment">//      int nub = 0;</span>
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         m_lo.resize(numConstraintRows);
<a name="l00184"></a>00184         m_hi.resize(numConstraintRows);
<a name="l00185"></a>00185  
<a name="l00186"></a>00186         {
<a name="l00187"></a>00187                 BT_PROFILE(<span class="stringliteral">"init lo/ho"</span>);
<a name="l00188"></a>00188 
<a name="l00189"></a>00189                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numConstraintRows;i++)
<a name="l00190"></a>00190                 {
<a name="l00191"></a>00191                         <span class="keywordflow">if</span> (0)<span class="comment">//m_limitDependencies[i]&gt;=0)</span>
<a name="l00192"></a>00192                         {
<a name="l00193"></a>00193                                 m_lo[i] = -BT_INFINITY;
<a name="l00194"></a>00194                                 m_hi[i] = BT_INFINITY;
<a name="l00195"></a>00195                         } <span class="keywordflow">else</span>
<a name="l00196"></a>00196                         {
<a name="l00197"></a>00197                                 m_lo[i] = m_allConstraintPtrArray[i]-&gt;m_lowerLimit;
<a name="l00198"></a>00198                                 m_hi[i] = m_allConstraintPtrArray[i]-&gt;m_upperLimit;
<a name="l00199"></a>00199                         }
<a name="l00200"></a>00200                 }
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202 
<a name="l00203"></a>00203         <span class="comment">//</span>
<a name="l00204"></a>00204         <span class="keywordtype">int</span> m=m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordtype">int</span> numBodies = m_tmpSolverBodyPool.size();
<a name="l00207"></a>00207         <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;int&gt;</a> bodyJointNodeArray;
<a name="l00208"></a>00208         {
<a name="l00209"></a>00209                 BT_PROFILE(<span class="stringliteral">"bodyJointNodeArray.resize"</span>);
<a name="l00210"></a>00210                 bodyJointNodeArray.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(numBodies,-1);
<a name="l00211"></a>00211         }
<a name="l00212"></a>00212         <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;btJointNode&gt;</a> jointNodeArray;
<a name="l00213"></a>00213         {
<a name="l00214"></a>00214                 BT_PROFILE(<span class="stringliteral">"jointNodeArray.reserve"</span>);
<a name="l00215"></a>00215                 jointNodeArray.<a class="code" href="classbt_aligned_object_array.html#0bcdc850355c6742c66d50b16b102d9d">reserve</a>(2*m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218     btMatrixXu&amp; J3 = <a class="code" href="classbt_m_l_c_p_solver.html#8430698267e9572498e04e8dba3cda3b">m_scratchJ3</a>;
<a name="l00219"></a>00219         {
<a name="l00220"></a>00220                 BT_PROFILE(<span class="stringliteral">"J3.resize"</span>);
<a name="l00221"></a>00221                 J3.resize(2*m,8);
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223     btMatrixXu&amp; JinvM3 = m_scratchJInvM3;
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225                 BT_PROFILE(<span class="stringliteral">"JinvM3.resize/setZero"</span>);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227                 JinvM3.resize(2*m,8);
<a name="l00228"></a>00228                 JinvM3.setZero();
<a name="l00229"></a>00229                 J3.setZero();
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         <span class="keywordtype">int</span> cur=0;
<a name="l00232"></a>00232         <span class="keywordtype">int</span> rowOffset = 0;
<a name="l00233"></a>00233     <a class="code" href="classbt_aligned_object_array.html">btAlignedObjectArray&lt;int&gt;</a>&amp; ofs = m_scratchOfs;
<a name="l00234"></a>00234         {
<a name="l00235"></a>00235                 BT_PROFILE(<span class="stringliteral">"ofs resize"</span>);
<a name="l00236"></a>00236                 ofs.<a class="code" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190">resize</a>(0);
<a name="l00237"></a>00237                 ofs.<a class="code" href="classbt_aligned_object_array.html#2cc58c74534181a7a10e5c6ab8b21227">resizeNoInitialize</a>(m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>());
<a name="l00238"></a>00238         }                               
<a name="l00239"></a>00239         {
<a name="l00240"></a>00240                 BT_PROFILE(<span class="stringliteral">"Compute J and JinvM"</span>);
<a name="l00241"></a>00241                 <span class="keywordtype">int</span> c=0;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243                 <span class="keywordtype">int</span> numRows = 0;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i+=numRows,c++)
<a name="l00246"></a>00246                 {
<a name="l00247"></a>00247                         ofs[c] = rowOffset;
<a name="l00248"></a>00248                         <span class="keywordtype">int</span> sbA = m_allConstraintPtrArray[i]-&gt;m_solverBodyIdA;
<a name="l00249"></a>00249                         <span class="keywordtype">int</span> sbB = m_allConstraintPtrArray[i]-&gt;m_solverBodyIdB;
<a name="l00250"></a>00250                         <a class="code" href="classbt_rigid_body.html">btRigidBody</a>* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;
<a name="l00251"></a>00251                         <a class="code" href="classbt_rigid_body.html">btRigidBody</a>* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;
<a name="l00252"></a>00252 
<a name="l00253"></a>00253                         numRows = i&lt;m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[c].m_numConstraintRows : numContactRows ;
<a name="l00254"></a>00254                         <span class="keywordflow">if</span> (orgBodyA)
<a name="l00255"></a>00255                         {
<a name="l00256"></a>00256                                 {
<a name="l00257"></a>00257                                         <span class="keywordtype">int</span> slotA=-1;
<a name="l00258"></a>00258                                         <span class="comment">//find free jointNode slot for sbA</span>
<a name="l00259"></a>00259                                         slotA =jointNodeArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l00260"></a>00260                                         jointNodeArray.<a class="code" href="classbt_aligned_object_array.html#d64affb4ed3f9db81f832cbac6b62527">expand</a>();<span class="comment">//NonInitializing();</span>
<a name="l00261"></a>00261                                         <span class="keywordtype">int</span> prevSlot = bodyJointNodeArray[sbA];
<a name="l00262"></a>00262                                         bodyJointNodeArray[sbA] = slotA;
<a name="l00263"></a>00263                                         jointNodeArray[slotA].nextJointNodeIndex = prevSlot;
<a name="l00264"></a>00264                                         jointNodeArray[slotA].jointIndex = c;
<a name="l00265"></a>00265                                         jointNodeArray[slotA].constraintRowIndex = i;
<a name="l00266"></a>00266                                         jointNodeArray[slotA].otherBodyIndex = orgBodyB ? sbB : -1;
<a name="l00267"></a>00267                                 }
<a name="l00268"></a>00268                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>=0;<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>&lt;numRows;<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>++,cur++)
<a name="l00269"></a>00269                                 {
<a name="l00270"></a>00270                                         btVector3 normalInvMass =                               m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_contactNormal1 *              orgBodyA-&gt;<a class="code" href="classbt_rigid_body.html#ff8193d59d882da6de7236b2410d7e52">getInvMass</a>();
<a name="l00271"></a>00271                                         btVector3 relPosCrossNormalInvInertia = m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_relpos1CrossNormal *  orgBodyA-&gt;<a class="code" href="classbt_rigid_body.html#ac3284d52f4dd4628a0e0ffbc6e05908">getInvInertiaTensorWorld</a>();
<a name="l00272"></a>00272 
<a name="l00273"></a>00273                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r=0;r&lt;3;r++)
<a name="l00274"></a>00274                                         {
<a name="l00275"></a>00275                                                 J3.setElem(cur,r,m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_contactNormal1[r]);
<a name="l00276"></a>00276                                                 J3.setElem(cur,r+4,m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_relpos1CrossNormal[r]);
<a name="l00277"></a>00277                                                 JinvM3.setElem(cur,r,normalInvMass[r]);
<a name="l00278"></a>00278                                                 JinvM3.setElem(cur,r+4,relPosCrossNormalInvInertia[r]);
<a name="l00279"></a>00279                                         }
<a name="l00280"></a>00280                                         J3.setElem(cur,3,0);
<a name="l00281"></a>00281                                         JinvM3.setElem(cur,3,0);
<a name="l00282"></a>00282                                         J3.setElem(cur,7,0);
<a name="l00283"></a>00283                                         JinvM3.setElem(cur,7,0);
<a name="l00284"></a>00284                                 }
<a name="l00285"></a>00285                         } <span class="keywordflow">else</span>
<a name="l00286"></a>00286                         {
<a name="l00287"></a>00287                                 cur += numRows;
<a name="l00288"></a>00288                         }
<a name="l00289"></a>00289                         <span class="keywordflow">if</span> (orgBodyB)
<a name="l00290"></a>00290                         {
<a name="l00291"></a>00291 
<a name="l00292"></a>00292                                 {
<a name="l00293"></a>00293                                         <span class="keywordtype">int</span> slotB=-1;
<a name="l00294"></a>00294                                         <span class="comment">//find free jointNode slot for sbA</span>
<a name="l00295"></a>00295                                         slotB =jointNodeArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l00296"></a>00296                                         jointNodeArray.<a class="code" href="classbt_aligned_object_array.html#d64affb4ed3f9db81f832cbac6b62527">expand</a>();<span class="comment">//NonInitializing();</span>
<a name="l00297"></a>00297                                         <span class="keywordtype">int</span> prevSlot = bodyJointNodeArray[sbB];
<a name="l00298"></a>00298                                         bodyJointNodeArray[sbB] = slotB;
<a name="l00299"></a>00299                                         jointNodeArray[slotB].nextJointNodeIndex = prevSlot;
<a name="l00300"></a>00300                                         jointNodeArray[slotB].jointIndex = c;
<a name="l00301"></a>00301                                         jointNodeArray[slotB].otherBodyIndex = orgBodyA ? sbA : -1;
<a name="l00302"></a>00302                                         jointNodeArray[slotB].constraintRowIndex = i;
<a name="l00303"></a>00303                                 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>=0;<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>&lt;numRows;<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>++,cur++)
<a name="l00306"></a>00306                                 {
<a name="l00307"></a>00307                                         btVector3 normalInvMassB = m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_contactNormal2*orgBodyB-&gt;<a class="code" href="classbt_rigid_body.html#ff8193d59d882da6de7236b2410d7e52">getInvMass</a>();
<a name="l00308"></a>00308                                         btVector3 relPosInvInertiaB = m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_relpos2CrossNormal * orgBodyB-&gt;<a class="code" href="classbt_rigid_body.html#ac3284d52f4dd4628a0e0ffbc6e05908">getInvInertiaTensorWorld</a>();
<a name="l00309"></a>00309 
<a name="l00310"></a>00310                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r=0;r&lt;3;r++)
<a name="l00311"></a>00311                                         {
<a name="l00312"></a>00312                                                 J3.setElem(cur,r,m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_contactNormal2[r]);
<a name="l00313"></a>00313                                                 J3.setElem(cur,r+4,m_allConstraintPtrArray[i+<a class="code" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44">row</a>]-&gt;m_relpos2CrossNormal[r]);
<a name="l00314"></a>00314                                                 JinvM3.setElem(cur,r,normalInvMassB[r]);
<a name="l00315"></a>00315                                                 JinvM3.setElem(cur,r+4,relPosInvInertiaB[r]);
<a name="l00316"></a>00316                                         }
<a name="l00317"></a>00317                                         J3.setElem(cur,3,0);
<a name="l00318"></a>00318                                         JinvM3.setElem(cur,3,0);
<a name="l00319"></a>00319                                         J3.setElem(cur,7,0);
<a name="l00320"></a>00320                                         JinvM3.setElem(cur,7,0);
<a name="l00321"></a>00321                                 }
<a name="l00322"></a>00322                         }
<a name="l00323"></a>00323                         <span class="keywordflow">else</span>
<a name="l00324"></a>00324                         {
<a name="l00325"></a>00325                                 cur += numRows;
<a name="l00326"></a>00326                         }
<a name="l00327"></a>00327                         rowOffset+=numRows;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329                 }
<a name="l00330"></a>00330                 
<a name="l00331"></a>00331         }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 
<a name="l00334"></a>00334         <span class="comment">//compute JinvM = J*invM.</span>
<a name="l00335"></a>00335         <span class="keyword">const</span> btScalar* JinvM = JinvM3.getBufferPointer();
<a name="l00336"></a>00336 
<a name="l00337"></a>00337         <span class="keyword">const</span> btScalar* Jptr = J3.getBufferPointer();
<a name="l00338"></a>00338         {
<a name="l00339"></a>00339                 BT_PROFILE(<span class="stringliteral">"m_A.resize"</span>);
<a name="l00340"></a>00340                 m_A.resize(n,n);
<a name="l00341"></a>00341         }
<a name="l00342"></a>00342         
<a name="l00343"></a>00343         {
<a name="l00344"></a>00344                 BT_PROFILE(<span class="stringliteral">"m_A.setZero"</span>);
<a name="l00345"></a>00345                 m_A.setZero();
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347         <span class="keywordtype">int</span> c=0;
<a name="l00348"></a>00348         {
<a name="l00349"></a>00349                 <span class="keywordtype">int</span> numRows = 0;
<a name="l00350"></a>00350                 BT_PROFILE(<span class="stringliteral">"Compute A"</span>);
<a name="l00351"></a>00351                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i+= numRows,c++)
<a name="l00352"></a>00352                 {
<a name="l00353"></a>00353                         <span class="keywordtype">int</span> row__ = ofs[c];
<a name="l00354"></a>00354                         <span class="keywordtype">int</span> sbA = m_allConstraintPtrArray[i]-&gt;m_solverBodyIdA;
<a name="l00355"></a>00355                         <span class="keywordtype">int</span> sbB = m_allConstraintPtrArray[i]-&gt;m_solverBodyIdB;
<a name="l00356"></a>00356                 <span class="comment">//      btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;</span>
<a name="l00357"></a>00357                 <span class="comment">//      btRigidBody* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359                         numRows = i&lt;m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[c].m_numConstraintRows : numContactRows ;
<a name="l00360"></a>00360                                         
<a name="l00361"></a>00361                         <span class="keyword">const</span> btScalar *JinvMrow = JinvM + 2*8*(size_t)row__;
<a name="l00362"></a>00362 
<a name="l00363"></a>00363                         {
<a name="l00364"></a>00364                                 <span class="keywordtype">int</span> startJointNodeA = bodyJointNodeArray[sbA];
<a name="l00365"></a>00365                                 <span class="keywordflow">while</span> (startJointNodeA&gt;=0)
<a name="l00366"></a>00366                                 {
<a name="l00367"></a>00367                                         <span class="keywordtype">int</span> j0 = jointNodeArray[startJointNodeA].jointIndex;
<a name="l00368"></a>00368                                         <span class="keywordtype">int</span> cr0 = jointNodeArray[startJointNodeA].constraintRowIndex;
<a name="l00369"></a>00369                                         <span class="keywordflow">if</span> (j0&lt;c)
<a name="l00370"></a>00370                                         {
<a name="l00371"></a>00371                                                                  
<a name="l00372"></a>00372                                                 <span class="keywordtype">int</span> numRowsOther = cr0 &lt; m_tmpSolverNonContactConstraintPool.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>() ? m_tmpConstraintSizesPool[j0].m_numConstraintRows : numContactRows;
<a name="l00373"></a>00373                                                 <span class="keywordtype">size_t</span> ofsother = (m_allConstraintPtrArray[cr0]-&gt;m_solverBodyIdB == sbA) ? 8*numRowsOther  : 0;
<a name="l00374"></a>00374                                                 <span class="comment">//printf("%d joint i %d and j0: %d: ",count++,i,j0);</span>
<a name="l00375"></a>00375                                                 m_A.multiplyAdd2_p8r ( JinvMrow, 
<a name="l00376"></a>00376                                                 Jptr + 2*8*(<span class="keywordtype">size_t</span>)ofs[j0] + ofsother, numRows, numRowsOther,  row__,ofs[j0]);
<a name="l00377"></a>00377                                         }
<a name="l00378"></a>00378                                         startJointNodeA = jointNodeArray[startJointNodeA].nextJointNodeIndex;
<a name="l00379"></a>00379                                 }
<a name="l00380"></a>00380                         }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382                         {
<a name="l00383"></a>00383                                 <span class="keywordtype">int</span> startJointNodeB = bodyJointNodeArray[sbB];
<a name="l00384"></a>00384                                 <span class="keywordflow">while</span> (startJointNodeB&gt;=0)
<a name="l00385"></a>00385                                 {
<a name="l00386"></a>00386                                         <span class="keywordtype">int</span> j1 = jointNodeArray[startJointNodeB].jointIndex;
<a name="l00387"></a>00387                                         <span class="keywordtype">int</span> cj1 = jointNodeArray[startJointNodeB].constraintRowIndex;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389                                         <span class="keywordflow">if</span> (j1&lt;c)
<a name="l00390"></a>00390                                         {
<a name="l00391"></a>00391                                                 <span class="keywordtype">int</span> numRowsOther =  cj1 &lt; m_tmpSolverNonContactConstraintPool.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>() ? m_tmpConstraintSizesPool[j1].m_numConstraintRows : numContactRows;
<a name="l00392"></a>00392                                                 <span class="keywordtype">size_t</span> ofsother = (m_allConstraintPtrArray[cj1]-&gt;m_solverBodyIdB == sbB) ? 8*numRowsOther  : 0;
<a name="l00393"></a>00393                                                 m_A.multiplyAdd2_p8r ( JinvMrow + 8*(<span class="keywordtype">size_t</span>)numRows, 
<a name="l00394"></a>00394                                                 Jptr + 2*8*(<span class="keywordtype">size_t</span>)ofs[j1] + ofsother, numRows, numRowsOther, row__,ofs[j1]);
<a name="l00395"></a>00395                                         }
<a name="l00396"></a>00396                                         startJointNodeB = jointNodeArray[startJointNodeB].nextJointNodeIndex;
<a name="l00397"></a>00397                                 }
<a name="l00398"></a>00398                         }
<a name="l00399"></a>00399                 }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401                 {
<a name="l00402"></a>00402                         BT_PROFILE(<span class="stringliteral">"compute diagonal"</span>);
<a name="l00403"></a>00403                         <span class="comment">// compute diagonal blocks of m_A</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405                         <span class="keywordtype">int</span>  row__ = 0;
<a name="l00406"></a>00406                         <span class="keywordtype">int</span> numJointRows = m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();
<a name="l00407"></a>00407 
<a name="l00408"></a>00408                         <span class="keywordtype">int</span> jj=0;
<a name="l00409"></a>00409                         <span class="keywordflow">for</span> (;row__&lt;numJointRows;)
<a name="l00410"></a>00410                         {
<a name="l00411"></a>00411 
<a name="l00412"></a>00412                                 <span class="comment">//int sbA = m_allConstraintPtrArray[row__]-&gt;m_solverBodyIdA;</span>
<a name="l00413"></a>00413                                 <span class="keywordtype">int</span> sbB = m_allConstraintPtrArray[row__]-&gt;m_solverBodyIdB;
<a name="l00414"></a>00414                         <span class="comment">//      btRigidBody* orgBodyA = m_tmpSolverBodyPool[sbA].m_originalBody;</span>
<a name="l00415"></a>00415                                 <a class="code" href="classbt_rigid_body.html">btRigidBody</a>* orgBodyB = m_tmpSolverBodyPool[sbB].m_originalBody;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417 
<a name="l00418"></a>00418                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> infom =  row__ &lt; m_tmpSolverNonContactConstraintPool.size() ? m_tmpConstraintSizesPool[jj].m_numConstraintRows : numContactRows;
<a name="l00419"></a>00419                                 
<a name="l00420"></a>00420                                 <span class="keyword">const</span> btScalar *JinvMrow = JinvM + 2*8*(size_t)row__;
<a name="l00421"></a>00421                                 <span class="keyword">const</span> btScalar *Jrow = Jptr + 2*8*(size_t)row__;
<a name="l00422"></a>00422                                 m_A.multiply2_p8r (JinvMrow, Jrow, infom, infom, row__,row__);
<a name="l00423"></a>00423                                 <span class="keywordflow">if</span> (orgBodyB) 
<a name="l00424"></a>00424                                 {
<a name="l00425"></a>00425                                         m_A.multiplyAdd2_p8r (JinvMrow + 8*(<span class="keywordtype">size_t</span>)infom, Jrow + 8*(<span class="keywordtype">size_t</span>)infom, infom, infom,  row__,row__);
<a name="l00426"></a>00426                                 }
<a name="l00427"></a>00427                                 row__ += infom;
<a name="l00428"></a>00428                                 jj++;
<a name="l00429"></a>00429                         }
<a name="l00430"></a>00430                 }
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433         <span class="keywordflow">if</span> (1)
<a name="l00434"></a>00434         {
<a name="l00435"></a>00435                 <span class="comment">// add cfm to the diagonal of m_A</span>
<a name="l00436"></a>00436                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;m_A.rows(); ++i) 
<a name="l00437"></a>00437                 {
<a name="l00438"></a>00438                         m_A.setElem(i,i,m_A(i,i)+ infoGlobal.m_globalCfm/ infoGlobal.m_timeStep);
<a name="l00439"></a>00439                 }
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441                                    
<a name="l00443"></a>00443         {
<a name="l00444"></a>00444                 BT_PROFILE(<span class="stringliteral">"fill the upper triangle "</span>);
<a name="l00445"></a>00445                 m_A.copyLowerToUpperTriangle();
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         {
<a name="l00449"></a>00449                 BT_PROFILE(<span class="stringliteral">"resize/init x"</span>);
<a name="l00450"></a>00450                 m_x.resize(numConstraintRows);
<a name="l00451"></a>00451                 m_xSplit.resize(numConstraintRows);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453                 <span class="keywordflow">if</span> (infoGlobal.m_solverMode&amp;SOLVER_USE_WARMSTARTING)
<a name="l00454"></a>00454                 {
<a name="l00455"></a>00455                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;m_allConstraintPtrArray.<a class="code" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array">size</a>();i++)
<a name="l00456"></a>00456                         {
<a name="l00457"></a>00457                                 <span class="keyword">const</span> btSolverConstraint&amp; c = *m_allConstraintPtrArray[i];
<a name="l00458"></a>00458                                 m_x[i]=c.m_appliedImpulse;
<a name="l00459"></a>00459                                 m_xSplit[i] = c.m_appliedPushImpulse;
<a name="l00460"></a>00460                         }
<a name="l00461"></a>00461                 } <span class="keywordflow">else</span>
<a name="l00462"></a>00462                 {
<a name="l00463"></a>00463                         m_x.setZero();
<a name="l00464"></a>00464                         m_xSplit.setZero();
<a name="l00465"></a>00465                 }
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_cgraph.png" border="0" usemap="#classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_cgraph_map" alt=""></center>
<map name="classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#d64affb4ed3f9db81f832cbac6b62527" title="btAlignedObjectArray::expand" alt="" coords="292,5,487,32"><area shape="rect" href="classbt_rigid_body.html#ac3284d52f4dd4628a0e0ffbc6e05908" title="btRigidBody::getInvInertiaTensorWorld" alt="" coords="269,56,509,83"><area shape="rect" href="classbt_rigid_body.html#ff8193d59d882da6de7236b2410d7e52" title="btRigidBody::getInvMass" alt="" coords="308,107,471,133"><area shape="rect" href="classbt_aligned_object_array.html#0bcdc850355c6742c66d50b16b102d9d" title="btAlignedObjectArray::reserve" alt="" coords="293,157,485,184"><area shape="rect" href="classbt_aligned_object_array.html#6a48cd9cb91d0cfa50ee1c70ef485190" title="btAlignedObjectArray::resize" alt="" coords="296,208,483,235"><area shape="rect" href="classbt_aligned_object_array.html#2cc58c74534181a7a10e5c6ab8b21227" title="btAlignedObjectArray::resizeNoInitialize" alt="" coords="264,259,515,285"><area shape="rect" href="group__gtc__matrix__access.html#g4409b9c0604f3ed3e6f116b6680eae44" title="glm::row" alt="" coords="355,309,424,336"><area shape="rect" href="classbt_aligned_object_array.html#6bdd14c7599ecb95e8d83dd5a715f9b7" title="return the number of elements in the array" alt="" coords="301,360,477,387"><area shape="rect" href="group__core__func__geometric.html#gd73a94d9c967e619e670156356e93b7e" title="glm::length" alt="" coords="563,309,648,336"><area shape="rect" href="group__core__func__common.html#gab4b95b47f2918ce6e7ac279a0ba27c1" title="glm::abs" alt="" coords="696,309,768,336"></map>
</div>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_icgraph.png" border="0" usemap="#classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_icgraph_map" alt=""></center>
<map name="classbt_m_l_c_p_solver_b36b9b3bf2bbbd1de7db27ba109e0a8a_icgraph_map">
<area shape="rect" href="classbt_m_l_c_p_solver.html#a465e167537eceb89f7125d3bb2d5321" title="btMLCPSolver::solveGroupCacheFriendlySetup" alt="" coords="265,5,556,32"></map>
</div>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8430698267e9572498e04e8dba3cda3b"></a><!-- doxytag: member="btMLCPSolver::m_scratchJ3" ref="8430698267e9572498e04e8dba3cda3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btMatrixXu <a class="el" href="classbt_m_l_c_p_solver.html#8430698267e9572498e04e8dba3cda3b">btMLCPSolver::m_scratchJ3</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The following scratch variables are not stateful -- contents are cleared prior to each use. They are only cached here to avoid extra memory allocations and deallocations and to ensure that multiple instances of the solver can be run in parallel. 
<p>Definition at line <a class="el" href="bt_m_l_c_p_solver_8h-source.html#l00049">49</a> of file <a class="el" href="bt_m_l_c_p_solver_8h-source.html">btMLCPSolver.h</a>.</p>

<p>Referenced by <a class="el" href="bt_m_l_c_p_solver_8cpp-source.html#l00154">createMLCPFast()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/MLCPSolvers/<a class="el" href="bt_m_l_c_p_solver_8h-source.html">btMLCPSolver.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletDynamics/MLCPSolvers/<a class="el" href="bt_m_l_c_p_solver_8cpp-source.html">btMLCPSolver.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:01:29 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
