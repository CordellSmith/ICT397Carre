<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Assignment2 - OOber Taxi: btConvex2dConvex2dAlgorithm Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>btConvex2dConvex2dAlgorithm Class Reference</h1><!-- doxytag: class="btConvex2dConvex2dAlgorithm" --><!-- doxytag: inherits="btActivatingCollisionAlgorithm" --><code>#include &lt;<a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html">btConvex2dConvex2dAlgorithm.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for btConvex2dConvex2dAlgorithm:</div>
<div class="dynsection">
<p><center><img src="classbt_convex2d_convex2d_algorithm__inherit__graph.png" border="0" usemap="#bt_convex2d_convex2d_algorithm__inherit__map" alt="Inheritance graph"></center>
<map name="bt_convex2d_convex2d_algorithm__inherit__map">
<area shape="rect" href="classbt_activating_collision_algorithm.html" title="This class is not enabled yet (work&#45;in&#45;progress) to more aggressively activate objects..." alt="" coords="9,80,201,107"><area shape="rect" href="classbt_collision_algorithm.html" title="btCollisionAlgorithm" alt="" coords="37,5,173,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for btConvex2dConvex2dAlgorithm:</div>
<div class="dynsection">
<p><center><img src="classbt_convex2d_convex2d_algorithm__coll__graph.png" border="0" usemap="#bt_convex2d_convex2d_algorithm__coll__map" alt="Collaboration graph"></center>
<map name="bt_convex2d_convex2d_algorithm__coll__map">
<area shape="rect" href="classbt_activating_collision_algorithm.html" title="This class is not enabled yet (work&#45;in&#45;progress) to more aggressively activate objects..." alt="" coords="5,173,197,200"><area shape="rect" href="classbt_collision_algorithm.html" title="btCollisionAlgorithm" alt="" coords="33,96,169,123"><area shape="rect" href="classbt_dispatcher.html" title="btDispatcher" alt="" coords="55,5,148,32"><area shape="rect" href="classbt_convex_penetration_depth_solver.html" title="ConvexPenetrationDepthSolver provides an interface for penetration depth calculation..." alt="" coords="221,173,429,200"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classbt_convex2d_convex2d_algorithm-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual btScalar&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex2d_convex2d_algorithm.html#32bf85e0246ed54dd41edd861294c37e">calculateTimeOfImpact</a> (btCollisionObject *body0, btCollisionObject *body1, const btDispatcherInfo &amp;dispatchInfo, <a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *resultOut)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbt_convex2d_convex2d_algorithm.html#de3af2f3f04d9b202535d33550a94be4">getAllContactManifolds</a> (<a class="el" href="classbt_aligned_object_array.html">btManifoldArray</a> &amp;manifoldArray)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The convex2dConvex2dAlgorithm collision algorithm support 2d collision detection for btConvex2dShape Currently it requires the <a class="el" href="classbt_minkowski_penetration_depth_solver.html">btMinkowskiPenetrationDepthSolver</a>, it has support for 2d penetration depth computation 
<p>Definition at line <a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html#l00033">33</a> of file <a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html">btConvex2dConvex2dAlgorithm.h</a>.</p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="32bf85e0246ed54dd41edd861294c37e"></a><!-- doxytag: member="btConvex2dConvex2dAlgorithm::calculateTimeOfImpact" ref="32bf85e0246ed54dd41edd861294c37e" args="(btCollisionObject *body0, btCollisionObject *body1, const btDispatcherInfo &amp;dispatchInfo, btManifoldResult *resultOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btScalar btConvex2dConvex2dAlgorithm::calculateTimeOfImpact           </td>
          <td>(</td>
          <td class="paramtype">btCollisionObject *&nbsp;</td>
          <td class="paramname"> <em>body0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btCollisionObject *&nbsp;</td>
          <td class="paramname"> <em>body1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btDispatcherInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatchInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbt_manifold_result.html">btManifoldResult</a> *&nbsp;</td>
          <td class="paramname"> <em>resultOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Rather then checking ALL pairs, only calculate TOI when motion exceeds threshold<p>
Linear motion for one of objects needs to exceed m_ccdSquareMotionThreshold col0-&gt;m_worldTransform,<p>
Convex0 against sphere for Convex1<p>
Simplification, one object is simplified as a sphere<p>
Sphere (for convex0) against Convex1<p>
Simplification, one object is simplified as a sphere 
<p>Implements <a class="el" href="classbt_collision_algorithm.html">btCollisionAlgorithm</a>.</p>

<p>Definition at line <a class="el" href="bt_convex2d_convex2d_algorithm_8cpp-source.html#l00151">151</a> of file <a class="el" href="bt_convex2d_convex2d_algorithm_8cpp-source.html">btConvex2dConvex2dAlgorithm.cpp</a>.</p>

<p>References <a class="el" href="bt_gjk_convex_cast_8cpp-source.html#l00037">btGjkConvexCast::calcTimeOfImpact()</a>, and <a class="el" href="_g_l_m_2include_2_g_l_m_2gtx_2quaternion_8inl-source.html#l00164">glm::length2()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00152"></a>00152 {
<a name="l00153"></a>00153         (void)resultOut;
<a name="l00154"></a>00154         (void)dispatchInfo;
<a name="l00156"></a>00156 
<a name="l00159"></a>00159         btScalar resultFraction = btScalar(1.);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         btScalar squareMot0 = (col0-&gt;getInterpolationWorldTransform().getOrigin() - col0-&gt;getWorldTransform().getOrigin()).<a class="code" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d">length2</a>();
<a name="l00163"></a>00163         btScalar squareMot1 = (col1-&gt;getInterpolationWorldTransform().getOrigin() - col1-&gt;getWorldTransform().getOrigin()).<a class="code" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d">length2</a>();
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         <span class="keywordflow">if</span> (squareMot0 &lt; col0-&gt;getCcdSquareMotionThreshold() &amp;&amp;
<a name="l00166"></a>00166                 squareMot1 &lt; col1-&gt;getCcdSquareMotionThreshold())
<a name="l00167"></a>00167                 <span class="keywordflow">return</span> resultFraction;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 
<a name="l00170"></a>00170         <span class="comment">//An adhoc way of testing the Continuous Collision Detection algorithms</span>
<a name="l00171"></a>00171         <span class="comment">//One object is approximated as a sphere, to simplify things</span>
<a name="l00172"></a>00172         <span class="comment">//Starting in penetration should report no time of impact</span>
<a name="l00173"></a>00173         <span class="comment">//For proper CCD, better accuracy and handling of 'allowed' penetration should be added</span>
<a name="l00174"></a>00174         <span class="comment">//also the mainloop of the physics should have a kind of toi queue (something like Brian Mirtich's application of Timewarp for Rigidbodies)</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179                 btConvexShape* convex0 = <span class="keyword">static_cast&lt;</span>btConvexShape*<span class="keyword">&gt;</span>(col0-&gt;getCollisionShape());
<a name="l00180"></a>00180 
<a name="l00181"></a>00181                 btSphereShape   sphere1(col1-&gt;getCcdSweptSphereRadius()); <span class="comment">//todo: allow non-zero sphere sizes, for better approximation</span>
<a name="l00182"></a>00182                 <a class="code" href="structbt_convex_cast_1_1_cast_result.html">btConvexCast::CastResult</a> result;
<a name="l00183"></a>00183                 btVoronoiSimplexSolver voronoiSimplex;
<a name="l00184"></a>00184                 <span class="comment">//SubsimplexConvexCast ccd0(&amp;sphere,min0,&amp;voronoiSimplex);</span>
<a name="l00186"></a>00186 <span class="comment"></span>                <a class="code" href="classbt_gjk_convex_cast.html" title="GjkConvexCast performs a raycast on a convex object using support mapping.">btGjkConvexCast</a> ccd1( convex0 ,&amp;sphere1,&amp;voronoiSimplex);
<a name="l00187"></a>00187                 <span class="comment">//ContinuousConvexCollision ccd(min0,min1,&amp;voronoiSimplex,0);</span>
<a name="l00188"></a>00188                 <span class="keywordflow">if</span> (ccd1.calcTimeOfImpact(col0-&gt;getWorldTransform(),col0-&gt;getInterpolationWorldTransform(),
<a name="l00189"></a>00189                         col1-&gt;getWorldTransform(),col1-&gt;getInterpolationWorldTransform(),result))
<a name="l00190"></a>00190                 {
<a name="l00191"></a>00191 
<a name="l00192"></a>00192                         <span class="comment">//store result.m_fraction in both bodies</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194                         <span class="keywordflow">if</span> (col0-&gt;getHitFraction()&gt; result.m_fraction)
<a name="l00195"></a>00195                                 col0-&gt;setHitFraction( result.m_fraction );
<a name="l00196"></a>00196 
<a name="l00197"></a>00197                         <span class="keywordflow">if</span> (col1-&gt;getHitFraction() &gt; result.m_fraction)
<a name="l00198"></a>00198                                 col1-&gt;setHitFraction( result.m_fraction);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200                         <span class="keywordflow">if</span> (resultFraction &gt; result.m_fraction)
<a name="l00201"></a>00201                                 resultFraction = result.m_fraction;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203                 }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00211"></a>00211         {
<a name="l00212"></a>00212                 btConvexShape* convex1 = <span class="keyword">static_cast&lt;</span>btConvexShape*<span class="keyword">&gt;</span>(col1-&gt;getCollisionShape());
<a name="l00213"></a>00213 
<a name="l00214"></a>00214                 btSphereShape   sphere0(col0-&gt;getCcdSweptSphereRadius()); <span class="comment">//todo: allow non-zero sphere sizes, for better approximation</span>
<a name="l00215"></a>00215                 <a class="code" href="structbt_convex_cast_1_1_cast_result.html">btConvexCast::CastResult</a> result;
<a name="l00216"></a>00216                 btVoronoiSimplexSolver voronoiSimplex;
<a name="l00217"></a>00217                 <span class="comment">//SubsimplexConvexCast ccd0(&amp;sphere,min0,&amp;voronoiSimplex);</span>
<a name="l00219"></a>00219 <span class="comment"></span>                <a class="code" href="classbt_gjk_convex_cast.html" title="GjkConvexCast performs a raycast on a convex object using support mapping.">btGjkConvexCast</a> ccd1(&amp;sphere0,convex1,&amp;voronoiSimplex);
<a name="l00220"></a>00220                 <span class="comment">//ContinuousConvexCollision ccd(min0,min1,&amp;voronoiSimplex,0);</span>
<a name="l00221"></a>00221                 <span class="keywordflow">if</span> (ccd1.calcTimeOfImpact(col0-&gt;getWorldTransform(),col0-&gt;getInterpolationWorldTransform(),
<a name="l00222"></a>00222                         col1-&gt;getWorldTransform(),col1-&gt;getInterpolationWorldTransform(),result))
<a name="l00223"></a>00223                 {
<a name="l00224"></a>00224 
<a name="l00225"></a>00225                         <span class="comment">//store result.m_fraction in both bodies</span>
<a name="l00226"></a>00226 
<a name="l00227"></a>00227                         <span class="keywordflow">if</span> (col0-&gt;getHitFraction()      &gt; result.m_fraction)
<a name="l00228"></a>00228                                 col0-&gt;setHitFraction( result.m_fraction);
<a name="l00229"></a>00229 
<a name="l00230"></a>00230                         <span class="keywordflow">if</span> (col1-&gt;getHitFraction() &gt; result.m_fraction)
<a name="l00231"></a>00231                                 col1-&gt;setHitFraction( result.m_fraction);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233                         <span class="keywordflow">if</span> (resultFraction &gt; result.m_fraction)
<a name="l00234"></a>00234                                 resultFraction = result.m_fraction;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236                 }
<a name="l00237"></a>00237         }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239         <span class="keywordflow">return</span> resultFraction;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241 }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e_cgraph.png" border="0" usemap="#classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e_cgraph_map" alt=""></center>
<map name="classbt_convex2d_convex2d_algorithm_32bf85e0246ed54dd41edd861294c37e_cgraph_map">
<area shape="rect" href="classbt_gjk_convex_cast.html#814009e1ebc582495689f365a42ce2c1" title="cast a convex against another convex object" alt="" coords="396,31,628,57"><area shape="rect" href="group__gtx__quaternion.html#ge0ff959e757f5feba0bd375658673d0d" title="glm::length2" alt="" coords="467,81,557,108"><area shape="rect" href="structbt_convex_cast_1_1_cast_result.html#febcf038c88ef123c0570d5ab79cb3c6" title="btConvexCast::CastResult::DebugDraw" alt="" coords="677,5,925,32"><area shape="rect" href="classbt_gjk_pair_detector.html#42505a0ccc728c82595febe9af3a3bc8" title="btGjkPairDetector::getClosestPoints" alt="" coords="685,56,917,83"></map>
</div>

</div>
</div><p>
<a class="anchor" name="de3af2f3f04d9b202535d33550a94be4"></a><!-- doxytag: member="btConvex2dConvex2dAlgorithm::getAllContactManifolds" ref="de3af2f3f04d9b202535d33550a94be4" args="(btManifoldArray &amp;manifoldArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btConvex2dConvex2dAlgorithm::getAllContactManifolds           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbt_aligned_object_array.html">btManifoldArray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>manifoldArray</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
should we use m_ownManifold to avoid adding duplicates? 
<p>Implements <a class="el" href="classbt_collision_algorithm.html">btCollisionAlgorithm</a>.</p>

<p>Definition at line <a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html#l00054">54</a> of file <a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html">btConvex2dConvex2dAlgorithm.h</a>.</p>

<p>References <a class="el" href="bt_aligned_object_array_8h-source.html#l00274">btAlignedObjectArray&lt; T &gt;::push_back()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00055"></a>00055         {
<a name="l00057"></a>00057                 <span class="keywordflow">if</span> (m_manifoldPtr &amp;&amp; m_ownManifold)
<a name="l00058"></a>00058                         manifoldArray.<a class="code" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1">push_back</a>(m_manifoldPtr);
<a name="l00059"></a>00059         }
</pre></div>
<p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4_cgraph.png" border="0" usemap="#classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4_cgraph_map" alt=""></center>
<map name="classbt_convex2d_convex2d_algorithm_de3af2f3f04d9b202535d33550a94be4_cgraph_map">
<area shape="rect" href="classbt_aligned_object_array.html#d61e10166e2c00f487095d3482b9edd1" title="btAlignedObjectArray::push_back" alt="" coords="395,5,611,32"></map>
</div>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/<a class="el" href="bt_convex2d_convex2d_algorithm_8h-source.html">btConvex2dConvex2dAlgorithm.h</a><li>C:/Users/New/Documents/Games_Technology/Year4_Semester1/ICT397/~My Work/Assignment2/ICT397Carre/CarreGameEngine/Dependencies/BulletPhysicsEngine/include/BulletCollision/CollisionDispatch/<a class="el" href="bt_convex2d_convex2d_algorithm_8cpp-source.html">btConvex2dConvex2dAlgorithm.cpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jun 1 13:00:55 2018 for Assignment2 - OOber Taxi by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
